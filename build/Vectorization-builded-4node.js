
/*
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization © 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/
if(typeof window === 'undefined'){
    global.VECTORIZATION_BUILD = true;
    global.VECTORIZATION_BUILD_TYPE = 'node';
}else{
    window.VECTORIZATION_BUILD = true;
    window.VECTORIZATION_BUILD_TYPE = 'navegador';
}

/* COMPILADO: 24/11/2024 - 14:21:37*//* ARQUIVO VECTORIZATION: ../src/Root.js*/
/*
 * File Name: Root.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }

    globalThis.require = function(){};
}

if(!window.Vectorization){ window.Vectorization = {} };

/**
 * Base class for all other components.
 * @param {Object} config;
 * @returns {Vectorization.Base}
 */
window.Vectorization.Base = function(config){
    const context = {};
    context._config = config;
    context.objectName = 'Base';
    context.extendedFrom = 'Base';
    context.namespace = 'window.Vectorization';
    context.path = 'Vectorization.Base';
    context.autoGeneratedGetters = [];
    context.autoGeneratedSetters = [];
    context._translations = config.translations;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    context.copyArgs = function(config){
        //Copia os argumentos
        let configKeys = Object.keys(config);
        for( let i = 0 ; i < configKeys.length ; i++){
            context[ configKeys[i] ] = config[ configKeys[i] ];
        }
    }

    context.copyArgsSeNaoExistir = function(config, aplicarBind=true){
        //Copia os argumentos
        let configKeys = Object.keys(config);

        for( let i = 0 ; i < configKeys.length ; i++){

            if( context[ configKeys[i] ] == undefined )
            {
                context[ configKeys[i] ] = config[ configKeys[i] ];
                if(aplicarBind == true && context[ configKeys[i] ].bind != undefined){
                    context[ configKeys[i] ].bind(context);
                }
            }

        }
    }

    context._doDefaultBaseAfterCreate = function(){
        context.createGettersFromOriginalProperties();
        context.createSettersFromOriginalProperties();
    }

    context.createGettersFromOriginalProperties = function(){
        //Getters
        Object.keys( context ).forEach( function(attrib){
            const nameOfGetter = `get${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfGetter] ){
                context[nameOfGetter] = function(){
                    return context[attrib];
                }
                context.autoGeneratedGetters.push(nameOfGetter);
            }
        });
    }

    context.createSettersFromOriginalProperties = function(){
        //Setters
        Object.keys( context ).forEach( function(attrib){
            const nameOfSetter = `set${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfSetter] ){
                context[nameOfSetter] = function(valueToDefine){
                    context[attrib] = valueToDefine; 
                }
                context.autoGeneratedSetters.push(nameOfSetter);
            }
        });
    }

    //MÃ©todos responsavel por fazer as traduÃ§Ãµes dos mÃ©todos
    context.translateMethods = function(translations) {
        let translationsKeys;

        //Traduz os mÃ©todos
        translationsKeys = Object.keys(translations.translatedMethods);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedMethods[nomeMetodoTraduzido];

           //Aplica a traduÃ§Ã£o
           if(typeof context[nomeOriginal] === 'function'){
               context[nomeMetodoTraduzido] = context[nomeOriginal].bind(context);
           }
        }
    }

    //MÃ©todos responsavel por fazer as traduÃ§Ãµes dos atributos
    context.translateAttributes = function(translations) {
        let translationsKeys;

        //Traduz os atributos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           //Aplica a traduÃ§Ã£o no atributo
           if(context[nomeOriginal] != undefined && typeof context[nomeOriginal] != 'function' && !context[nomeMetodoTraduzido] ){
              context[nomeMetodoTraduzido] = context[nomeOriginal];
           }
        }
    }

    //Parecido com a funÃ§Ã£o translateAttributes, porÃ©m ele faz essa traduÃ§Ã£o e retorna um objeto com as traduÃ§Ãµes aplicadas
    //No caso o translationsDicionario pode ser um objeto ja pronto que sÃ³ precisa ser traduzido
    //Isso vai ser usado na inicializaÃ§Ã£o de algumas classes como Vectorization.Matrix e Vectorization.Vector
    context.translateAttributes_andReturn = function(propioDicionario, translations){
        let translationsKeys;
        let novoObjeto = {... propioDicionario};

        //Traduz os atributos
        translationsKeys = Object.keys(propioDicionario);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           if( nomeOriginal != undefined && !propioDicionario[nomeOriginal] ){
               novoObjeto[nomeOriginal] = propioDicionario[nomeMetodoTraduzido];
           }
        }

        return novoObjeto;
    }

    //Para nÃ£o ter problemas com atributos desatualizados
    context.atualizarAtributosTraduzidos = function(translations=context._internal_translations){
        let translationsKeys;

        //Pegar os atributos traduzidos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
            const nomeMetodoTraduzido = translationsKeys[i];
            const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

            if( nomeOriginal != undefined && 
                typeof context[nomeMetodoTraduzido] != 'function' && 
                typeof context[nomeOriginal] != 'function' &&
                context[nomeOriginal] != undefined &&
                context[nomeMetodoTraduzido] != undefined
            ){
                context[nomeMetodoTraduzido] = context[nomeOriginal];
            }
        }
    }

    //Start class
    context.copyArgs(config);
    context._doDefaultBaseAfterCreate();

    context.applyTranslations = function(translationFunction=null){
        //Se existir uma traduÃ§Ã£o para a classe
        if(context._translations && typeof context._translations === 'function'){
            context._internal_translations = translationFunction || context._translations();
            context.translateMethods( context._internal_translations );
            context.translateAttributes( context._internal_translations );
        }
    }

    context.applyTranslations(null);

    context.getTodasConfiguracoesAplicadas = function(){
        let todasConfiguracoesClassConfig = {};
        let keysConfiguracoesClassConfig = [... Object.keys(context)];

        for( let i = 0 ; i < keysConfiguracoesClassConfig.length ; i++ )
        {
            let nomeConfiguracaoClassConfig = keysConfiguracoesClassConfig[i],
                valorConfiguracaoClassConfig = context[nomeConfiguracaoClassConfig];
            
            todasConfiguracoesClassConfig[nomeConfiguracaoClassConfig] = valorConfiguracaoClassConfig;
        }

        return { 
                  configuracoesUsadas: todasConfiguracoesClassConfig,
                  quantidadeDentro: keysConfiguracoesClassConfig.length
               };
    }

    context.herdarFuncoes = function(referenciaObjeto){
        const templateObjetoCriado = referenciaObjeto();
        const contextObjetoCriado = templateObjetoCriado;
        
        //Aplica dentro deste objeto do Vectorization
        context.copyArgsSeNaoExistir(contextObjetoCriado); 
    }

    return context;
}

//FunÃ§Ãµes a nivel principal

/**
 * Gera uma matrix de identidade
 * @param {Number} ordem 
 * @returns {Vectorization.Matrix}
*/
window.Vectorization.matrixIdentidade = function(ordem){
    const NON_DIAGONAL_VALUE = 0;
    const DIAGONAL_VALUE = 1;
    let matrix = [];

    for( let i = 0 ; i < ordem ; i++ )
    {
        matrix[i] = [];
        for( let j = 0 ; j < ordem ; j++ )
        {
            //NA LINHA ATUAL, Toda vez que o indice do nÃºmero for igual ao indice da linha, ele faz parte da diagonal principal
            if( j == i ){
                matrix[i][j] = DIAGONAL_VALUE;

            }else{
                matrix[i][j] = NON_DIAGONAL_VALUE;
            }
        }
    }

    const extraProps = {
        isIdentidade: true
    }

    return Vectorization.Matrix(matrix, extraProps);
}

window.Vectorization.identificarTipo = function(obj){
    //Se for um objeto do Vectorization
    if( obj instanceof Object && obj.objectName != undefined ){

        if( Vectorization.Scalar.isScalar( obj ) ){
            return 'Scalar';

        }else if( Vectorization.Text.isText( obj ) ){
            return 'Text';

        }else{
            return undefined;
        }

    }else{
        if( typeof obj == 'number' ){
            return 'Scalar';

        }else if( typeof obj == 'string' ){
            return 'Text';
        }
    }

    return undefined;
}

window.Vectorization.isAlgumValorVectorization = function(obj){
    return window.Vectorization.identificarTipo(obj) != undefined && 
           obj instanceof Object && 
           obj.objectName != undefined;
}

window.Vectorization.isAlgumVetorVectorization = function(obj){
    return window.Vectorization.Vector.isVectorizationVector(obj) ||
           window.Vectorization.StringVector.isVectorizationStringVector(obj) ||
           window.Vectorization.BendableVector.isVectorizationBendableVector(obj);
}

module.exports = window.Vectorization.Root;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Root.js*/
/* ARQUIVO VECTORIZATION: ../src/Utilidades.js*/
/*
 * File Name: Utils.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Utilidades = {};

window.Vectorization.Utilidades.apenasNumeros = function(stringObj){
    let apenasNumeros = true;
    let tamanhoString = stringObj.length;
    for( let letra = 0 ; letra < tamanhoString ; letra++ )
    {       
        if( !isNaN( Number(stringObj[letra]) ) || stringObj[letra] == '.' ){
            apenasNumeros = true;

        }else{
            apenasNumeros = false;
            break;
        }
    }

    return apenasNumeros;
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/Utilidades.js*/
/* ARQUIVO VECTORIZATION: ../src/Scalar.js*/
/*
 * File Name: Scalar.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 

    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Random'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Scalar = function( value=NaN, classConfig={} ){
    //Define a traduÃ§Ã£o
    classConfig['translations'] = window.Vectorization.Scalar._translations || null;

    let classeBaseEscalar = window.Vectorization.Base({... classConfig});

    //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseEscalar.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( value.objectName != undefined && value.objectName == 'Scalar' ){
        return Vectorization.Scalar( value.raw(), {... classConfig} );
    }

    //let context = {... classConfig};
    let context = window.Vectorization.Base({... classConfig});

    if( value != undefined && 
        !(value instanceof Object) &&
        (typeof value == 'number' || Vectorization.Utilidades.apenasNumeros(value)) == true
    ){
        context.value = Number(value);
        context.configuracoesValue = {};
    
    //Se for um objeto com configuraÃ§Ãµes
    }else if(value instanceof Object){

        //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
        value = classeBaseEscalar.translateAttributes_andReturn(value, classConfig['translations']() );

        //Salva a config
        context.configuracoesValue = {... value};

        if( value.aleatorio == true ){
            if( value.minimo != undefined && value.maximo != undefined ){
                context.aleatorio = true;
                context.ultimoMaximoUsado = value.maximo;
                context.ultimoMinimoUsado = value.minimo;
                context.sementeAleatoria = context.sementeAleatoria || Vectorization.Random._sementeDefinida;

                if( value.sementeAleatoria != undefined ){
                    context.sementeAleatoria = value.sementeAleatoria;

                    if( typeof value.sementeAleatoria == 'number' ){
                        context.numeroSemente = value.sementeAleatoria;
                    }
                }

                context.value = Vectorization.Random.gerarNumeroAleatorio( Number(value.minimo), Number(value.maximo), context.sementeAleatoria );
                if( value.arredondar != undefined ){
                    switch(value.arredondar){
                        case true:
                            context.value = Math.round(context.value);
                            break;

                        case 'cima':
                        case 'up':
                            context.value = Math.ceil(context.value);
                            break;
            
                        case 'baixo':
                        case 'down':
                            context.value = Math.floor(context.value);
                            break;

                        case 'automatico':
                        case 'auto':
                            context.value = Math.round(context.value);
                            break;
                    }
                }

            }else{
                throw 'Para criar um Scalar aleatÃ³rio voce precisar passar a faixa de valores!';
            }

        }else{
            //Se nao for aleatorio
            if( value.value != undefined ){
                if( typeof value.value == 'string' ){
                    context.value = value.value;
                    
                }else{
                    context.value = Number(value.value);
                }
            }
        }
    }

    context.objectName = 'Scalar';
    context.path = 'Vectorization.Scalar';

    context.storedClassConfig = classConfig || {};

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Scalar!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;
        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Scalar!';
        }
    }

    context.obterValor = function(){
        return context.value;
    }

    //Troca o nÃºmero aleatorio dentro desse Vectorization.Scalar
    context.trocarNumeroAleatorio = function(novoMinimo=context.ultimoMinimoUsado, novoMaximo=context.ultimoMaximoUsado, novaSemente=null){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Scalar
        if( context._isBloqueado() == true ){
           throw 'Este Vectorization.Scalar estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        if( context.aleatorio == true ){

            if( novoMinimo == null ){
                novoMinimo = context.ultimoMinimoUsado;
            }

            if( novoMaximo == null ){
                novoMaximo = context.ultimoMaximoUsado;
            }

            if( novaSemente == null ){
                novaSemente = context.sementeAleatoria;

            }else{
                context.sementeAleatoria = Vectorization.Random._get_dados_semente(novaSemente);
                
                if( typeof novaSemente == 'number' ){
                    context.numeroSemente = novaSemente;
                }
            }

            context.ultimoMaximoUsado = novoMaximo;
            context.ultimoMinimoUsado = novoMinimo;

            context.value = Vectorization.Random.gerarNumeroAleatorio( Number(novoMinimo), Number(novoMaximo), novaSemente );
            if( value.arredondar != undefined ){
                switch(value.arredondar){
                    case true:
                        context.value = Math.round(context.value);
                        break;

                    case 'cima':
                    case 'up':
                        context.value = Math.ceil(context.value);
                        break;
        
                    case 'baixo':
                    case 'down':
                        context.value = Math.floor(context.value);
                        break;

                    case 'automatico':
                    case 'auto':
                        context.value = Math.round(context.value);
                        break;
                }
            }

            return context.value;

        }else{
            throw 'Este objeto nÃ£o Ã© aleatÃ³rio!';
        }
    }

    context.valueOf = function(){
        return Number.parseFloat( context.value );
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.Text( context.valueOf(), novasConfiguracoes );
    }

    context.toString = function(){
        return String(context.value);
    }

    context.raw = function(){
        return context.value + 0;
    }

    context.somarNumero = function(numero){
        return Vectorization.Scalar(context.value + numero, {... classConfig});
    }

    context.subtrairNumero = function(numero){
        return Vectorization.Scalar(context.value - numero, {... classConfig});
    }

    context.dividirNumero = function(numero){
        return Vectorization.Scalar(context.value / numero, {... classConfig});
    }

    context.multiplicarNumero = function(numero){
        return Vectorization.Scalar(context.value * numero, {... classConfig});
    }

    context.elevarNumero = function(numero){
        return Vectorization.Scalar(Math.pow(context.value, numero), {... classConfig});
    }

    context.aoQuadrado = function(){
        return Vectorization.Scalar(context.elevarNumero(2), {... classConfig});
    }

    context.metade = function(){
        return Vectorization.Scalar(context.dividirNumero(2), {... classConfig});
    }

    //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
    context.bloqueado = (classConfig['bloqueado'] != undefined) ? (classConfig['bloqueado']) : false;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se existir uma traduÃ§Ã£o para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //return context;
    return new Proxy(context, {
        
        set: function(target, prop, value) {
          //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Scalar
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Scalar estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'VocÃª nÃ£o pode modificar esta atributo do Vectorization.Vector!';
          }

          return Reflect.set(target, prop, value);
        }
    });
}

/**
* MÃ©todos estÃ¡ticos
*/
window.Vectorization.Scalar.isScalar = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Scalar') || typeof obj == 'number';
}

window.Vectorization.Scalar.isVectorizationScalar = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Scalar');
}

module.exports = window.Vectorization.Scalar;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Scalar.js*/
/* ARQUIVO VECTORIZATION: ../src/Scalar-translation.js*/
/*
 * File Name: Scalar-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Scalar._translations = function(){
    const translatedMethods = {
        'elevarQuadrado': 'aoQuadrado',
        'elevarAoQuadrado': 'aoQuadrado'
    };

    const translatedAttributes = {
        'valor': 'value',
        'conteudo': 'value'
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Scalar._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Scalar-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Text.js*/
/*
 * File Name: Text.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Scalar'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Text = function( value=NaN, classConfig={} ){
    //Define a traduÃ§Ã£o
    classConfig['translations'] = window.Vectorization.Text._translations || null;

    let classeBaseEscalar = window.Vectorization.Base({... classConfig});

    //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseEscalar.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    if( value.objectName != undefined && value.objectName == 'Text' ){
        return Vectorization.Text( value.raw(), {... classConfig} );
    }

    //let context = {... classConfig};
    let context = window.Vectorization.Base({... classConfig});

    if( value != undefined && 
        !(value instanceof Object) &&
        (typeof value == 'string' || Vectorization.Utilidades.apenasNumeros(value)) == true
    ){

        context.value = String(value);
        context.configuracoesValue = {};
    
    //Se for um objeto com configuraÃ§Ãµes
    }else if(value instanceof Object){

        //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
        value = classeBaseEscalar.translateAttributes_andReturn(value, classConfig['translations']() );

        //Salva a config
        context.configuracoesValue = {... value};

        if( value.value != undefined ){
            if( typeof value.value == 'string' ){
                context.value = value.value;
                
            }else{
                context.value = String(value.value);
            }
        }
    }

    if(context.value == undefined){
        if( Vectorization.Scalar.isScalar(value) == true ){
            context.value = String(value);   
        }
    }

    context.objectName = 'Text';
    context.path = 'Vectorization.Text';

    context.storedClassConfig = classConfig || {};

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Scalar!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;
        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Scalar!';
        }
    }

    context.obterValor = function(){
        return context.value;
    }

    context.valueOf = function(){
        return String( context.value );
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.Scalar( context.valueOf(), novasConfiguracoes );
    }

    context.toString = function(){
        return String(context.value);
    }

    context.raw = function(){
        return context.value;
    }

    /**
    * Transforma este Vectorization.Text em um Vectorization.StringVector
    * Transform this Vectorization.Text into a Vectorization.StringVector
    * @returns {Vectorization.StringVector}
    */
    context.toCharacterVector = function(){
        let esteTexto = context;
        return Vectorization.StringVector( esteTexto.obterValor().split('') );
    }
    context.paraVetorCaracteres = context.toCharacterVector;


    context.letrasMaiusculas = function(){
        return Vectorization.Text( String( context.obterValor() ).toUpperCase() );
    }
    context.toUpperCase = context.letrasMaiusculas;


    
    context.letrasMinusculas = function(){
        return Vectorization.Text( String( context.obterValor() ).toLowerCase() );
    }
    context.toLowerCase = context.letrasMinusculas;

    /**
    * Verifica se este Vectorization.Text Ã© igual a outro Vectorization.Text
    * @param {Vectorization.Text} outroTexto 
    * @returns {Boolean}
    */
    context.isIgual = function(outroTexto){
        let outroTexto_Text = Vectorization.Text.isVectorizationText(outroTexto) == false ? Vectorization.Text(outroTexto) : outroTexto;
        return Vectorization.Text.isText(outroTexto) && context.obterValor() === outroTexto_Text.obterValor();
    }

    /**
    * Calcula a distancia hamming deste Vectorization.Text com outro Vectorization.Text
    * @param {Vectorization.Text} outroTexto 
    * @returns {Vectorization.Scalar}
    */
    context.distanciaHamming = function(outroTexto){
        let outroTexto_Text = Vectorization.Text.isVectorizationText(outroTexto) == false ? Vectorization.Text(outroTexto) : outroTexto;
        let caracteresOutroTexto = outroTexto_Text.toCharacterVector();

        let esteTexto_Text = context;
        let caracteresEsteTexto = esteTexto_Text.toCharacterVector();

        let distanciaTotalCalculada = Vectorization.Scalar(0);

        caracteresEsteTexto.paraCadaElemento(function(i){
            let isIgual = (caracteresEsteTexto.lerIndice(i).isIgual( caracteresOutroTexto.lerIndice(i) ) ) == true ? 0 : 1;
            distanciaTotalCalculada = distanciaTotalCalculada.somarNumero( Vectorization.Scalar(isIgual) );
        });

        return Vectorization.Scalar(distanciaTotalCalculada);
    }

    //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
    context.bloqueado = (classConfig['bloqueado'] != undefined) ? (classConfig['bloqueado']) : false;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se existir uma traduÃ§Ã£o para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //return context;
    return new Proxy(context, {
        
        set: function(target, prop, value) {
          //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Scalar
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Text estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'VocÃª nÃ£o pode modificar esta atributo do Vectorization.Vector!';
          }

          return Reflect.set(target, prop, value);
        }
    });
}

/**
* MÃ©todos estÃ¡ticos
*/
window.Vectorization.Text.isText = function(obj){
    if(obj == undefined){return false};
    return (obj.objectName != undefined && obj.objectName == 'Text') || typeof obj == 'string';
}

window.Vectorization.Text.isVectorizationText = function(obj){
    if(obj == undefined){return false};
    return (obj.objectName != undefined && obj.objectName == 'Text');
}

module.exports = window.Vectorization.Text;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Text.js*/
/* ARQUIVO VECTORIZATION: ../src/Text-translation.js*/
/*
 * File Name: Text-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Text._translations = function(){
    const translatedMethods = {
        'isEquals': 'isIgual'
    };

    const translatedAttributes = {
        'valor': 'value',
        'conteudo': 'value'
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Text._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Text-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Boolean.js*/
/*
 * File Name: Boolean.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 

    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Random'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Boolean = function( value=NaN, classConfig={} ){
    //Define a traduÃ§Ã£o
    classConfig['translations'] = window.Vectorization.Boolean._translations || null;

    let classeBaseEscalar = window.Vectorization.Base({... classConfig});

    //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseEscalar.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( value.objectName != undefined && value.objectName == 'Boolean' ){
        return Vectorization.Boolean( value.raw(), {... classConfig} );
    }

    //let context = {... classConfig};
    let context = window.Vectorization.Base({... classConfig});

    if( classConfig.value ){
        value = classConfig.value;
    }

    if( value != undefined && 
        !(value instanceof Object) &&
        (typeof value == 'number' || typeof value == 'false' || typeof value == 'true' || Vectorization.Utilidades.apenasNumeros(value)) == true
    ){
        if( value > 1 ){
            throw 'Esse Vectorization.Boolean nÃ£o suporta valores maiores do que 1!';
        }

        if( value < 0 ){
            throw 'Esse Vectorization.Boolean nÃ£o suporta valores menores do que 0!';
        }

        context.value = Number(value);
        context.configuracoesValue = {};
    
    //Se for um objeto com configuraÃ§Ãµes
    }else if(value instanceof Object){

        //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
        value = classeBaseEscalar.translateAttributes_andReturn(value, classConfig['translations']() );

        //Salva a config
        context.configuracoesValue = {... value};

        if( value.value > 1 ){
            throw 'Esse Vectorization.Boolean nÃ£o suporta valores maiores do que 1!';
        }

        if( value.value < 0 ){
            throw 'Esse Vectorization.Boolean nÃ£o suporta valores menores do que 0!';
        }

        if( typeof value.value == 'string' ){
            context.value = value.value;
        }else{
            context.value = Number(value.value);
        }
    }

    if( typeof context.value == 'string' ){
        context.value = String(context.value).toLowerCase();
    }

    if( context.value == 'sim' || context.value == 'verdade' || context.value == 'afirmativo' || context.value == 'verdadeiro' ){
        context.value = Number(true);

    }else if( context.value == 'nao' || context.value == 'falso' || context.value == 'negativo' ){
        context.value = Number(false);
    }

    context.objectName = 'Boolean';
    context.path = 'Vectorization.Boolean';

    context.storedClassConfig = classConfig || {};

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Boolean!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;
        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Boolean!';
        }
    }

    context.obterValor = function(){
        return context.value;
    }

    context.valueOf = function(){
        return Number.parseFloat( context.value );
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.Text( context.valueOf(), novasConfiguracoes );
    }

    context.toString = function(){
        return String(context.value);
    }

    context.raw = function(){
        return context.value + 0;
    }

    context.toggle = function(){
        if( context.value == Number(true) ){
            context.value = Number(false);
            
        }else{
            context.value = Number(true);
        }
    }

    context.isTrue = function(){
        return context.value == Number(true);
    }

    context.isFalse = function(){
        return context.value == Number(false);
    }

    //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
    context.bloqueado = (classConfig['bloqueado'] != undefined) ? (classConfig['bloqueado']) : false;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se existir uma traduÃ§Ã£o para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //return context;
    return new Proxy(context, {
        
        set: function(target, prop, value) {
          //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Scalar
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Boolean estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'VocÃª nÃ£o pode modificar esta atributo do Vectorization.Boolean!';
          }

          return Reflect.set(target, prop, value);
        }
    });
}

/**
* MÃ©todos estÃ¡ticos
*/
window.Vectorization.Boolean.isBoolean = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Boolean') || typeof obj == 'number';
}

window.Vectorization.Boolean.isVectorizationBoolean = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Boolean');
}

module.exports = window.Vectorization.Boolean;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Boolean.js*/
/* ARQUIVO VECTORIZATION: ../src/Boolean-translation.js*/
/*
 * File Name: Boolean-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Boolean._translations = function(){
    const translatedMethods = {
        
    };

    const translatedAttributes = {
        'valor': 'value',
        'conteudo': 'value'
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Boolean._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Boolean-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Vector.js*/
/*
 * File Name: Vector.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    require('./Scalar');
    require('./Root');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Vector = function( config=[], classConfig={} ){
    //Define a traduÃ§Ã£o
    classConfig['translations'] = window.Vectorization.Vector._translations || null;

    //Por padrÃ£o o usarEscalares vai ser true
    if( config['usarEscalares'] == undefined && classConfig['usarEscalares'] == undefined && config['usarEscalares'] != false && classConfig['usarEscalares'] != false ){
        config['usarEscalares'] = true;
    }

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.Vector.isVector(config) && config.objectName == 'Vector' ){
        return Vectorization.Vector( config.values() );
    }

    let context = window.Vectorization.Base(classConfig);
    context.objectName = 'Vector';
    context.path = 'Vectorization.Vector';
    context.configRecebidaUsuario = config;

    context.storedClassConfig = classConfig || {};

    //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
    //classConfig = context.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Aplica a traduÃ§Ã£o dos atributos tambÃ©m no config, EXCETO SE config FOR UM ARRAY
    if( config instanceof Object && !(config instanceof Array && (config instanceof Array || Vectorization.Vector.isVector(config) )) ){
        config = context.translateAttributes_andReturn(config, classConfig['translations']() );
    }

    context.initialColumnValue = config['fillValue'] || 0;
    context.content = [];

    context.permitirDesbloquear = (config['permitirDesbloquear'] != undefined || classConfig['permitirDesbloquear'] != undefined) ? (config['permitirDesbloquear'] || classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (config['permitirBloquear'] != undefined || classConfig['permitirBloquear'] != undefined) ? (config['permitirBloquear'] || classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

            if(context.usarEscalares != undefined && context.usarEscalares == true)
            {
                //Bloquear tambÃ©m os filhos dentro deste Vectorization.Vector
                context.paraCadaElemento(function(i, elementoVetor){
                    elementoVetor.bloquearModificacoes();
                });
            }

        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Vector!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;

            if(context.usarEscalares != undefined && context.usarEscalares == true)
            {
                //Desbloquear tambÃ©m os filhos dentro deste Vectorization.Vector
                context.paraCadaElemento(function(i, elementoVetor){
                    elementoVetor.desbloquearModificacoes();
                });
            }
            
        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Vector!';
        }
    }

    context.trocarValoresAleatorios = function(novoMinimo=null, novoMaximo=null, novaSemente=null){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }
        
        if( context.usarEscalares == true )    
        {
            context.paraCadaElemento(function(i, elementoVetor){
                elementoVetor.trocarNumeroAleatorio(novoMinimo, novoMaximo, novaSemente);
            });

        }else{
            context.substituirElementosPor(
                context.mapearValores(function(i, elementoVetor){
                    return Vectorization.Scalar({
                        aleatorio: true,
                        minimo: 0,
                        maximo: 10
                    }).trocarNumeroAleatorio(novoMinimo, novoMaximo, novaSemente);
                })
            );
        }

        return context;
    }

    context._update = function(){
        context.length = config.length;
        context.elementos = config.length;
    }

    //Se passar diretamente o conteudo
    if( config instanceof Array ){
        context.content = config;
        context.length = config.length;

    //Ou caso contrario
    }else{
        if( config instanceof Object && config['length'] ){
            context.length = config['length'];
        }

        //Inicializa o vetor
        for( let i = 0 ; i < context.length ; i++ )
        {
            if( Vectorization.Vector.isVectorizationVector(context.initialColumnValue) == true ||
                Vectorization.Matrix.isMatrix(context.initialColumnValue) == true
            ){
                context.content[i] = context.initialColumnValue.duplicar();

            }else{
                context.content[i] = context.initialColumnValue;
            }
        }
    }

    /**
     * Permite definir uma posiÃ§Ã£o especifica deste vetor
     * @param {Number} indice 
     * @param {any} valor 
     */
    context.definirElementoNoIndice = function(indice, valor){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.content[indice] = valor;
    }

    context.estaVazio = function(){
        return context.tamanho() == 0 ? true : false;
    }
    context.isVazio = context.estaVazio;

    /**
     * Permite trocar todos os valores deste vetor, elemento a elemento
     * por valores que vem de outro vetor, com a mesma quantidade de elementos
     * 
     * @param {Vectorization.Vector} outroVector - O outro vetor que contem os valores
     * @returns {Vectorization.Vector}
     */
    context.substituirElementosPor = function(outroVector){
        let valoresASeremColocados = (Vectorization.Vector.isVector(outroVector) && Vectorization.Vector.isVectorizationVector(outroVector)) ? outroVector.valores() : outroVector;
        let tamanhoSegundoVetor = (Vectorization.Vector.isVector(outroVector) && Vectorization.Vector.isVectorizationVector(outroVector)) ? outroVector.tamanho() : outroVector.length;

        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        if(context.tamanho() != tamanhoSegundoVetor){
            throw 'O tamanho do outroVetor precisa ser o mesmo!';
        }
        
        if( context.tamanho() > 0 )
        {
            Vectorization.Vector(context.content).paraCadaElemento(function(indiceTrocar, elementoTrocar){
                context.definirElementoNoIndice(indiceTrocar, valoresASeremColocados[indiceTrocar]);
            });

        }else{
            throw 'O Vectorization.Vector nÃ£o pode estar vazio!';
        }

        return valoresASeremColocados;
    }

    /**
     * Permite trocar todos os valores deste vetor, PORÃM nÃ£o elemento a elemento
     * Ele vai casar os indices deste Vectorization.Vector com o vetor de objetos que identificam os indices e os valores
     * 
     * @param {Vectorization.Vector} outroVectorDeInformacoes - O outro vetor que contem os valores
     * @returns {Vectorization.Vector}
     */
    context.substituirElementosPorIndice = function(outroVectorDeInformacoes){
        let valoresASeremColocados = (Vectorization.Vector.isVector(outroVectorDeInformacoes) && Vectorization.Vector.isVectorizationVector(outroVectorDeInformacoes)) ? outroVectorDeInformacoes.valores() : outroVectorDeInformacoes;
    
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        if( context.tamanho() > 0 )
        {
            Vectorization.Vector(valoresASeremColocados).paraCadaElemento(function(indice, elementoComAsInformacoes){
                let indiceTrocar = elementoComAsInformacoes.indice;
                let valorASerColocado = elementoComAsInformacoes.valor;
                
                context.definirElementoNoIndice(indiceTrocar, valorASerColocado);
            });

        }else{
            throw 'O Vectorization.Vector nÃ£o pode estar vazio!';
        }

        return context;
    }

    context.toText = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.StringVector( context.raw(), novasConfiguracoes);
    }

    context.values = function(){
        if( context.usarEscalares == true ){
            return context.raw();

        }else{
            return context.content;
        }
    }

    //Alias for context.values
    context.valores = context.values;

    context.toArray = function(){
        if( context.usarEscalares != undefined && context.usarEscalares == true )
        {
            let valoresSemEstarEmEscalar = [];
            context.paraCadaElemento(function(i, objetoEscalar){

                if( objetoEscalar.obterValor == undefined && 
                    typeof objetoEscalar == 'number' 
                
                ){
                    valoresSemEstarEmEscalar.push( objetoEscalar );

                }else{
                    valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );
                }
            });

            return valoresSemEstarEmEscalar;

        }else{
            return context.content;
        }
    }

    //Alias for context.toArray
    context.raw = context.toArray;

    context.rawProfundo = function(){
        if( context.usarEscalares != undefined && context.usarEscalares == true )
        {
            let valoresSemEstarEmEscalar = [];
            context.paraCadaElemento(function(i, objetoEscalar){

                if( objetoEscalar.obterValor == undefined && 
                    typeof objetoEscalar == 'number' 
                
                ){
                    valoresSemEstarEmEscalar.push( objetoEscalar );

                }else{
                    valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );
                }
            });

            return valoresSemEstarEmEscalar;

        }else{
            //if( context.content.some( (elementoAtual)=>{ return Vectorization.Vector.isVectorizationVector(elementoAtual) || Vectorization.BendableVector.isVectorizationBendableVector(elementoAtual) } ) 
            if( (elementoAtual) => Vectorization.Scalar.isScalar(elementoAtual) == true || 
                                   Vectorization.Text.isText(elementoAtual) == true )
            {
                let valoresSemEstarEmEscalar = [];
                context.paraCadaElemento(function(i, objetoEscalar){

                    if( Vectorization.Scalar.isScalar(objetoEscalar) || 
                        Vectorization.Text.isText(objetoEscalar)
                    
                    ){
                        if( objetoEscalar.obterValor != undefined )
                        {
                            valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );

                        }else{
                            valoresSemEstarEmEscalar.push( objetoEscalar );
                        }
    
                    }else{
                        valoresSemEstarEmEscalar.push( objetoEscalar );
                    }
                });

                return valoresSemEstarEmEscalar;
                
            }else{
                return context.content;
            }
        }
    }

    context.obterTiposRapido = function(includeNamespace=false){
        let tiposUsados = [];
        context.paraCadaElemento(function(i, elementoAtual){
            if( includeNamespace == true ){
                tiposUsados.push( 'Vectorization.' + String(elementoAtual.objectName) );

            }else{
                tiposUsados.push( String(elementoAtual.objectName) );
            }
        });

        return tiposUsados;
    }

    /**
    * Obtem um novo Vector exatamente igual a este Vector
    * Ou seja, faz uma copia do propio objeto, identido, porÃ©m sem manter as referencias. 
    * @returns {Vectorization.Vector}
    */
    context.duplicar = function(){
        let novoVector = [];
        
        for( let i = 0 ; i < context.length ; i++ )
        {
            novoVector.push( context.readIndex(i) );
        }

        return Vectorization.Vector(novoVector);
    }

    //Alias for duplicar
    context.clonar = context.duplicar;


    //Alias for context.content
    context.conteudo = context.content;

    context.sizeOf = function(){
        return context.length;
    }

    context.tamanho = function(){
        return context.sizeOf();
    }

    context.push = function(element){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.content.push(element);
        context._update();
    }
    context.adicionarElemento = context.push;

    context.adicionarElementoNoInicio = function(elemento){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }
        
        context.content.unshift(elemento);
        context._update();
    }

    context.readIndex = function(i){
        return context.content[i];
    }

    /**
    * @param {Function} funcao 
    * @returns {Vectorization.Vector} - o propio Vectorization.Vector
    * 
    * CUIDADO: isso vai modificar este propio Vectorization.Vector
    */
    context.aplicarFuncao = function(funcao){
        context.substituirElementosPor(
            context.mapearValores(function(indice, elementoVetor){
                return funcao(elementoVetor, indice);
            })
        );

        return context;
    }

    context.valorMinimo = function(){
        let valoresAnalisar = context.duplicar();
        let menorValorEncontrado = valoresAnalisar.readIndex(0);

        // Verificar se o vetor nÃ£o estÃ¡ vazio
        if (valoresAnalisar.elementos == 0) {
            throw 'Este Vectorization.Vector nÃ£o tem nada dentro.';
        }

        valoresAnalisar.paraCadaElemento(function(i){
            const elemento = valoresAnalisar.readIndex(i);

            if( elemento < menorValorEncontrado )
            {
                menorValorEncontrado = elemento;
            }
        });

        return menorValorEncontrado;
    }

    context.valorMaximo = function(){
        let valoresAnalisar = context.duplicar();
        let maiorElementoEncontrado = valoresAnalisar.readIndex(0);

        // Verificar se o vetor nÃ£o estÃ¡ vazio
        if (valoresAnalisar.elementos == 0) {
            throw 'Este Vectorization.Vector nÃ£o tem nada dentro.';
        }

        valoresAnalisar.paraCadaElemento(function(i){
            const elemento = valoresAnalisar.readIndex(i);

            if( elemento > maiorElementoEncontrado )
            {
                maiorElementoEncontrado = elemento;
            }
        });

        return maiorElementoEncontrado;
    }

    context.indexOf = function(elemento, comecandoAPartirDoIndice){
        return Vectorization.Vector(context).duplicar()
        .raw().indexOf( 
            Vectorization.Scalar.isVectorizationScalar(elemento) == true ? elemento.obterValor() : elemento, 
            comecandoAPartirDoIndice);
    }

    context.sum = function(){
        let result = 0;
        for( let i = 0 ; i < context.length ; i++ )
        {   
            result = result + Number.parseFloat( context.readIndex( i ) );
        }

        return result;
    }

    context.soma = function(){
        return context.sum();
    }

    context.mean = function(){
        let sum = context.sum();
        return sum / context.length;
    }

    context.media = function(){
        return context.mean();
    }

    /**
    * Verifica se todos os elementos deste vetor sÃ£o "true"
    * @returns {Boolean}
    */
    context.todosVerdadeiros = function(){
        let retorno = false;
        for( let i = 0 ; i < context.content.length ; i++ )
        {   
            if( context.content[i] == true ){
                retorno = true;
            }else{
                retorno = false;
                break;
            }
        }

        return retorno;
    }

    /**
    * Verifica se todos os elementos deste vetor sÃ£o "false"
    * @returns {Boolean}
    */
    context.todosFalsos = function(){
        let retorno = false;
        for( let i = 0 ; i < context.content.length ; i++ )
        {   
            if( context.content[i] == false ){
                retorno = true;
            }else{
                retorno = false;
                break;
            }
        }

        return retorno;
    }

    /**
    * Verifica se todos os elementos deste vetor sÃ£o iguais a um valor
    * @param {Number} valor - o valor
    * @returns {Boolean}
    */
    context.todosIguaisA = function(valor){
        let retorno = false;
        for( let i = 0 ; i < context.content.length ; i++ )
        {   
            if( context.content[i] == valor ){
                retorno = true;
            }else{
                retorno = false;
                break;
            }
        }

        return retorno;
    }

    /**
    * Verifica se este Vector Ã© exatamente igual a outro Vector, no conteudo 
    */
    context.isExatamenteIgual = function(vectorB){
        let isIgual = false;

        if(!Vectorization.Vector.isVector(vectorB)){
            isIgual = false;
            return isIgual;
        }

        if( context.length != vectorB.length ){
            isIgual = false;
            return isIgual;
        }
        
        for( let i = 0 ; i < vectorB.length ; i++ )
        {
            if( vectorB.readIndex(i) == context.readIndex(i)){
                isIgual = true;
            }else{
                isIgual = false;
                break;
            }
        }

        return isIgual;
    }

    /**
    * Permite fatiar(ou recortar) este vetor
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Vector} - o vetor recortado
    */
    context.slice = function(elementoInicial, elementoFinal, intervalo=1){
        let dadosRecortados = [];

        if( elementoInicial < 0 ){
            throw 'A elementoInicial precisa ser maior ou igual a zero!';
        }

        if( elementoFinal > context.length ){
            throw 'A elementoFinal precisa estar dentro da faixa de valores do Vector! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        for( let i = elementoInicial ; i < elementoFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.readIndex(i) );
        }

        return Vectorization.Vector(dadosRecortados);
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma funÃ§Ã£o de callback
    * @param {Function} callback(index, element, context)
    */
    context.forEach = function(callback){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            let ultimoEstadoRetornado = callback( i, context.content[i], context );
    
            if( ultimoEstadoRetornado instanceof Object )
            {
                ultimoEstadoRetornado.propriedadesControle = {};

                switch(ultimoEstadoRetornado.acao){
                    case 'parar':
                    case 'parar_loop':
                    case 'interromper':
                    case 'stop':
                        ultimoEstadoRetornado.propriedadesControle.vaiPararLoop = true;
                        break;

                    case 'reiniciar':
                    case 'reiniciar_loop':
                    case 'restart':
                        i = 0;
                        break;

                    case 'ir_indice':
                    case 'ir_iteracao':
                    case 'go_iteration':
                        if( ultimoEstadoRetornado.valor != undefined )
                        {
                            i = ultimoEstadoRetornado.valor;
                        }else{
                            throw 'NÃ£o Ã© possivel ir para uma iteraÃ§Ã£o sem um numero';
                        }
                        break;
                }

                //Interromper este loop
                if( ultimoEstadoRetornado.propriedadesControle.vaiPararLoop == true ){
                    break;
                }
            }
        }
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma funÃ§Ã£o de callback, porÃ©m faz isso de forma contrÃ¡ria/revertida
    * @param {Function} callback(index, element, context)
    */
    context.paraCadaElementoReverso = function(callback, executarNoContexto=null){
        let valorComecar = context.tamanho()-1;
        let valorVaiInterromper = 0;
        let vaiParar = false;

        for( let i = valorComecar ; vaiParar == false ; i-- )
        {
            if( i > valorVaiInterromper ){
                vaiParar = false;
            }else{
                //Brecar aqui
                vaiParar = true;
            }

            if( executarNoContexto != null ){
                callback = callback.bind(executarNoContexto);
            }

            ultimoEstadoRetornado = callback(
                     //O indice
                     i, 
                     //O elemento atual
                     context.content[i],
                     //O propio contexto deste Vectorization.Vector 
                     context
                    );

            if( ultimoEstadoRetornado instanceof Object )
            {
                ultimoEstadoRetornado.propriedadesControle = {};

                switch(ultimoEstadoRetornado.acao){
                    case 'parar':
                    case 'parar_loop':
                    case 'interromper':
                    case 'stop':
                        ultimoEstadoRetornado.propriedadesControle.vaiPararLoop = true;
                        break;

                    case 'reiniciar':
                    case 'reiniciar_loop':
                    case 'restart':
                        i = 0;
                        break;

                    case 'ir_indice':
                    case 'ir_iteracao':
                    case 'go_iteration':
                        if( ultimoEstadoRetornado.valor != undefined )
                        {
                            i = ultimoEstadoRetornado.valor;
                        }else{
                            throw 'NÃ£o Ã© possivel ir para uma iteraÃ§Ã£o sem um numero';
                        }
                        break;
                }

                //Interromper este loop
                if( ultimoEstadoRetornado.propriedadesControle.vaiPararLoop == true ){
                    break;
                }
            }
        }
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma funÃ§Ã£o de callback, retornando um resultado
    * @param {Function} callback(index, element, context)
    * @returns {Vectorization.Vector}
    */
    context.map = function(callback){
        let novoVetor = [];

        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = callback( i, context.content[i], context );
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma funÃ§Ã£o de filtro, retornando um resultado que Ã© filtrado de forma rÃ­gida.
    * Isso ignora elementos que nÃ£o atendam aos critÃ©rios que voce estabeleceu na funÃ§Ã£o de filtro
    * @param {Function} callback(index, element, context)
    * @returns {Vectorization.Vector} - um novo Vectorization.Vector
    */
    context.filtrar = function(funcaoDeFiltro, incluirDetalhes=false){
        let novoVetor = Vectorization.Vector([]);

        if(!funcaoDeFiltro){
            throw 'Voce precisa passar uma funÃ§Ã£o de filtro!. NÃ£o permitido!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: context.tamanho()

        }).paraCadaElemento(function(i, element, contextoLoop){
            let checagemDoFiltro = funcaoDeFiltro( i, context.content[i], context );

            if(checagemDoFiltro == true || checagemDoFiltro == 'incluir' || checagemDoFiltro == 'manter' || checagemDoFiltro == 'keep' || checagemDoFiltro == 'ok'){
                if( incluirDetalhes == true ){
                    novoVetor.adicionarElemento({
                        valor: context.content[i],
                        indice: i,
                        parIndiceValor: [i, context.content[i]],
                        terminouExecutarFiltro: new Date().getTime(),
                        resultadoFuncaoFiltro: checagemDoFiltro,
                        context: context
                    });

                }else{
                    novoVetor.adicionarElemento( context.content[i] );
                }
            }
        });

        return Vectorization.Vector( novoVetor.valores() );
    }

    context.ignorarUndefined = function(){
        return context.filtrar(function(iAtualFiltragem, elementoAtualFiltragem){
            if( elementoAtualFiltragem != undefined && 
                elementoAtualFiltragem != null &&
                isNaN(elementoAtualFiltragem) == false
            ){
                return 'manter';
            }
        }, false);
    }

    context.ignorar = function(oElemento){
        return context.filtrar(function(iAtualFiltragem, elementoAtualFiltragem){
            if( elementoAtualFiltragem != oElemento ){
                return 'manter';
            }
        }, false);
    }
    context.ignorarOs = context.ignorar;

    context.sobrescreverConteudo = function(novoConteudoDoVetor){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.content = Vectorization.Vector.isVectorizationVector( novoConteudoDoVetor ) ? novoConteudoDoVetor.valores() : novoConteudoDoVetor;
        context.conteudo = context.content;
    }

    /**
    * Similar ao context.filtrar
    * Percorre cada elemento do vetor, aplicando uma funÃ§Ã£o de filtro, retornando um resultado que Ã© filtrado de forma rÃ­gida.
    * Isso ignora elementos que nÃ£o atendam aos critÃ©rios que voce estabeleceu na funÃ§Ã£o de filtro
    * 
    * CUIDADO: Este mÃ©todo vai sobrescrever os valores deste Vectorization.Vector
    */
    context.aplicarFiltro = function(funcaoDeFiltro){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.sobrescreverConteudo(
            Vectorization.Vector(
                context.filtrar(funcaoDeFiltro, incluirDetalhes=true)

            ).mapearValores(function(indiceAtual, valorAtual){
                //Se for um objeto retornado pela funÃ§Ã£o filtrar
                if(typeof valorAtual == 'object')
                {
                    return valorAtual.valor;
                }else{
                    return valorAtual;
                }
            })
        );
    }

    //Preenche tudo com um unico valor especifico
    context.preencherTudo = function(valorEspecifico){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.paraCadaElemento(function(indicePreencher, elemento, contextoVetor){
            context.content[indicePreencher] = valorEspecifico;
        });

        return context;
    }

    /**
    * Similar ao preencherTudo, porÃ©m ele sÃ³ preenche valores que atendam a certo critÃ©rio simples
    * Neste caso o critÃ©rio Ã© onde o valorEspecifico apareÃ§a no indice deste Vectorization.Vector
    * Mais ele vai preencher todos os valores onde a condiÃ§Ã£o bate
    * @param {any} valorEspecifico 
    * @param {any} novoValorEspecifico 
    * @returns {Vectorization.Vector}
    */
    context.preencherTudoOnde = function(valorEspecifico, novoValorEspecifico){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.paraCadaElemento(function(indicePreencher, elemento, contextoVetor){
            let valorNaPosicaoAtualDoVetor = context.readIndex(indicePreencher);

            if( String(valorNaPosicaoAtualDoVetor) == String(valorEspecifico) &&
                String(valorNaPosicaoAtualDoVetor).length == String(valorEspecifico).length
            ){
                context.definirElementoNoIndice(indicePreencher, novoValorEspecifico);
            }
        });

        return context;
    }

    /**
    * Similar ao preencherTudoOnde, sÃ³ que ele vai preencher sÃ³ os N primeiros
    * @param {any} valorEspecifico 
    * @param {any} novoValorEspecifico 
    * @returns {Vectorization.Vector} - o propio Vectorization.Vector
    */
    context.preencherAlgunsOnde = function(valorEspecifico, novoValorEspecifico, quantidadeLimitePreencher, direcaoOperar='esquerda'){
        let quantidadeJaPreencheu = 0;
        let valorNaPosicaoAtualDoVetor;

        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        switch(direcaoOperar){
            case 'esquerda':
            case 'left':
            case 'inicio':
                context.paraCadaElemento(function(indicePreencher, elemento, contextoVetor){
                    valorNaPosicaoAtualDoVetor = context.readIndex(indicePreencher);
        
                    if( String(valorNaPosicaoAtualDoVetor) == String(valorEspecifico) &&
                        String(valorNaPosicaoAtualDoVetor).length == String(valorEspecifico).length
                    ){
                        if( quantidadeJaPreencheu < quantidadeLimitePreencher ){
                            context.definirElementoNoIndice(indicePreencher, novoValorEspecifico);
                        }
        
                        quantidadeJaPreencheu++;
                    }
                });
                break;

            case 'direita':
            case 'frente':
            case 'right':
                context.paraCadaElementoReverso(function(indicePreencher, elemento, contextoVetor){
                    valorNaPosicaoAtualDoVetor = context.readIndex(indicePreencher);
        
                    if( String(valorNaPosicaoAtualDoVetor) == String(valorEspecifico) &&
                        String(valorNaPosicaoAtualDoVetor).length == String(valorEspecifico).length
                    ){
                        if( quantidadeJaPreencheu < quantidadeLimitePreencher ){
                            context.definirElementoNoIndice(indicePreencher, novoValorEspecifico);
                        }
        
                        quantidadeJaPreencheu++;
                    }
                });
                break;

            default:
                throw 'Voce precisa dizer em qual direÃ§Ã£o voce quer usar'
                break;
        }

        return context;
    }

    //TambÃ©m, se o config for um objeto(NÃO FOR UM ARRAY)
    if( config instanceof Object && !(config instanceof Array && (config instanceof Array || Vectorization.Vector.isVector(config) )) ){
        context.aleatorio = config['aleatorio'] || false;
        
        if( config['aleatorio'] != undefined &&
            config['numeros'] != undefined
        ){
            throw 'Voce nÃ£o pode criar um Vectorization.Vector com contÃ©udo definido, e ao mesmo tempo sendo aleatÃ³rio!';
        }

        if( context.aleatorio == true ){
            context.content = []; // Zero o conteudo

            //Se tem outros detalhes
            if( config['minimo'] != undefined && 
                config['maximo'] != undefined && 
                config['elementos'] != undefined &&
                typeof config['minimo'] == 'number' &&
                typeof config['maximo'] == 'number' &&
                typeof config['elementos'] == 'number'
            ){
                //Grava os parametros
                context.minimoAleatorio = config['minimo'];
                context.maximoAleatorio = config['maximo'];

                //Se tiver um nÃºmero base
                if( config['sementeAleatoria'] != undefined &&
                    typeof config['sementeAleatoria'] == 'number'
                ){
                    context.sementeAleatoria = config['sementeAleatoria'];
                }else{
                    context.sementeAleatoria = Vectorization.Random._sementeDefinida;
                }

                //Vai gerando os valores aleatorios enquanto nÃ£o terminar a quantidade de elementos
                while( context.content.length < config['elementos'] )
                {
                    let numeroAleatorioGeradoParaOIndice = Vectorization.Random.gerarNumeroAleatorio( Number(context.minimoAleatorio), Number(context.maximoAleatorio), context.sementeAleatoria );
                    context.adicionarElemento( numeroAleatorioGeradoParaOIndice );
                }

                //Se o programador quiser arredondar
                if( config['arredondar'] != undefined ){
                    switch(config['arredondar']){
                        case true:
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.round(valor);
                                }).valores()
                            );
                            break;

                        case 'cima':
                        case 'up':
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.ceil(valor);
                                }).valores()
                            );
                            break;
            
                        case 'baixo':
                        case 'down':
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.floor(valor);
                                }).valores()
                            );
                            break;

                        case 'automatico':
                        case 'auto':
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.round(valor);
                                }).valores()
                            );
                            break;
                    }
                }

            }else{
                if( typeof config['minimo'] != 'number' ||
                    typeof config['maximo'] != 'number' ||
                    typeof config['elementos'] != 'number' 
                ){
                    throw 'Os valores minimo, mÃ¡ximo e quantidade de elementos precisam ser nÃºmeros!. Tipo nÃ£o permitido.'
                
                }else{
                    throw 'Para criar um Vector aleatÃ³rio voce precisar passar a faixa de valores e a quantidade de elementos!';
                }
            }

            context.conteudo = context.content;
        
        //Se for um objeto, que nÃ£o possui o atributo "aleatorio"
        }else if(context.aleatorio == false){
            
            if( config['numeros'] != undefined &&
                Vectorization.Vector.isVector(config['numeros'])
            ){
                if( config['aleatorio'] != undefined ){
                    throw 'Voce nÃ£o pode criar um Vectorization.Vector com contÃ©udo definido, e ao mesmo tempo sendo aleatÃ³rio!';
                }

                context.content = config['numeros'] != undefined ? 
                                  (Vectorization.Vector.isVectorizationVector(config['numeros']) ? config['numeros'].valores() : 
                                   config['numeros']) : [];

                context.length = context.content.length;
                context.elementos = context.length;
            }

            context.conteudo = context.content;
        }
    }


    /**
    * Retorna os valores deste Vectorization.Vector como arredondados.
    * @param {String} tipoArredondamentoAplicar
    * @returns {Vectorization.Vector}
    */
    context.getValoresArredondados = function(tipoArredondamentoAplicar='cima'){
        let novoVetorArredondado = Vectorization.Vector( context.duplicar() );

        //Se o programador quiser arredondar
        if( tipoArredondamentoAplicar != undefined ){
            switch(tipoArredondamentoAplicar){
                case true:
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.round(valor);
                        }).valores()
                    );
                    break;

                case 'cima':
                case 'up':
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.ceil(valor);
                        }).valores()
                    );
                    break;
    
                case 'baixo':
                case 'down':
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.floor(valor);
                        }).valores()
                    );
                    break;

                case 'automatico':
                case 'auto':
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.round(valor);
                        }).valores()
                    );
                    break;

                default:
                    if(tipoArredondamentoAplicar != false){
                        throw 'Voce precisa falar que tipo de arredondamento voce quer fazer!';
                    }
                    break;
            }
        }

        return novoVetorArredondado;
    }

    /**
    * Aplica um arredondamento sobre os valores deste vetor
    * CUIDADO: isso vai sobrescrever os valores
    * 
    * @param {String} tipoArredondamentoAplicar
    * @returns {Vectorization.Vector} - o propio vetor
    */
    context.aplicarArredondamento = function(tipoArredondamentoAplicar='cima'){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.substituirElementosPor(
            context.getValoresArredondados(tipoArredondamentoAplicar)
        );

        return context;
    }

    /**
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Este propio Vectorization.Vector sobrescrito(CUIDADO!)
    */
    context.acrescentarVetor = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado : Vectorization.Vector(novoVetorASerAcrescentado); 
        let contextoEsteVetor = context;

        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = novoVetorASerAcrescentado_Vector.lerIndice(i);
            context.adicionarElemento(elementoVetorASerAdicionado);
        });
    }

    /**
    * Se parece muito ao context.acrescentarVetor, sÃ³ que aqui, ele vai apenas retornar uma novo Vectorization.Vector, NÃO SUBSTITUI ESTE VETOR
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Um novo Vectorization.Vector
    */
    context.juntarComOutroVetor = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado : Vectorization.Vector(novoVetorASerAcrescentado); 
        let contextoEsteVetor = context;

        let novoVetorASerAcrescentado_VectorFinal = contextoEsteVetor.duplicar();

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = novoVetorASerAcrescentado_Vector.lerIndice(i);
            novoVetorASerAcrescentado_VectorFinal.adicionarElemento(elementoVetorASerAdicionado);
        });

        return novoVetorASerAcrescentado_VectorFinal;
    }

    /**
    * Se parece muito ao context.acrescentarVetor, porÃ©m ele pÃ´em os elementos no inicio do vetor, ao invÃ©s de colocar no final do mesmo
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Este propio Vectorization.Vector sobrescrito(CUIDADO!)
    */
    context.acrescentarNoInicioVetor = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado : Vectorization.Vector(novoVetorASerAcrescentado); 
        let contextoEsteVetor = context;

        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: contextoEsteVetor.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = contextoEsteVetor.lerIndice(i);
            novoVetorASerAcrescentado_Vector.adicionarElemento(elementoVetorASerAdicionado);
        });

        let novoVetorASerAcrescentado_VectorFinal = Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        });

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_VectorFinal.tamanho()
        })
        .paraCadaElemento(function(i){
            novoVetorASerAcrescentado_VectorFinal[i] = novoVetorASerAcrescentado_Vector.lerIndice(i);
        });

        contextoEsteVetor.sobrescreverConteudo(
            novoVetorASerAcrescentado_VectorFinal.duplicar()
                                                 .valores()
        )
    }

    /**
    * Se parece muito ao context.acrescentarNoInicioVetor, sÃ³ que aqui, ele vai apenas retornar uma novo Vectorization.Vector, NÃO SUBSTITUI ESTE VETOR
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Um novo Vectorization.Vector
    */
    context.juntarComOutroVetorNoInicio = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado.duplicar() : Vectorization.Vector(novoVetorASerAcrescentado).duplicar(); 
        let contextoEsteVetorDuplicado = context.duplicar();

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: contextoEsteVetorDuplicado.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = contextoEsteVetorDuplicado.lerIndice(i);
            novoVetorASerAcrescentado_Vector.adicionarElemento(elementoVetorASerAdicionado);
        });

        let novoVetorASerAcrescentado_VectorFinal = Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        });

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_VectorFinal.tamanho()
        })
        .paraCadaElemento(function(i){
            novoVetorASerAcrescentado_VectorFinal[i] = novoVetorASerAcrescentado_Vector.lerIndice(i);
        });

        return novoVetorASerAcrescentado_VectorFinal;
    }

    //OUTROS MÃTODOS ABAIXO

    /**
     * Produto escalar entre dois vetores
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-vetor-com-vetor
     * 
     * @param {Vectorization.Vector} vectorA 
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Scalar}
    */
    context.produtoEscalar = function(vectorB){
        let vectorA = context;

        if( vectorA.length != vectorB.length ){
            throw 'The number of elements in vector A must be exactly equal to the number of elements in vector B. Impossible to calculate!';
        }

        if( !vectorB instanceof Object ){
            throw 'vectorB must be a Object'
        }

        if( vectorB.objectName != 'Vector' ){
            throw 'vectorB must be a instance of ' + String( context.path );
        }

        //Inicializa a variavel que serÃ¡ usada para a soma ponderada da linha atual
        let produtoAtual = 0;
        //Percorre cada elemento do vetor B
        for( let colunaB = 0 ; colunaB < vectorB.length ; colunaB++ ){
            produtoAtual += ( vectorA.readIndex(colunaB) * vectorB.readIndex(colunaB) );
        }

        return Vectorization.Scalar(produtoAtual);
    }

    //Alias for produtoEscalar
    context.produtoEscalarVetor = context.produtoEscalar;

    /**
     * Produto escalar entre este vetor e uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-vetor-com-matriz
     * @param {Vectorization.Vector} vectorA 
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Vector}
    */
    context.produtoEscalarMatrix = function(matrixA){
        let vectorB = context.content;

        if( matrixA.rows != vectorB.length ){
            throw 'O nÃºmero de linhas da matrixA deve ser exatamente igual ao numero de elementos do vetor. Impossivel calcular!';
        }
    
        let vetorResultado = [];
    
        //Percorre cada linha da matrix A
        for( let linha = 0 ; linha < matrixA.rows ; linha++ ){
    
            //Inicializa a variavel que serÃ¡ usada para a soma ponderada
            let produtoAtual = 0;
    
            //Percorre cada elemento do vetor B
            for( let colunaB = 0 ; colunaB < vectorB.length ; colunaB++ ){
                /*
                * Obtem os valores da linha atual da matrix A(nesse caso, a linha Ã© na verdade a colunaB)
                * Pois, quando vamos calcular o produto escalar entre um vetor e uma matrix, acessamos os elementos de forma diferente: ao invez de acessar matrix[linha][coluna](como fazemos no produto escalar entre matrix e vetor), fazemos o contrÃ¡rio e acessamos matrix[coluna][linha], 
                * Ou seja, na matrix A, acessamos a coluna correspondente ao elemento atual do vetor B.
                * Ou seja, a nivel de cÃ³digo, na matrixA acessamos a colunaB que Ã© o elemento atual do vetor, de modo que matrixA.content[colunaB] retornarÃ¡ um vetor(isto Ã©, a variavel colunaB da matrixA), e ai em seguida nÃ³s acessamos a linha atual da matrixA, ou seja, literalmente matrixA.content[coluna][linha], e Ã© assim que vamos fazer a soma ponderada.
                * Ã assim que vamos fazer a soma ponderada.
                */
                let valoresAtualMatrixNaPosicaoColunaB = matrixA.content[colunaB]; //Aqui a linha vai ser na verdade a coluna, no caso, a linha da colunaB, da matrix em questÃ£o
    
                produtoAtual += ( vectorB[colunaB] * valoresAtualMatrixNaPosicaoColunaB[linha] ); //E a coluna vai ser a linha
            }
    
            //Vai adicionando os resultados no vetor de resultado
            vetorResultado.push(produtoAtual);
        }
    
        return Vectorization.Vector(vetorResultado);
    }

    /**
     * Multiplica este vetor com outro vetor
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-vetores-elemento-a-elemento/codigo-principal.js
     * @param {Vectorization.Vector} vectorB_param
     * @returns {Vectorization.Vector}
    */
    context.multiplicarVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E nÃ£o um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content;
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let vetorResultado = [];

        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }

        for( let i = 0 ; i < vectorA.length ; i++ )
        {   
            vetorResultado.push( vectorA[i] * vectorB[i] );
        }

        return Vectorization.Vector(vetorResultado);
    }

    /**
     * Multiplica este vetor por um nÃºmero
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-vetores-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.multiplicarNumero = function(numero){
        let vetorResultado = [];
        let vectorA = context.content;

        for( let i = 0 ; i < vectorA.length ; i++ )
        {   
            vetorResultado.push( vectorA[i] * numero );
        }

        return Vectorization.Vector(vetorResultado);
    }

    /**
     * Multiplica este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.multiplicarMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] * matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Divide este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.dividirMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] / matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Faz a soma deste vetor com outro vetor
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-vetores/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.somarVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E nÃ£o um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] + vectorB[i];
        }
    
        return Vectorization.Vector(novoVetor);
    }

    /**
     * Soma este vetor com um nÃºmero
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-vetores-por-um-numero-scalar/codigo-principal.js 
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.somarNumero = function(numero){
        let novoVetor = [];
        let vectorA = context.content;

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] + numero;
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
     * Soma este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.somarMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] + matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Faz a subtraÃ§Ã£o deste vetor com outro vetor
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-vetores/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.subtrairVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E nÃ£o um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] - vectorB[i];
        }
    
        return Vectorization.Vector(novoVetor);
    }

    /**
     * Subtrai este vetor com um nÃºmero
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-vetores-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.subtrairNumero = function(numero){
        let novoVetor = [];

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] - numero;
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
     * Subtrai este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.subtrairMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] - matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Faz a divisÃ£o deste vetor com outro vetor
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-vetores/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.dividirVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E nÃ£o um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] / vectorB[i];
        }
    
        return Vectorization.Vector(novoVetor);
    }

    /**
     * Divide este vetor com um nÃºmero
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-vetores-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.dividirNumero = function(numero){
        let novoVetor = [];
        let vectorA = context.content;

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] / numero;
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
     * Eleva este vetor a um nÃºmero
     * 
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.elevarNumero = function(numero){
        let novoVetor = [];

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = Math.pow(vectorA[i], numero);
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Eleva este vetor a outro vetor
    * 
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.elevarVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E nÃ£o um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = Math.pow(vectorA[i], vectorB[i]);
        }
    
        return Vectorization.Vector(novoVetor);
    }

    /**
     * Eleva este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.elevarMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( Math.pow(vectorB[j], matrixA[i][j]) );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Obtem o vetor oposto
    * @returns {Vectorization.Vector}
    */
    context.vetorOposto = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = context.content[i] * -1;
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Obtem o vetor absoluto
    * @returns {Vectorization.Vector}
    */
    context.abs = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.abs(context.content[i]);
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Obtem o vetor absoluto
    * @returns {Vectorization.Vector}
    */
    context.absoluto = function(){
        return context.abs();
    }

    /**
    * Obtem a raiz quadrada de cada elemento do vetor
    * @returns {Vectorization.Vector}
    */
    context.sqrt = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.sqrt(context.content[i]);
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Obtem o log2 de cada elemento do vetor
    * @returns {Vectorization.Vector}
    */
    context.log2 = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.log2(context.content[i]);
        }

        return Vectorization.Vector(novoVetor);
    }

    context.removerApenasUm = function(elementoRemover){
        let novoVectorRetirado = Vectorization.Vector([]);
        let vetorPercorrer = context.duplicar();
        let jaFoi = false;

        vetorPercorrer.paraCadaElemento(function(i, elementoVetor){
            if( jaFoi == false && elementoVetor == elementoRemover){
                jaFoi = true;

            }else{
                novoVectorRetirado.adicionarElemento(elementoVetor);
            }
        });

        novoVectorRetirado._update();
        return novoVectorRetirado;
    }

    /**
    * Ordena este Vectorization.Vector em ordem crescente
    * @returns {Vectorization.Vector} - um novo Vectorization.Vector ordenado
    */
    context.ordenarCrescente = function(){
        let novoVectorOrdenado = Vectorization.Vector([]);
        let vetorPercorrer = context.duplicar();
        let vetorTrabalhando = vetorPercorrer.duplicar();

        while( novoVectorOrdenado.elementos != vetorPercorrer.elementos )
        {
            let valorMinimoVetorTrabalhando = vetorTrabalhando.valorMinimo();
    
            let jaFoiAPrimeira = false;
            vetorTrabalhando.paraCadaElemento(function(i, elementoVetor){
                if( jaFoiAPrimeira == false && elementoVetor == valorMinimoVetorTrabalhando ){
                    novoVectorOrdenado.adicionarElemento( elementoVetor );
                    jaFoiAPrimeira = true;

                    //Vai parar o loop do elementoVetor
                    return {
                        acao: 'parar_loop'
                    }
                }
            })

            //Substitui o vetorTrabalhando
            vetorTrabalhando = vetorTrabalhando.removerApenasUm(valorMinimoVetorTrabalhando);
            jaFoiAPrimeira = false;
        }

        return novoVectorOrdenado;
    }

    /**
    * Ordena este Vectorization.Vector em ordem decrescente
    * @returns {Vectorization.Vector} - um novo Vectorization.Vector ordenado
    */
    context.ordenarDecrescente = function(){
        let novoVectorOrdenado = Vectorization.Vector([]);
        let vetorPercorrer = context.duplicar();
        let vetorTrabalhando = vetorPercorrer.duplicar();

        while( novoVectorOrdenado.elementos != vetorPercorrer.elementos )
        {
            let valorMaximoVetorTrabalhando = vetorTrabalhando.valorMaximo();
    
            let jaFoiAPrimeira = false;
            vetorTrabalhando.paraCadaElemento(function(i, elementoVetor){
                if( jaFoiAPrimeira == false && elementoVetor == valorMaximoVetorTrabalhando ){
                    novoVectorOrdenado.adicionarElemento( elementoVetor );
                    jaFoiAPrimeira = true;

                    //Vai parar o loop do elementoVetor
                    return {
                        acao: 'parar_loop'
                    }
                }
            })

            //Substitui o vetorTrabalhando
            vetorTrabalhando = vetorTrabalhando.removerApenasUm(valorMaximoVetorTrabalhando);
            jaFoiAPrimeira = false;
        }

        return novoVectorOrdenado;
    }

    /**
     * Permite dividir este Vectorization.Vector em N partes iguais.
     * @param {Number} numeroPartesDividir 
     * @returns {Vectorization.Vector} - um Vectorization.Vector de outros Vectorization.Vector(s)
     */
    context.dividirEmPartes = function(numeroPartesDividir){
        let esteVetorCopiado = context.duplicar();
        let tamanhosAproximados = Math.round( esteVetorCopiado.elementos / numeroPartesDividir );
        let ondeParou = 0;

        let listaResultadoDivisao = Vectorization.Vector({
            valorPreencher: Vectorization.Vector([]),
            elementos: numeroPartesDividir
        });

        Vectorization.Vector({
            valorPreencher: tamanhosAproximados,
            elementos: numeroPartesDividir
        }).paraCadaElemento(function(iParte, tamanhoParte){

            let quantosJaColocou = 0;
            let jaTerminouEste = false;
            
            Vectorization.Vector(esteVetorCopiado)
            .paraCadaElemento(function(iElemento){
                let elementoAtual = esteVetorCopiado.lerIndice(iElemento);
                let consideradouEsteIndice = ( (ondeParou == 0 || iElemento > ondeParou) == true && quantosJaColocou <= (tamanhoParte-1) == true) == true;
                let jaColocouTudoDaParte = (quantosJaColocou <= (tamanhoParte-1)) == false;

                if( jaTerminouEste == false && (ondeParou == 0 || iElemento > ondeParou) && quantosJaColocou <= (tamanhoParte-1) )
                {
                    listaResultadoDivisao.lerIndice(iParte)
                                         .adicionarElemento(elementoAtual);

                    ondeParou = iElemento;
                    quantosJaColocou++;
                    
                }else{
                    //Se ele pulou o indice por que ainda nÃ£o comeÃ§ou a faixa de valores do proximo pedaÃ§o, ele ignora e nÃ£o vai marcar que ja terminou
                    if( jaColocouTudoDaParte == true ){
                        jaTerminouEste = true;

                        //Vai parar o loop do iElemento
                        return {
                            acao: 'parar_loop'
                        }
                    }
                }

            });
        })

        return Vectorization.Vector(listaResultadoDivisao);
    }
    context.split = context.dividirEmPartes;

    /**
     * Verifica se este Vectorization.Vector estÃ¡ ordenado de forma crescente
     * @returns {Boolean}
     */
    context.isOrdenadoCrescente = function(){
        let esteVetorCopiado = context.duplicar();
        let estaOrdenado = true;
        Vectorization.Vector(esteVetorCopiado)
        .paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);
            let elementoMaisUm = esteVetorCopiado.readIndex(i+1) || NaN;
            let elementoMenosUm = esteVetorCopiado.readIndex(i-1) || NaN;

            if( elementoMaisUm < elementoAtual || elementoMenosUm > elementoAtual ){
                estaOrdenado = false;

                return {
                    acao: 'parar_loop'
                }
            }
        });

        return estaOrdenado;
    }

    /**
     * Verifica se este Vectorization.Vector estÃ¡ ordenado de forma decrescente
     * @returns {Boolean}
     */
    context.isOrdenadoDecrescente = function(){
        let esteVetorCopiado = context.duplicar();
        let estaOrdenado = true;
        Vectorization.Vector(esteVetorCopiado)
        .paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);
            let elementoMaisUm = esteVetorCopiado.readIndex(i+1) || NaN;
            let elementoMenosUm = esteVetorCopiado.readIndex(i-1) || NaN;

            if( elementoMaisUm > elementoAtual || elementoMenosUm < elementoAtual ){
                estaOrdenado = false;

                return {
                    acao: 'parar_loop'
                }
            }
        });

        return estaOrdenado;
    }

    /**
     * Verifica se este Vectorization.Vector estÃ¡ ordenado de forma crescente ou entÃ£o decrescente
     * @returns {Boolean}
     */
    context.isOrdenado = function(){
        return (context.isOrdenadoCrescente() || context.isOrdenadoDecrescente());
    }
    context.estaOrdenado = context.isOrdenado;
    context.estiverOrdenado = context.estaOrdenado;
    context.estiverOrdenadoCrescente = context.isOrdenadoCrescente;

    context.primeiroItem = function(){
        return context.lerIndice(0);
    }

    context.ultimoItem = function(){
        return context.lerIndice(context.elementos - 1) + 0;
    }

    context.segundoItem = function(){
        return context.lerIndice(1);
    }
    context.terceiroItem = function(){
        return context.lerIndice(2);
    }
    context.quartoItem = function(){
        return context.lerIndice(3);
    }
    context.quintoItem = function(){
        return context.lerIndice(4);
    }
    context.sextoItem = function(){
        return context.lerIndice(5);
    }
    context.setimoItem = function(){
        return context.lerIndice(6);
    }
    context.oitavoItem = function(){
        return context.lerIndice(7);
    }
    context.nonoItem = function(){
        return context.lerIndice(8);
    }
    context.decimoItem = function(){
        return context.lerIndice(9);
    }

    /**
    * @param {Number} numeroQuerendoPesquisar 
    * @returns {Object}
    */
    context.pesquisaBinaria = function(numeroQuerendoPesquisar, naoChecarOrdenacao=false){
        let resultado = {
            encontrou: false,
            indiceAchou: -1
        };

        if( naoChecarOrdenacao == true || context.estiverOrdenadoCrescente() )
        {
            let esteVetorCopiado = context.duplicar();
            let esteVetor_dividido = esteVetorCopiado.dividirEmPartes(2);
            let tamanhoEsteVetor = esteVetorCopiado.elementos;
            let tamanhoEsteVetor_pelaMetade = Math.round( tamanhoEsteVetor/2 );

            let parte1 = esteVetor_dividido.primeiroItem(),
                parte2 = esteVetor_dividido.segundoItem();

            if( numeroQuerendoPesquisar >= esteVetorCopiado.lerIndice(tamanhoEsteVetor_pelaMetade) ){
                resultado.indiceAchou = parte2.indiceDe(numeroQuerendoPesquisar);
                resultado.encontrou = resultado.indiceAchou > -1 ? true : false;

            }else{
                resultado.indiceAchou = parte1.indiceDe(numeroQuerendoPesquisar);
                resultado.encontrou = resultado.indiceAchou > -1 ? true : false;
            }   

        }else{
            throw 'VocÃª precisa ordenar primeiro em ordem crescente!';
        }

        return resultado;
    }

    /**
    * Vai percorrer cada elemento deste Vectorization.Vector, visando localizar elementos que aparecem mais de uma vez.
    * E com isso, ele vai remover tais repetiÃ§Ãµes de elementos, retornando um novo Vectorization.Vector que nÃ£o contenha duplicidade. 
    */
    context.valoresUnicos = function(){
        const esteVetorCopiado = context.duplicar();
        const jaFoi = {};
        
        let novoVetor_sem_repeticoes = Vectorization.Vector([]);

        esteVetorCopiado.paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);

            if( jaFoi[ elementoAtual ] == undefined )
            {
                novoVetor_sem_repeticoes.adicionarElemento(elementoAtual);
                jaFoi[ elementoAtual ] = true;
            }
        });

        return novoVetor_sem_repeticoes;
    }

    /**
    * Conta quantas vezes um elemento em questÃ£o apareceu dentro deste Vectorization.Vector
    */
    context.contarFrequenciaElemento = function(elementoEmQuestao='nenhumElemento'){
        let quantidade = 0;
        if( elementoEmQuestao == 'nenhumElemento' ){
            throw 'Voce precisa passar um elemento!';
        }

        context.paraCadaElemento(function(iii){
            const elementoAtual = context.lerIndice(iii);
            if( elementoAtual == elementoEmQuestao )
            {
                quantidade = quantidade + 1;
            }
        });

        return quantidade;
    }

    /**
     * Sub-classe auxiliar, para uso interno
     * Possui uma estrutura personalizada para armazenar frequencias
     * @param { Object{contextVinculado:Vectorization.Vector, calcular:Vectorization.Vector||Array} } dadosFrequencias
     * @returns {Vectorization.Vector.FrequenciaComputada}
     */
    Vectorization.Vector.FrequenciaComputada = function(dadosFrequencias){
        let dadosFrequencias_Obj = {};
        let dadosProcurar = [];

        let contextPropioVector = null;
        if( !Vectorization.Vector.isVector(dadosFrequencias) ){
            dadosFrequencias_Obj = {... dadosFrequencias};
            contextPropioVector = dadosFrequencias_Obj.contextVinculado;
            dadosProcurar = dadosFrequencias_Obj.calcular;

            if( dadosProcurar == null || dadosProcurar == undefined ){
                throw 'Voce precisa informar o calcular';
            }

            if( contextPropioVector == null || contextPropioVector == undefined ){
                throw 'Voce precisa informar o contexto do Vectorization.Vector';
            }   
        }

        let informacoesCopiadas = Vectorization.Base(dadosFrequencias_Obj);
        let context_informacoesCopiadas = informacoesCopiadas;
        context_informacoesCopiadas.tabelaFrequencias = {};

        context_informacoesCopiadas.path = 'Vectorization.Vector.FrequenciaComputada';
        context_informacoesCopiadas.namespace = 'window.Vectorization';
        context_informacoesCopiadas.dadosProcurar = dadosProcurar;

        //Permite adicionar ao frequencias_Vector um elemento a ser contado
        informacoesCopiadas.adicionarInformacao = function(conteudo, quantidade=undefined){
            if(quantidade == undefined || quantidade == null){
                quantidade = context_informacoesCopiadas.contextVinculado.contarFrequenciaElemento(conteudo);
            }

            //Cadastra a quantidade informada(ou identificada)
            context_informacoesCopiadas.tabelaFrequencias[ conteudo ] = quantidade;
        }

        informacoesCopiadas.obterContagens = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.dados = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.obter = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.mostrar = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.raw = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.maisAparece = function(){
            let contagens = informacoesCopiadas.obterContagens();
            let maiorValorPresente = Vectorization.Vector( Object.values( contagens ) ).valorMaximo();
            let valoresIndexados = Vectorization.Vector( Object.keys( contagens ).map( function(numero){return Number(numero)} ) );
            let maisAparece = contagens[ Object.keys( contagens )[0] ];

            valoresIndexados.paraCadaElemento(function(iii){
                const nomeIndice = valoresIndexados.lerIndice(iii);
                const quantidadeElementoEmQuestao = contagens[ nomeIndice ];

                if( quantidadeElementoEmQuestao == maiorValorPresente ){
                    maisAparece = nomeIndice;

                    return {
                        acao: 'parar_loop'
                    }
                }
            });

            return maisAparece;
        }

        //Nao precisa ser apenas um
        informacoesCopiadas.menosAparece = function(){
            let contagens = informacoesCopiadas.obterContagens();
            let menorValorPresente = Vectorization.Vector( Object.values( contagens ) ).valorMinimo();
            let valoresIndexados = Vectorization.Vector( Object.keys( contagens ).map( function(numero){return Number(numero)} ) );
            let menosAparece = contagens[ Object.keys( contagens )[0] ];

            valoresIndexados.paraCadaElemento(function(iii){
                const nomeIndice = valoresIndexados.lerIndice(iii);
                const quantidadeElementoEmQuestao = contagens[ nomeIndice ];

                if( quantidadeElementoEmQuestao == menorValorPresente ){
                    menosAparece = nomeIndice;

                    return {
                        acao: 'parar_loop'
                    }
                }
            });

            return menosAparece;
        }

        informacoesCopiadas.atualizarContagem = function(novosDadosProcurar=null){
            context_informacoesCopiadas.tabelaFrequencias = {};

            if(novosDadosProcurar != null){
                informacoesCopiadas.dadosProcurar = novosDadosProcurar;
                informacoesCopiadas.calcular = novosDadosProcurar;
            }

            if( Vectorization.Vector.isVector(informacoesCopiadas.dadosProcurar) && !Vectorization.Vector.isVectorizationVector(informacoesCopiadas.dadosProcurar) ){
                Vectorization.Vector(informacoesCopiadas.dadosProcurar).paraCadaElemento(function(ii, elementoAtualSublaco, contextoEsteDadosProcurar){
                    const elementoAtual = contextoEsteDadosProcurar.lerIndice(ii);
                    informacoesCopiadas.adicionarInformacao(elementoAtual.obterValor(), null);
                });
    
            }else if(Vectorization.Vector.isVectorizationVector(informacoesCopiadas.dadosProcurar) == true){
                informacoesCopiadas.dadosProcurar.paraCadaElemento(function(ii, elementoAtualSublaco, contextoEsteDadosProcurar){
                    const elementoAtual = contextoEsteDadosProcurar.lerIndice(ii);
                    informacoesCopiadas.adicionarInformacao(elementoAtual.obterValor(), null);
                });
            }
        }

        informacoesCopiadas.atualizarContagem();
        return informacoesCopiadas;
    }

    /**
    * Vai percorrer cada elemento deste Vectorization.Vector, visando contabilizar a quantia de cada elemento que aparece. 
    * Ou seja, a quantidade de cada elemento, caso haja repetiÃ§oes. Similar a um histograma
    */
    context.contabilizarFrequencias = function(valoresBrutos=false){
        let frequenciaComputada = Vectorization.Vector.FrequenciaComputada({
            contextVinculado: context,
            calcular: context.duplicar().valores()
        });

        return valoresBrutos == true ? frequenciaComputada.obterContagens() : frequenciaComputada;
    }

    /**
    * Vai percorrer cada elemento deste Vectorization.Vector, visando contabilizar a quantia de cada elemento que aparece. 
    * Ou seja, a quantidade de cada elemento, caso haja repetiÃ§oes. Similar a um histograma
    * Similar ao context.contabilizarFrequencias
    * porÃ©m este contabiliza apenas valores especificos
    * @param {Vectorization.Vector} valoresAnalisar
    */
    context.contabilizarFrequenciasValores = function(valoresAnalisar){
        let frequenciaComputada = Vectorization.Vector.FrequenciaComputada({
            contextVinculado: context,
            calcular: valoresAnalisar
        });

        return frequenciaComputada;
    }

    /**
    * MÃ©todo que converte este Vectorization.Vector para um Vectorization.Vector avanÃ§ado, onde cada elemento dentro do mesmo Ã© um Vectorization.Scalar
    */
    context._vectorElementos2Escalares = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            context.content[i] = Vectorization.Scalar(context.content[i], extraPropsOfLine);
        }
    }

    if( context.configRecebidaUsuario['usarEscalares'] != undefined || classConfig['usarEscalares'] != undefined ){
        if( context.configRecebidaUsuario['usarEscalares'] == true || classConfig['usarEscalares'] == true )
        {
            context.usarEscalares = true;
            context._vectorElementos2Escalares();
        }
    }

    context._doDefaultBaseAfterCreate();

    //Se existir uma traduÃ§Ã£o para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //Aplica arredondamentos, se o usuario desejar, mesmo nÃ£o sendo um Vectorization.Vector aleatorio
    if( context._config != undefined &&
        (
            context._config['aleatorio'] == undefined || context._config['aleatorio'] == false
        ) == true && 
        (
            context._config['arredondar'] != undefined ||
            context.configRecebidaUsuario['arredondar'] != undefined
        ) == true
    ){
        context.aplicarArredondamento(
            context._config['arredondar'] != undefined ? context._config['arredondar'] : context.configRecebidaUsuario['arredondar'] 
        );
    }

    //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
    context.bloqueado = (config['bloqueado'] != undefined || classConfig['bloqueado'] != undefined) ? (config['bloqueado'] || classConfig['bloqueado']) : false;

    //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
    if( context._isBloqueado() == true ){
        context.bloquearModificacoes();
    }

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se tiver uma funÃ§Ã£o a ser aplicada por cima de tudo
    if( config['funcaoAplicar'] != undefined || classConfig['funcaoAplicar'] != undefined ){
        context.aplicarFuncao( config['funcaoAplicar'] || classConfig['funcaoAplicar'] );
    }

    //return context;
    //Cria um Proxy para permitir acessar os indices do vetor diretamente
    return new Proxy(context, {
        get: function(target, prop, receiver) {
          if (typeof prop === 'string' && !isNaN(prop)) {
            return target.content[Number(prop)];
          }
          return Reflect.get(target, prop, receiver);
        },

        set: function(target, prop, value) {
          //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Vector estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'VocÃª nÃ£o pode modificar esta atributo do Vectorization.Vector!';
          }

          if (typeof prop === 'string' && !isNaN(prop)) {
            target.content[Number(prop)] = value;
            return true;
          }
          return Reflect.set(target, prop, value);
        }
    });
}

/**
* MÃ©todos estÃ¡ticos
*/
window.Vectorization.Vector.isVector = function(obj){
    if( obj == undefined ){ return false };
    return ((obj.objectName != undefined && obj.objectName == 'Vector') || 
           Array.isArray(obj)) ? true : false;
}

window.Vectorization.Vector.isVectorizationVector = function(obj){
    if( obj == undefined ){ return false };
    return (obj.objectName != undefined && obj.objectName == 'Vector')
}

module.exports = window.Vectorization.Vector;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Vector.js*/
/* ARQUIVO VECTORIZATION: ../src/Vector-translation.js*/
/*
 * File Name: Vector-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Vector._translations = function(){
    const translatedMethods = {
        //English
        "dotProduct": "produtoEscalar",

        "dotProductMatrix": "produtoEscalarMatrix",

        "dotProductVector": "produtoEscalarVector",

        "multiplyMatrix": "multiplicarMatrix",

        "multiplyNumber": "multiplicarNumero",

        "multiplyVector": "multiplicarVetor",

        "addMatrix": "somarMatrix",

        "addNumber": "somarNumero",

        "addVector": "somarVetor",

        "subtractMatrix": "subtrairMatrix",

        "subtractNumber": "subtrairNumero",

        "subtractVector": "subtrairVetor",

        "divideMatrix": "dividirMatrix",

        "divideNumber": "dividirNumero",

        "divideVector": "dividirVetor",

        "powMatrix": "elevarMatrix",

        "powNumber": "elevarNumero",

        "powVector": "elevarVetor",

        "transposed": "tranposta",

        "oppostMatrix": "matrixOposta",

        "identity": "identidade",

        "filter": "filtrar",

        "blockModifications": "bloquearModificacoes",
        "unblockModifications": "desbloquearModificacoes",

        "findMin": "valorMinimo",
        "findMax": "valorMaximo",
        "sortAscending": "ordenarCrescente",
        "sortDescending": "ordenarDecrescente",
        "mapFunction": "aplicarFuncao",
        "unicalValues": "valoresUnicos",

        //Portugues
        "somarMatriz": "somarMatrix",
        "subtrairMatriz": "subtrairMatrix",
        "multiplicarMatriz": "multiplicarMatrix",
        "elevarMatriz": "elevarMatrix",
        "produtoEscalarMatriz": "produtoEscalarMatrix",
        
        "paraCadaElemento": "forEach",
        "adicionarElemento": "push",
        "mapearValores": "map",
        "filtrarValores": "filtrar",
        "lerIndice": "readIndex",
        "getIndice": "readIndex",
        "bloquear": "bloquearModificacoes",
        "desbloquear": "desbloquearModificacoes",
        "indiceDe": "indexOf",
        "encontrarIndiceDe": "indexOf",
        "encontrarIndice": "indexOf",
        "ordemCrescente": "ordenarCrescente",
        "ordemDecrescente": "ordenarDecrescente",
        "isOrdemCrescente": "isOrdenadoCrescente",
        "isOrdemDecrescente": "isOrdenadoDecrescente"
    };

    const translatedAttributes = {
        //English
        "blocked": "bloqueado",
        "allowBlock": "permitirBloquear",
        "allowUnblock": "permitirDesbloquear",
        "mapUsingFunction": "funcaoAplicar",

        //Portugues
        "valorPreencher": "fillValue",
        "elementos": "length",
        "conteudo": "numeros"
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Vector._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Vector-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/StringVector.js*/
/*
 * File Name: StringVector.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    require('./Root'); 
    require('./Scalar');
    require('./Vector');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringVector = function( config=[], classConfig={} ){
    //Por padrÃ£o o usarEscalares vai ser true
    if( config['usarTextos'] == undefined && classConfig['usarTextos'] == undefined && config['usarTextos'] != false && classConfig['usarTextos'] != false ){
        config['usarTextos'] = true;
    }
    
    //Define a traduÃ§Ã£o
    classConfig['translations'] = window.Vectorization.StringVector._translations || null;

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Este Vectorization.StringVector NÃO usa nÃºmeros, em vez disso, ele Ã© especifico pra texto
    classConfig['usarEscalares'] = false;

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.StringVector.isStringVector(config) && config.objectName == 'StringVector' ){
        return Vectorization.StringVector( config.values() );
    }

    //O StringVector serÃ¡ baseado no Vectorization.Vector
    let context = window.Vectorization.Vector(config, classConfig);
    context.objectName = 'StringVector';
    context.extendedFrom = 'Vector';
    context.path = 'Vectorization.StringVector';
    context.configRecebidaUsuario = config;

    context.letrasMaiusculas = function(){
        let novoStringVector = Vectorization.StringVector([]);
        let contextoMetodo = this instanceof Window ? context : this; 
        
        //Usei o this acima pois isso permite herdar este cÃ³digo em outro objeto
        contextoMetodo.paraCadaElemento(function(i){
            novoStringVector.adicionarElemento( contextoMetodo.lerIndice(i).letrasMaiusculas() );
        });

        return novoStringVector;
    }
    context.toUpperCase = context.letrasMaiusculas;


    context.letrasMinusculas = function(){
        let novoStringVector = Vectorization.StringVector([]);
        let contextoMetodo = this instanceof Window ? context : this; 

        //Usei o this acima pois isso permite herdar este cÃ³digo em outro objeto
        contextoMetodo.paraCadaElemento(function(i){
            novoStringVector.adicionarElemento( contextoMetodo.lerIndice(i).letrasMinusculas() );
        });

        return novoStringVector;
    }
    context.toLowerCase = context.letrasMinusculas;

    
    /**
     * Retorna um Vectorization.Vector, contendo as distancias hamming de cada elemento Vectorizaion.Text
     * @param {Vectorization.StringVector} outroStringVector 
     * @returns {Vectorization.Vector}
     */
    context.distanciaPalavras = function(outroStringVector){
        let distancias = Vectorization.Vector([]);
        let contextoMetodo = this instanceof Window ? context : this; 

        //Usei o this acima pois isso permite herdar este cÃ³digo em outro objeto
        contextoMetodo.paraCadaElemento(function(i){
            let elementoAtual_esteStringVector = contextoMetodo.lerIndice(i),
                elementoAtual_outroStringVector = ( Vectorization.StringVector.isVectorizationStringVector(outroStringVector) == false ? Vectorization.StringVector(outroStringVector) : outroStringVector ).lerIndice(i);

            if( elementoAtual_outroStringVector != undefined ){
                let distanciaElementoIndiceAtual = Vectorization.Text(elementoAtual_esteStringVector)
                                                  .distanciaHamming( Vectorization.Text(elementoAtual_outroStringVector) )
                
                distancias.adicionarElemento( distanciaElementoIndiceAtual );

            }else{
                distancias.adicionarElemento( 1 );
            }
        });

        return distancias;
    }

    //Se existir uma traduÃ§Ã£o para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    /**
    * MÃ©todo que converte este Vectorization.StringVector para um Vectorization.StringVector avanÃ§ado, onde cada elemento dentro do mesmo Ã© um Vectorization.Text
    */
    context._vectorElementos2Textos = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            context.content[i] = Vectorization.Text(context.content[i], extraPropsOfLine);
        }
    }

    /**
    * @override
    * @returns {Array}
    */
    context.toArray = function(){
        if( context.usarTextos != undefined && context.usarTextos == true )
        {
            let valoresSemEstarEmTextos = [];
            context.paraCadaElemento(function(i, objetoTexto){
                valoresSemEstarEmTextos.push( objetoTexto.obterValor() );
            });

            return valoresSemEstarEmTextos;

        }else{
            return context.content;
        }
    }
    /**
    * @override
    * @returns {Array}
    */
    context.raw = context.toArray;

    if( context.configRecebidaUsuario['usarTextos'] != undefined || classConfig['usarTextos'] != undefined ){
        if( context.configRecebidaUsuario['usarTextos'] == true || classConfig['usarTextos'] == true )
        {
            context.usarTextos = true;
            context._vectorElementos2Textos();
        }
    }

    //Se tiver uma funÃ§Ã£o a ser aplicada por cima de tudo
    if( config['funcaoAplicar'] != undefined || classConfig['funcaoAplicar'] != undefined ){
        context.aplicarFuncao( config['funcaoAplicar'] || classConfig['funcaoAplicar'] );
    }

    return context;
};

/**
* MÃ©todos estÃ¡ticos
*/
window.Vectorization.StringVector.isStringVector = function(obj){
    return ((obj.objectName != undefined && (obj.objectName == 'StringVector' || obj.objectName == 'Vector')) || 
           Array.isArray(obj)) ? true : false;
}

window.Vectorization.StringVector.isVectorizationStringVector = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'StringVector' )
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringVector.js*/
/* ARQUIVO VECTORIZATION: ../src/StringVector-translation.js*/
/*
 * File Name: StringVector-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringVector._translations = function(){
    const translatedMethods = {
        
    };

    const translatedAttributes = {
        
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.StringVector._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringVector-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/BendableVector.js*/
/*
 * File Name: BendableVector.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    require('./Root'); 
    require('./Scalar');
    require('./Vector');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.BendableVector = function( config=[], classConfig={} ){
    //Define a traduÃ§Ã£o
    classConfig['translations'] = window.Vectorization.BendableVector._translations || null;

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Este Vectorization.BendableVector NÃO usa nÃºmeros, em vez disso, vamos especificar o que queremos
    classConfig['usarEscalares'] = false;

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.BendableVector.isVectorizationBendableVector(config) && config.objectName == 'BendableVector' ){
        return Vectorization.BendableVector( config.values(), classConfig );
    }

    //O StringVector serÃ¡ baseado no Vectorization.Vector
    let context = window.Vectorization.Vector(config, classConfig);
    context.objectName = 'BendableVector';
    context.extendedFrom = 'Vector';
    context.path = 'Vectorization.BendableVector';
    context.configRecebidaUsuario = config;
    
    context.storedClassConfig = classConfig || {};

    context.flexibilidade = classConfig['flexibilidade'] || false;

    //Mais opÃ§Ãµes de flexibilidade
    if( context.flexibilidade != undefined )
    {
        //Se for apenas um texto, com o nome do tipo, ele trata isso aqui
        if( typeof context.flexibilidade == 'string' ){
            context.flexibilidade = [ context.flexibilidade ];
        }

        //Se o usuario passar um array contendo apenas um elemento, ele vai usar ele como tipo para todos os elementos deste Vectorization.BendableVector
        if( context.flexibilidade instanceof Array && context.flexibilidade.length == 1 && context.content.length > 1 )
        {
            
            for( let i = 0 ; i < context.content.length-1 ; i++ )
            {
                //Completa com o tipo que veio
                context.flexibilidade.push(context.flexibilidade[0]);
            }

        }
    }

    if( context.flexibilidade ){
        if( context.flexibilidade.length != context.content.length ){
            throw 'o array flexibilidade precisa conter a mesma quantidade de elementos deste Vectorization.Vector'
        }
    }

    if( context.flexibilidade ){
        //Verifica se todos sÃ£o do tipo Vectorization.Text
        context.isTudoTexto = Vectorization.StringVector( Vectorization.isAlgumVetorVectorization(context.flexibilidade) ? [... context.flexibilidade.raw()] : [... context.flexibilidade] ).todosIguaisA('Text');
        
    }else{
        context.isTudoTexto = null;
    }

    //Se for tudo texto
    if( context.isTudoTexto == true ){
        context.herdarFuncoes( Vectorization.StringVector );
    }

    context.toText = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.StringVector( context.raw(), novasConfiguracoes);
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        novasConfiguracoes['usarEscalares'] = true;

        return Vectorization.Vector( context.raw(), novasConfiguracoes );
    }

    /**
    * @override
    * @param {Boolean} includeNamespace 
    * @returns {Array}
    */
    context.obterTiposRapido = function(includeNamespace=false){
        let tiposUsados = [];
        context.paraCadaElemento(function(i, elementoAtual){
            if( includeNamespace == true ){
                tiposUsados.push( 'Vectorization.' + String(elementoAtual.objectName) );

            }else{
                tiposUsados.push( String(elementoAtual.objectName) );
            }
        });

        return tiposUsados;
    }

    /**
    * @override 
    */
    context.rawProfundo = function(){
        
        if( (elementoAtual) => Vectorization.Scalar.isScalar(elementoAtual) == true || 
                               Vectorization.Text.isText(elementoAtual) == true ||
                               Vectorization.Boolean.isBoolean(elementoAtual) == true 
                            
        ){
            let valoresSemEstarEmEscalar = [];
            context.paraCadaElemento(function(i, objetoEscalar){

                if( Vectorization.Scalar.isScalar(objetoEscalar) || 
                    Vectorization.Text.isText(objetoEscalar) ||
                    Vectorization.Boolean.isBoolean(objetoEscalar) 

                ){
                    if( objetoEscalar.obterValor != undefined )
                    {
                        valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );

                    }else{
                        valoresSemEstarEmEscalar.push( objetoEscalar );
                    }

                }else{
                    valoresSemEstarEmEscalar.push( objetoEscalar );
                }
            });

            return valoresSemEstarEmEscalar;

        }else{
            return context.content;
        }

    }

    /**
    * @override
    * Permite fatiar(ou recortar) este vetor
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Vector} - o vetor recortado
    */
    context.slice = function(elementoInicial, elementoFinal, intervalo=1){
        let dadosRecortados = [];

        if( elementoInicial < 0 ){
            throw 'A elementoInicial precisa ser maior ou igual a zero!';
        }

        if( elementoFinal > context.length ){
            throw 'A elementoFinal precisa estar dentro da faixa de valores do Vector! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        let quantosForam = 0;
        for( let i = elementoInicial ; i < elementoFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.readIndex(i) );
            quantosForam = quantosForam + 1;
        }

        let quantidadeFalta = Math.abs(dadosRecortados.length - context.flexibilidade.length);
        let flexibilidadeAjustada = [... context.flexibilidade];

        if( context.flexibilidade.length < quantidadeFalta ){
            for( let i = 0 ; i < quantidadeFalta ; i++ ){
                //Completa com um tipo de dado qualquer
                flexibilidadeAjustada.push('texto');
            }
        }

        let novoVetorCriado = Vectorization.BendableVector(dadosRecortados, {
            flexibilidade: flexibilidadeAjustada
        } );

        return novoVetorCriado;
    }

    /**
    * @override
    * Obtem um novo Vector exatamente igual a este Vector
    * Ou seja, faz uma copia do propio objeto, identido, porÃ©m sem manter as referencias. 
    * @returns {Vectorization.Vector}
    */
    context.duplicar = function(){
        let novoVector = [];
        
        for( let i = 0 ; i < context.length ; i++ )
        {
            novoVector.push( context.readIndex(i) );
        }

        //Pra ser compativel com este Vectorization.BendableVector
        let extraPropsOfLine = {};
        if( context.flexibilidade ){
            extraPropsOfLine['flexibilidade'] = context.flexibilidade;
        }

        return Vectorization.BendableVector(novoVector, extraPropsOfLine);
    }

    /**
    * @override
    * Vai percorrer cada elemento deste Vectorization.Vector, visando localizar elementos que aparecem mais de uma vez.
    * E com isso, ele vai remover tais repetiÃ§Ãµes de elementos, retornando um novo Vectorization.Vector que nÃ£o contenha duplicidade. 
    * @returns {Vectorization.BendableVector} 
    */
    context.valoresUnicos = function(){
        const esteVetorCopiado = context.duplicar();
        const jaFoi = {};
        
        //Pra ser compativel com este Vectorization.BendableVector
        let extraPropsOfLine = {};
        //if( context.flexibilidade ){
        //    extraPropsOfLine['flexibilidade'] = context.flexibilidade;
        //}

        let novoVetor_sem_repeticoes = Vectorization.BendableVector([], extraPropsOfLine);

        esteVetorCopiado.paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);

            if( jaFoi[ elementoAtual ] == undefined )
            {
                novoVetor_sem_repeticoes.adicionarElemento(elementoAtual);
                jaFoi[ elementoAtual ] = true;
            }
        });

        return novoVetor_sem_repeticoes;
    }

    //Alias for duplicar
    context.clonar = context.duplicar;

    /**
    * MÃ©todo que converte este Vectorization.Vector para um Vectorization.Vector avanÃ§ado, onde nÃ£o importa qual o tipo de valor usado
    */
    context._vectorElementos2Flexibilidade = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};

            //context.content[i] = 'vamos identificar abaixo';
            switch( Vectorization.isAlgumValorVectorization( context.flexibilidade[i] ) ? context.flexibilidade[i].raw() : context.flexibilidade[i] ){
                case 'Escalar':
                case 'Scalar':
                case 'Number':
                case 'Numero':
                case 'numero':
                case 'escalar':
                    context.content[i] = Vectorization.Scalar(context.content[i], extraPropsOfLine);
                    break;

                case 'texto':
                case 'Texto':
                case 'Text':
                case 'String':
                case 'Letras':
                    context.content[i] = Vectorization.Text(context.content[i], extraPropsOfLine);
                    break;

                case 'booleano':
                case 'Booleano':
                case 'Boolean':
                case 'boolean':
                case 'Logico':
                    context.content[i] = Vectorization.Boolean(context.content[i], extraPropsOfLine);
                    break;

                default:
                    throw 'Tipo nÃ£o aceito';
            }
        }
    }

    context._vectorElementos2Flexibilidade();

    //Se existir uma traduÃ§Ã£o para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //Se tiver uma funÃ§Ã£o a ser aplicada por cima de tudo
    if( config['funcaoAplicar'] != undefined || classConfig['funcaoAplicar'] != undefined ){
        context.aplicarFuncao( config['funcaoAplicar'] || classConfig['funcaoAplicar'] );
    }

    return context;
};

/**
* MÃ©todos estÃ¡ticos
*/
window.Vectorization.BendableVector.isBendableVector = function(obj){
    if( obj == undefined ){ return false };
    return ((obj.objectName != undefined && (obj.objectName == 'BendableVector' || obj.objectName == 'Vector')) || 
           Array.isArray(obj)) ? true : false;
}

window.Vectorization.BendableVector.isVectorizationBendableVector = function(obj){
    if( obj == undefined ){ return false };
    return (obj.objectName != undefined && obj.objectName == 'BendableVector' )
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/BendableVector.js*/
/* ARQUIVO VECTORIZATION: ../src/BendableVector-translation.js*/
/*
 * File Name: BendableVector-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.BendableVector._translations = function(){
    const translatedMethods = {
        
    };

    const translatedAttributes = {
        
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.BendableVector._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/BendableVector-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Matrix.js*/
/*
 * File Name: Matrix.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    require('./Root');
    require('./Scalar');
    require('./Vector');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Matrix = function( config, classConfig={} ){
    //Define a traduÃ§Ã£o
    classConfig['translations'] = window.Vectorization.Matrix._translations || null;

    let classeBaseMatrix = window.Vectorization.Base({... classConfig});

    //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseMatrix.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar uma matrix a partir de outra matrix, ele recria a propio matrix passada, mantendo a estrutura como ainda sendo uma Matrix
    if( Vectorization.Matrix.isMatrix(config) && config.objectName == 'Matrix' ){
        return Vectorization.Matrix( config.raw() );
    }

    let context = window.Vectorization.Base(classConfig);
    context.objectName = 'Matrix';
    context.path = 'Vectorization.Matrix';
    
    context.configRecebidaUsuario = config;

    context.storedClassConfig = classConfig || {};

    //Aplica a traduÃ§Ã£o dos atributos, pra ser capaz de entender nomes de atributos em outros idiomas
    //classConfig = context.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Aplica a traduÃ§Ã£o dos atributos tambÃ©m no config, EXCETO SE config FOR UM ARRAY
    if( config instanceof Object && !(config instanceof Array && (config[0] instanceof Array || Vectorization.Vector.isVector(config[0]) || Vectorization.BendableVector.isVectorizationBendableVector(config[0]) )) ){
        config = context.translateAttributes_andReturn(config, classConfig['translations']() );
    }


    context.rows = config['rows'];
    context.columns = config['columns'];
    context.initialColumnValue = config['fillValue'] || 0;
    context.flexivel = config['flexibilidade'] || classConfig['flexibilidade'] || null;

    //Mais opÃ§Ãµes de flexibilidade
    if( context.flexivel != undefined && 
        config.length > 0 && 
        config[0] != undefined 
    ){
        //Se for apenas um texto, com o nome do tipo, ele trata isso aqui
        if( typeof context.flexivel == 'string' ){
            context.flexivel = [ context.flexivel ];
        }

        //Se o usuario passar um array contendo apenas um elemento, ele vai usar ele como tipo para todos os elementos deste Vectorization.BendableVector
        if( context.flexivel instanceof Array && context.flexivel.length == 1 && config[0].length > 1 )
        {
            
            for( let i = 0 ; i < config[0].length-1 ; i++ )
            {
                //Completa com o tipo que veio
                context.flexivel.push(context.flexivel[0]);
            }

        }
    }

    context.isFlexivelNasColunas = context.flexivel != undefined && context.flexivel != null ? true : false;

    context.content = [];

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

            if(context.isAdvancedMatrix == true)
            {
                //Bloquear tambÃ©m os filhos Vectorization.Vector dentro deste Vectorization.Matrix
                context.paraCadaLinha(function(i, elementoVetorLinhaMatrix){
                    elementoVetorLinhaMatrix.bloquearModificacoes();
                });
            }

        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Matrix!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;

            if(context.isAdvancedMatrix == true)
            {
                //Desbloquear tambÃ©m os filhos Vectorization.Vector dentro deste Vectorization.Matrix
                context.paraCadaLinha(function(i, elementoVetorLinhaMatrix){
                    elementoVetorLinhaMatrix.desbloquearModificacoes();
                });
            }
        }else{
            throw 'AÃ§Ã£o nÃ£o permitida para este Vectorization.Matrix!';
        }
    }

    //Alguns atributos uteis
    context.isTransposta = classConfig['isTransposta'] || false;
    context.isOposta = classConfig['isOposta'] || false;
    context.isIdentidade = classConfig['isIdentidade'] || false;
    context.isAdvancedMatrix = classConfig['advanced'] || true;

    if( classConfig['advanced'] == false ){
        context.isAdvancedMatrix = false;
    }

    //Se passar diretamente o conteudo
    if( config instanceof Array && (config[0] instanceof Array || Vectorization.Vector.isVector(config[0]) || Vectorization.BendableVector.isVectorizationBendableVector(config[0]) ) ){

        //Se as linhas forem vetores do pacote Vectorization
        if( Vectorization.Vector.isVectorizationVector( config[0] ) == true ||
            Vectorization.BendableVector.isVectorizationBendableVector( config[0] ) == true
        ){
            context.content = config;
            context.rows = config.length;
            context.columns = config[0].length;

        //Se as linhas forem vetores normais
        }else{
            context.content = config;
            context.rows = config.length;
            context.columns = config[0].length;
        }

    //Ou caso contrario
    }else{
        //Inicializa a matrix
        for( let i = 0 ; i < context.rows ; i++ )
        {
            context.content[i] = [];
            for( let j = 0 ; j < context.columns ; j++ )
            {
                context.content[i][j] = context.initialColumnValue;
            }
        }

        /**
        * 25/07/2024 16:55 PM
        *  BUG CORRIGIDO:
        *    se o objeto for uma lista de objetos Vectorization.Vector, da certo
        *    AGORA se o objeto for um Vectorization.Vector que contem outros Vectorization.Vector
        *    dava erro na linha 251
        */
        //Se a matrix nao foi inicializada E SE FOR UM VETOR DO VECTORIZATION QUE CONTEM OUTROS VETORES DO VECTORIZATION
        if( context.rows == undefined && Vectorization.Vector.isVectorizationVector(config) ){
            context.content = config.raw();
            context.rows = config.length;
            context.columns = config.lerIndice(0).length;
        }
    }


    //TambÃ©m, se o config for um objeto(NÃO FOR UM ARRAY)
    if( config instanceof Object && !(config instanceof Array && (config instanceof Array || Vectorization.Vector.isVector(config) )) ){
        context.aleatorio = config['aleatorio'] || false;

        if( config['aleatorio'] != undefined &&
            config['numeros'] != undefined
        ){
            throw 'Voce nÃ£o pode criar um Vectorization.Matrix com contÃ©udo definido, e ao mesmo tempo sendo aleatÃ³rio!';
        }
        
        if( context.aleatorio == true ){
            context.content = []; // Zero o conteudo

            //Se tem outros detalhes
            if( config['minimo'] != undefined && 
                config['maximo'] != undefined && 
                config['linhas'] != undefined &&
                config['colunas'] != undefined &&
                typeof config['minimo'] == 'number' &&
                typeof config['maximo'] == 'number' &&
                typeof context.rows == 'number' &&
                typeof context.columns == 'number'
            ){
                //Grava os parametros
                context.minimoAleatorio = config['minimo'];
                context.maximoAleatorio = config['maximo'];

                //Se tiver um nÃºmero base
                if( config['sementeAleatoria'] != undefined &&
                    typeof config['sementeAleatoria'] == 'number'
                ){
                    context.sementeAleatoria = config['sementeAleatoria'];
                }else{
                    context.sementeAleatoria = Vectorization.Random._sementeDefinida;
                }

                //Vai gerando os valores aleatorios enquanto nÃ£o terminar a quantidade de elementos
                Vectorization.Vector({
                    valorPreencher: 1,
                    elementos: context.rows

                }).paraCadaElemento(function(iLinhaMatrix, linhaMatrix){
                    let objLinhaMatrix = linhaMatrix;
                    context.content[iLinhaMatrix] = [];

                    Vectorization.Vector({
                        valorPreencher: 1,
                        elementos: context.columns

                    }).paraCadaElemento(function(jColunaMatrix, colunaMatrix){
                        let objColunaMatrix = colunaMatrix;
                        
                        let numeroAleatorioGeradoParaOIndice = Vectorization.Random.gerarNumeroAleatorio( Number(context.minimoAleatorio), Number(context.maximoAleatorio), context.sementeAleatoria );
                        context.content[iLinhaMatrix][jColunaMatrix] = numeroAleatorioGeradoParaOIndice;
                    });
                });

                //Se o programador quiser arredondar
                if( config['arredondar'] != undefined ){
                    Vectorization.Vector({
                        valorPreencher: 1,
                        elementos: context.rows
    
                    }).paraCadaElemento(function(iLinhaMatrix, linhaMatrix){
                        let objLinhaMatrix = context.content[iLinhaMatrix];

                        if( Vectorization.Vector.isVector(objLinhaMatrix) &&
                            Vectorization.Vector.isVectorizationVector(objLinhaMatrix)
                        ){
                           objLinhaMatrix.aplicarArredondamento(config['arredondar']);

                        }else{
                            if( Vectorization.Vector.isVector(objLinhaMatrix) )
                            {
                                let valoresObtidos = Vectorization.Vector(objLinhaMatrix).getValoresArredondados(config['arredondar']);
                                
                                for( let i = 0 ; i < valoresObtidos.tamanho() ; i++ )
                                {
                                    objLinhaMatrix[i] = valoresObtidos.readIndex(i);
                                }
                            }
                        }
                    });
                }

            }else{
                if( typeof config['minimo'] != 'number' ||
                    typeof config['maximo'] != 'number' ||
                    typeof context.rows != 'number' || 
                    typeof context.columns != 'number'
                ){
                    throw 'Os valores minimo, mÃ¡ximo e quantidade de elementos das linhas e colunas precisam ser nÃºmeros!. Tipo nÃ£o permitido.'
                
                }else{
                    throw 'Para criar uma Matrix aleatÃ³rio voce precisar passar a faixa de valores e a quantidade de elementos nas linhas e colunas!';
                }
            }

        }else if(context.aleatorio == false){
        
            if( config['numeros'] != undefined &&
                Vectorization.Vector.isVector(config['numeros'])
            ){
                if( config['aleatorio'] != undefined ){
                    throw 'Voce nÃ£o pode criar um Vectorization.Matrix com contÃ©udo definido, e ao mesmo tempo sendo aleatÃ³rio!';
                }

                context.content = config['numeros'] != undefined ? 
                                  (Vectorization.Matrix.isVectorizationMatrix(config['numeros']) ? config['numeros'].valores() : 
                                   config['numeros']) : [];
            }

            context.conteudo = context.content;

            if( config['numeros'] != undefined )
            {
                context.rows = config['numeros'].length;
                context.columns = config['numeros'][0].length;

            }else{
                context.rows = context.content.length;
                
                if( context.content[0] != undefined ){
                    context.columns = context.content[0].length;
                }else{
                    context.columns = 0;
                }
            }
        }
    }


    //Alias em portugues
    context.linhas = context.rows;
    context.colunas = context.columns;
    context.conteudo = context.content;

    //Uma matriz simples nunca vai ser profunda
    context.matrixProfunda = false;

    /**
    * MÃ©todo que converte a matrix para uma matrix avanÃ§ada, onde cada linha Ã© um Vector 
    */
    context._matrix2Advanced = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            extraPropsOfLine['index'] = i;

            if( context.isFlexivelNasColunas == true ){
                if( Vectorization.Vector.isVector(context.flexivel) ){
                    extraPropsOfLine['flexibilidade'] = [... context.flexivel];

                }else{
                    extraPropsOfLine['flexibilidade'] = context.flexivel;
                }

                context.content[i] = Vectorization.BendableVector(context.content[i], extraPropsOfLine);

            }else{
                context.content[i] = Vectorization.Vector(context.content[i], extraPropsOfLine);
            }

        }
        context.isAdvancedMatrix = true;
    }

    context.adicionarVetorComoColuna = function(vectorAdicionar){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        if( context.isAdvancedMatrix ){
            if( context.isFlexivelNasColunas == false ){
                context.content.push( vectorAdicionar );

            }else{
                context.content.push( vectorAdicionar );
            }

        }else{
            if( context.isFlexivelNasColunas == false ){
                context.content.push( vectorAdicionar );

            }else{
                context.content.push( vectorAdicionar );
            }
        }

        if( context.content != undefined ){
            context.rows = context.content.length;
        }

        if( context.content != undefined && 
            context.columns[0] != undefined
        ){
            context.columns = context.columns[0].length;
        }
    }

    /**
    * Obtem uma nova matriz exatamente igual a esta matrix.
    * Ou seja, faz um copia do propio objeto, identico, porÃ©m sem manter as referencias. 
    * @returns {Vectorization.Matrix}
    */
    context.duplicar = function(){
        let novaMatrix = [];
        let novaMatrix_Matrix = null; //Se for necessario

        if( context.isFlexivelNasColunas == true ){
            //Nesse caso foi necessario usar o novaMatrix_Matrix como Vectorization.Matrix
            novaMatrix_Matrix = Vectorization.Matrix([], {
                flexibilidade: context.flexivel
            });
        }

        for( let i = 0 ; i < context.rows ; i++ )
        {
            if( context.isFlexivelNasColunas == false ){
                novaMatrix.push( Vectorization.Vector(context.getLinha(i)).clonar() );

            }else{
                novaMatrix_Matrix.adicionarVetorComoColuna( Vectorization.BendableVector(context.getLinha(i), {
                    flexibilidade: context.flexivel
                }).clonar() );
            }
        }

        return context.isFlexivelNasColunas == false ? Vectorization.Matrix(novaMatrix) : 
                                                       novaMatrix_Matrix;
    }

    //Alias for duplicar
    context.clonar = context.duplicar;

    /**
    * Calcula a forma (shape) da matrix
    * @returns {Array} - A forma da matrix.
    */
    context.calcTamanhos = function() {
        let dadosMatrix = context.content || [];
        let formato = [];
        let nivelAtual = [... dadosMatrix.copyWithin()];

        while ( Vectorization.Vector.isVector(nivelAtual) ) 
        {
            formato.push(nivelAtual.length);
            nivelAtual = nivelAtual[0];
            if(nivelAtual == undefined){
                break;
            }
        }

        return Vectorization.Vector(formato);
    }

    //Alias for calcTamanhos
    context.calcSizes = context.calcTamanhos;
    context.calcShape = context.calcTamanhos;
    context.calcFormato = context.calcTamanhos;
    context.getFormato = context.calcTamanhos;

    /*
    Calcula o formato da matrix e armazena no objeto sizes
    Por padrÃ£o o formato vai ser [qtdeLinhas, qtdeColunas]
    */
    context.sizes = context.calcTamanhos();
    context.formato = context.sizes;

    context.tamanho = function(){
        return context.sizes;
    }

    /**
    * Verifica se esta matrix possui exatamente o mesmo formato de outra matrix
    * @param {Vectorization.Matrix} matrixB - A outra matrix.
    * @returns {Boolean} - Verdadeiro se as formas forem iguais, falso caso contrÃ¡rio.
    */
    context.isExatoMesmoTamanho = function(matrixB){
        if( context.calcTamanhos().isExatamenteIgual( matrixB.calcTamanhos() ) ){
            return true;
        }

        return false;
    }

    //Alias for isExatoMesmoTamanho
    context.isExatamenteMesmoTamanho = context.isExatoMesmoTamanho;
    context.isExatamenteMesmoFormato = context.isExatoMesmoTamanho;
    context.isMesmoTamanhoDe = context.isExatoMesmoTamanho;
    context.isMesmoFormatoDe = context.isExatoMesmoTamanho;
    context.isSameSizes = context.isExatoMesmoTamanho;

    /**
    * Compara se o contÃ©udo desta matrix Ã© exatamente igual ao contÃ©udo da outra matrix  
    * Ele faz isso comparando linha por linha.
    * @param {Vectorization.Matrix} matrixB - A outra matrix
    * @returns {Boolean} - Se o contÃ©udo Ã© exatamente igual ou nÃ£o
    */
    context.isExatamenteMesmoConteudo = function(matrixB){
        //Verifica se cada linha da matrixB Ã© exatamente igual a linha correspondende da matrix atual
        const mappedVector = Vectorization.Vector( context.map(function(i, valor, selfContext){
            const linhaAtual = i;
            return matrixB.getLinha(linhaAtual).isExatamenteIgual( context.getLinha(linhaAtual) );
        }) );

        //Verifica os resultados de mappedMatrix, se todos sÃ£o verdadeiros
        return mappedVector.todosVerdadeiros();
    }

    /**
    * Compara se esta matrix Ã© exatamente igual a outra matrix, tanto em formato quanto em contÃ©udo
    * @param {Vectorization.Matrix} matrixB - A outra matrix
    * @returns {Boolean} - Se sÃ£o iguais ou nÃ£o
    */
    context.isIgual = function(matrixB){
        return (context.isExatamenteMesmoTamanho(matrixB) == true && 
                context.isExatamenteMesmoConteudo(matrixB) == true);
    }

    //Alias for isIgual
    context.isEquals = context.isIgual;

    context.valueOf = function(){
        return context.content;
    }

    context.toString = function(){
        return String(context.content);
    }

    context.get = function(linha, coluna){
        return context.content[linha][coluna];
    }

    context.getLinha = function(linha){
        return context.content[linha];
    }

    //Alias for getLinha
    context.getLine = context.getLinha;

    context.values = function(){
        return context.content;
    }

    context.rawProfundo = function(){
        let rawValues = [];

        for( let i = 0 ; i < context.rows ; i++ )
        {
            rawValues[i] = context.content[i].rawProfundo();
        }

        return rawValues;
    }

    context.rawValues = function(){
        let rawValues = [];

        //Se for um Vectorization.Matrix com essa opcao especifica ativa, usa por padrao o profundo
        if( context.isFlexivelNasColunas == true ){
            return context.rawProfundo();
        }

        for( let i = 0 ; i < context.rows ; i++ )
        {
            rawValues[i] = context.content[i].values();
        }

        return rawValues;
    }

    context.raw = function(){
        return context.rawValues();
    }

    context.mostrarTabela = function(){
        console.table( context.rawValues() );
    }

    context.mostrar = function(){
        console.log( context.rawValues() );
    }

    context.push = function(element){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        if( context.isAdvancedMatrix ){
            context.content.push( element.objectName != undefined && element.objectName == 'Vector' ? element : Vectorization.Vector(element) );

        }else{
            context.content.push(element);
        }
    }

    context.obterTiposRapido = function(includeNamespace=false){
        let tiposUsados = [];
        context.paraCadaLinha(function(i, elementoAtual){
            tiposUsados.push( elementoAtual.obterTiposRapido(includeNamespace) );
        });

        return tiposUsados;
    }

    context.identificarTiposColuna = function(numeroColuna){
        const resultado = Vectorization.Base({
            tipos: Vectorization.Vector([], {usarEscalares: false})
        });

        context.percorrerColuna(numeroColuna, function(iColuna, valorColuna){
            resultado.tipos.adicionarElemento( window.Vectorization.identificarTipo( valorColuna ) );
        });

        resultado.tiposUnicos = resultado.tipos.valoresUnicos();
        resultado.raw = function(){
            return resultado.tipos.raw();
        }

        return resultado;
    }
    context.getTiposColuna = context.identificarTiposColuna;
    context.obterTiposColuna = context.identificarTiposColuna;

    /**
    * Permite fatiar(ou recortar) a matrix
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Matrix} - a matriz recortada
    */
    context.slice = function(linhaInicial, linhaFinal, intervalo=1){
        let dadosRecortados = [];

        if( linhaInicial < 0 ){
            throw 'A linhaInicial precisa ser maior ou igual a zero!';
        }

        if( linhaFinal > context.rows ){
            throw 'A linhaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        for( let i = linhaInicial ; i < linhaFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.getLinha(i).raw() );
        }

        return Vectorization.Matrix(dadosRecortados);
    }

    context.recortarLinhas = context.slice;
    context.sliceLinhas = context.slice;

    /**
     * Similar ao context.slice, porÃ©m executado nas colunas
     * @param {Number} colunaInicial 
     * @param {Number} colunaFinal 
     * @param {Number} intervaloLinhas 
     * @param {Number} intervaloColunas 
     * @returns {Vectorization.Matrix}
     */
    context.recortarColunas = function(colunaInicial, colunaFinal='nao_definida', intervaloLinhas=1, intervaloColunas=1){
        let dadosRecortados = [];

        if( colunaFinal == 'nao_definida' ){
            colunaFinal = context.columns + 1;
        }

        if( colunaInicial < 0 ){
            throw 'A colunaInicial precisa ser maior ou igual a zero!';
        }

        if( colunaFinal > context.rows ){
            throw 'A colunaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        for( let i = 0 ; i < context.rows ; i = i + intervaloLinhas )
        {
            dadosRecortados[ i ] = context.getLinha(i)
                                          .slice( colunaInicial, colunaFinal, intervaloColunas );
        }

        return Vectorization.Matrix(dadosRecortados);
    }

    /**
     * Similar ao context.slice, porÃ©m executado nas colunas
     * @param {Number} colunaInicial 
     * @param {Number} colunaFinal 
     * @param {Number} intervaloLinhas 
     * @param {Number} intervaloColunas 
     * @returns {Vectorization.Matrix}
     */
    context.sliceColunas = context.recortarColunas;

    /**
     * Similar ao context.slice, porÃ©m executado nas linhas e tambÃ©m nas colunas
     * @param {Number} linhaInicial 
     * @param {Number} linhaFinal 
     * @param {Number} colunaInicial 
     * @param {Number} colunaFinal 
     * @param {Number} intervaloLinhas 
     * @param {Number} intervaloColunas 
     * @returns {Vectorization.Matrix}
     */
    context.recortarRegiao = function(linhaInicial, linhaFinal, colunaInicial, colunaFinal='nao_definida', intervaloLinhas=1, intervaloColunas=1){
        let dadosRecortados = [];

        if( linhaInicial < 0 ){
            throw 'A linhaInicial precisa ser maior ou igual a zero!';
        }

        if( linhaFinal > context.rows ){
            throw 'A linhaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        if( colunaFinal == 'nao_definida' ){
            colunaFinal = context.columns + 1;
        }

        if( colunaInicial < 0 ){
            throw 'A colunaInicial precisa ser maior ou igual a zero!';
        }

        if( colunaFinal > context.rows ){
            throw 'A colunaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        for( let i = linhaInicial ; i < linhaFinal ; i = i + intervaloLinhas )
        {
            dadosRecortados[ i ] = context.getLinha(i)
                                          .slice( colunaInicial, colunaFinal, intervaloColunas );
        }

        return Vectorization.Matrix(dadosRecortados);
    }

    /**
    * Similar ao context.slice, porÃ©m executado nas linhas e tambÃ©m nas colunas
    * @param {Number} linhaInicial 
    * @param {Number} linhaFinal 
    * @param {Number} colunaInicial 
    * @param {Number} colunaFinal 
    * @param {Number} intervaloLinhas 
    * @param {Number} intervaloColunas 
    * @returns {Vectorization.Matrix}
    */
    context.slice2 = context.recortarRegiao;

    /**
    * Permite extrair valores de uma coluna especifica
    * @param {Number} indiceColuna - o indice da coluna que queremos extrair os valores
    * @returns {Vectorization.Vector || Array}
    */
    context.extrairValoresColuna = function(indiceColuna){
        let valoresColuna = [];
        for( let i = 0 ; i < context.rows ; i++ )
        {
            valoresColuna.push( Vectorization.Vector(context.getLinha(i)).readIndex(indiceColuna) );
        }

        if( context.isAdvancedMatrix ){
            if( context.isFlexivelNasColunas == true ){
                let extraPropsOfLine = {};

                //Cada coluna pode ter o seu
                if( Vectorization.Text.isText( valoresColuna[0] ) ){
                    extraPropsOfLine['flexibilidade'] = Vectorization.Vector({
                        usarEscalares: false,
                        valorPreencher: 'Texto',
                        elementos: valoresColuna.length
                    });

                }else if( Vectorization.Scalar.isScalar( valoresColuna[0] ) ){
                    extraPropsOfLine['flexibilidade'] = Vectorization.Vector({
                        usarEscalares: false,
                        valorPreencher: 'Numero',
                        elementos: valoresColuna.length
                    });
                }

                return Vectorization.BendableVector( valoresColuna, extraPropsOfLine );

            }else if (context.isFlexivelNasColunas == false ){
                return Vectorization.Vector( valoresColuna );
            }

        }else{
            return valoresColuna;
        }
    }

    context.extrairValoresLinha = context.getLinha;

    context._definirValorLinha = function(indice, indiceAdicionar, vetorDaLinha){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.getLinha(indice)
               .definirElementoNoIndice(indiceAdicionar, vetorDaLinha);
    }

    context.definirValorLinha = function(indice, indiceAdicionar, vetorDaLinha){
        context._definirValorLinha(indice, indiceAdicionar, vetorDaLinha);
    }

    //Cria uma nova coluna nesta Vectorization.Matrix
    context.adicionarColuna = function(valoresNovaColuna){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        let isVetorVectorization = (
            Vectorization.Vector.isVector(valoresNovaColuna || []) == true &&
            Vectorization.Vector.isVectorizationVector(valoresNovaColuna || []) 
        ) == true;
           
        let valoresNovaColuna_Vector = isVetorVectorization == true ? valoresNovaColuna : Vectorization.Vector(valoresNovaColuna || []);
        let tamanhoVetorNovo = valoresNovaColuna_Vector.tamanho();
        let quantidadeLinhasMatrix = context.getRows();

        if( typeof valoresNovaColuna_Vector == 'object' &&
            tamanhoVetorNovo == quantidadeLinhasMatrix
        ){
            //Para cada linha
            Vectorization.Vector({
                valorPreencher: 1,
                elementos: quantidadeLinhasMatrix

            }).paraCadaElemento(function(iLinha){
                let valoresDaLinhaObtidos = context.getLinha(iLinha);

                switch( Vectorization.Vector.isVectorizationVector(valoresDaLinhaObtidos) || 
                        Vectorization.BendableVector.isVectorizationBendableVector(valoresDaLinhaObtidos) 
                ){
                    case true:
                        valoresDaLinhaObtidos.adicionarElemento( valoresNovaColuna[iLinha] );
                        break;

                    case false:
                        let novoVetorVectorization = Vectorization.Vector(valoresDaLinhaObtidos).adicionarElemento( valoresNovaColuna[iLinha] )
                        context._definirValorLinha(iLinha, valoresDaLinhaObtidos.length, [... novoVetorVectorization.valores()] );
                        break;
                }
            });

            //Atualiza a quantidade das colunas
            context.columns = matrix1.calcTamanhos().lerIndice(1);
            context.colunas = context.columns;

        }else{
            throw 'NÃ£o da pra adicionar uma nova coluna se a quantidade de elementos nÃ£o bater com a quantidade de linhas!. NÃ£o permitido.';
        }
    }

    context.zerarColuna = function(indiceColuna, valorDefinirNoLugar=0){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        let quantidadeLinhasMatrix = context.getLinhas();

        //Para cada linha
        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix

        }).paraCadaElemento(function(iLinha){
            context._definirValorLinha(iLinha, indiceColuna, valorDefinirNoLugar );
        });
    }

    /**
    * @param {Number} indiceColuna 
    * @param {Number} valorDefinirNoLugar 
    * @param {Number} funcaoDeCondicao - a funÃ§Ã£o(indiceDaLinhaAtual, indiceDaColunaEmQuestao, vetorDaLinhaAtual, valoresBrutosDaLinha, valorDaColunaAtualDaLinhaAtual, contextoPropiaMatrix) 
    */
    context.zerarColunaOnde = function(indiceColuna, valorDefinirNoLugar=0, funcaoDeCondicao){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }
        
        if( typeof funcaoDeCondicao == 'function' && funcaoDeCondicao != undefined )
        {
            let quantidadeLinhasMatrix = context.getLinhas();

            //Para cada linha
            Vectorization.Vector({
                valorPreencher: 1,
                elementos: quantidadeLinhasMatrix

            }).paraCadaElemento(function(iLinha){
                let vetorDaLinhaAtual = context.getLinha(iLinha),
                    valoresBrutosDaLinha = vetorDaLinhaAtual.valores(),
                    indiceDaLinhaAtual = iLinha,
                    indiceDaColunaEmQuestao = indiceColuna,
                    valorDaColunaAtualDaLinhaAtual = vetorDaLinhaAtual.readIndex(indiceColuna),
                    contextoPropiaMatrix = context;

                let checagemDaFuncaoDeCondicao = funcaoDeCondicao(indiceDaLinhaAtual, indiceDaColunaEmQuestao, vetorDaLinhaAtual, valoresBrutosDaLinha, valorDaColunaAtualDaLinhaAtual, contextoPropiaMatrix);

                if( checagemDaFuncaoDeCondicao == true || checagemDaFuncaoDeCondicao == 'limpar' || checagemDaFuncaoDeCondicao == 'zerar' || checagemDaFuncaoDeCondicao == 'clear' || checagemDaFuncaoDeCondicao == 'clean'){
                    context._definirValorLinha(iLinha, indiceColuna, valorDefinirNoLugar );
                }
            });

        }else{
            throw 'Precisa ter a funcaoDeCondicao';
        }
    }

    context.zerarLinha = function(indiceLinha, valorDefinirNoLugar=0){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.getLinha(indiceLinha).substituirElementosPor( Vectorization.Vector({
            valorPreencher: valorDefinirNoLugar,
            elementos: context.columns
        }) );
    }

    /**
    * Aplica um arredondamento sobre os valores deste vetor
    * CUIDADO: isso vai sobrescrever os valores
    * 
    * @param {String} tipoArredondamentoAplicar
    * @returns {Vectorization.Matrix} - a matrix arredondada
    */
    context.aplicarArredondamento = function(tipoArredondamentoAplicar='cima'){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: context.rows

        }).paraCadaElemento(function(i){
            let subVetorAplicarArredondamento = context.getLinha(i);

            if( Vectorization.Vector.isVectorizationVector(subVetorAplicarArredondamento) ){
                subVetorAplicarArredondamento.aplicarArredondamento(tipoArredondamentoAplicar);
            }
        });

        return context;
    }

    /**
    * Vai tornar possivel que voce ande por todos os elementos que estÃ£o presentes dentro da coluna especifica que vc passar como parametro.
    * @param {Number} indiceColuna - o indice da coluna em questÃ£o
    * @param {Function} callbackPercorrer - callbackPercorrer(valorNoIndiceDeInteresse, iLinha, LinhaMatrix_Vector, context)
    */
    context.percorrerColuna = function(indiceColuna, callbackPercorrer){
        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let valorNoIndiceDeInteresse = LinhaMatrix_Vector.lerIndice(indiceColuna);

            callbackPercorrer( 
                      indiceColuna,
                      valorNoIndiceDeInteresse, 
                      iLinha, 
                      LinhaMatrix_Vector, 
                      context 
                    );
        });
    }

    context.paraCadaColuna = context.percorrerColuna;

    /**
    * Vai tornar possivel que voce ande por todos os elementos que estÃ£o presentes dentro da coluna especifica que vc passar como parametro.
    * SIMILAR AO context.percorrerColuna, porÃ©m ele vai implementar algo mais parecido com o Vectorization.Vector.mapearValores
    * @param {Number} indiceColuna - o indice da coluna em questÃ£o
    * @param {Function} callbackMapeamento - callbackMapeamento(valorNoIndiceDeInteresse, iLinha, LinhaMatrix_Vector, context)
    * @returns {Vectorization.Vector} - a coluna apÃ³s a aplicaÃ§Ã£o desta funÃ§Ã£o
    */
    context.mapearColuna = function(indiceColuna, callbackMapeamento){
        let valoresAposAplicacaoMetodo = Vectorization.Vector([]);

        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let valorNoIndiceDeInteresse = LinhaMatrix_Vector.lerIndice(indiceColuna);

            let resultadoAplicacaoFuncao = callbackMapeamento( valorNoIndiceDeInteresse, 
                      iLinha, LinhaMatrix_Vector, context 
                    );

            valoresAposAplicacaoMetodo.adicionarElemento(resultadoAplicacaoFuncao);
        });

        return Vectorization.Vector(valoresAposAplicacaoMetodo);
    }

    /**
    * Vai permitir "Peneirar" os elementos que estÃ£o presentes dentro da coluna especifica que vc passar como parametro.
    * SIMILAR AO Vectorization.Vector.filtrarValores
    * @param {Number} indiceColuna - o indice da coluna em questÃ£o
    * @param {Function} callbackFiltragem - callbackFiltragem(valorNoIndiceDeInteresse, iLinha, LinhaMatrix_Vector, context)
    * @returns {Vectorization.Vector} - a coluna apÃ³s a aplicaÃ§Ã£o deste filtro
    */
    context.filtrarColuna = function(indiceColuna, callbackFiltragem){
        let valoresAposAplicacaoMetodo = Vectorization.Vector([]);

        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let valorNoIndiceDeInteresse = LinhaMatrix_Vector.lerIndice(indiceColuna);

            if(!callbackFiltragem){
                throw 'Voce precisa passar uma funÃ§Ã£o de filtro!. NÃ£o permitido!';
            }

            let resultadoAplicacaoFuncao = callbackFiltragem( valorNoIndiceDeInteresse, 
                      iLinha, LinhaMatrix_Vector, context 
                    );

            let checagemDoFiltro = resultadoAplicacaoFuncao;

            if(checagemDoFiltro == true || checagemDoFiltro == 'incluir' || checagemDoFiltro == 'manter' || checagemDoFiltro == 'keep' || checagemDoFiltro == 'ok'){
                valoresAposAplicacaoMetodo.adicionarElemento(valorNoIndiceDeInteresse);
            }

        });

        return Vectorization.Vector(valoresAposAplicacaoMetodo);
    }

    /**
    * Aplica um "peneiramento" na coluna desta Vectorization.Matrix
    * @param {Number} indiceColuna - o indice da coluna em questÃ£o
    * @param {Function} callbackFiltragem - callbackFiltragem(iColuna, elementoNaPosicaoAtual, context)
    * @returns {Vectorization.Matrix} - Esta propia Vectorization.Matrix
    * 
    * CUIDADO: isso vai sobrescrever esta Vectorization.Matrix
    */
    context.aplicarFiltroColuna = function(indiceColuna, callbackFiltragem){
        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let LinhaMatrix_Vector_copia = ( LinhaMatrix_Vector || Vectorization.Vector([]) ).duplicar();
            let dadosLinhaMatrix_Vector_Filtrados = Vectorization.Vector( LinhaMatrix_Vector_copia.filtrarValores(callbackFiltragem) );

            if(!callbackFiltragem){
                throw 'Voce precisa passar uma funÃ§Ã£o de filtro!. NÃ£o permitido!';
            }

            if( Vectorization.Vector.isVectorizationVector(dadosLinhaMatrix_Vector_Filtrados) ){
                //Atualiza esta Vectorization.Matrix
                LinhaMatrix_Vector.sobrescreverConteudo(
                    Vectorization.Vector( dadosLinhaMatrix_Vector_Filtrados.valores() || [] )
                );

            }else{
                console.warn('Nenhum filtro foi aplicado');
            }

        });

        return context;
    }

    /**
    * Descobre qual que Ã© a maior quantidade de elementos das linhas cadastradas na matrix
    */
    context.getMaiorQuantidadeColunas = function(){
        let primeiraLinha = context.getLinha(0);
        let maiorQuantiaAtualmenteObtida = primeiraLinha.tamanho();
        let quantidadeLinhasMatrix = context.rows;

        Vectorization.Vector({
           valorPreencher: 1,
           elementos: quantidadeLinhasMatrix
           
        }).paraCadaElemento(
            function(i){
                let linhaAtual = context.getLinha(i);
                let tamanhoDaLinhaAtual = linhaAtual.tamanho();
                maiorQuantiaAtualmenteObtida = (maiorQuantiaAtualmenteObtida <= tamanhoDaLinhaAtual) ? tamanhoDaLinhaAtual : maiorQuantiaAtualmenteObtida;
            });

        return maiorQuantiaAtualmenteObtida;
    }

    /**
    Descobre qual que Ã© a linha que tem mais quantidade de elementos.
    */
    context.getMaiorLinha = function(){
        let primeiraLinha = context.getLinha(0);
        let maiorLinha = primeiraLinha;
        let quantidadeLinhasMatrix = context.rows;
        let maiorQuantidadeColunas = context.getMaiorQuantidadeColunas();

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix
            
         }).paraCadaElemento(
             function(i){
                 let linhaAtual = context.getLinha(i);
                 let tamanhoDaLinhaAtual = linhaAtual.tamanho();
                 if( tamanhoDaLinhaAtual >= maiorQuantidadeColunas ){ maiorLinha = linhaAtual };
             });

        return maiorLinha;
    }

    /**
    * MÃ©todo que ele vai sair percorrendo cada linha, e vai deixar todas as linhas com a mesma quantidade de elemeentos
    * Se baseando estritamente na quantidade de colunas atual desta Vectorization.Matrix
    */
    context.igualarColunas = function(valorDefinirNoLugar){
        let maiorQuantidadeColunas = context.getMaiorQuantidadeColunas();
        let quantidadeLinhasMatrix = context.rows;

        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix
            
        }).paraCadaElemento(function(i){
            let linhaAtual = context.getLinha(i);
            let tamanhoDaLinhaAtual = linhaAtual.tamanho();

            if( tamanhoDaLinhaAtual < maiorQuantidadeColunas )
            {
                let quantosElementosFaltam = Math.abs( tamanhoDaLinhaAtual - maiorQuantidadeColunas );
                
                let novoVetorASerAcrescentado = Vectorization.Vector({
                    valorPreencher: valorDefinirNoLugar,
                    elementos: quantosElementosFaltam
                });

                //Vai acrescentar um novo Vectorization.Vector dentro da linha atual desta Vectorization.Matrix
                //Vai usar um mÃ©todo chamado acrescentarVetor do Vectorization.Vector
                linhaAtual.acrescentarVetor(novoVetorASerAcrescentado);
            }
        });
    }

    /**
    * Quase identico ao context.igualarColunas, porÃ©m com uma diferenÃ§a drÃ¡stica: ele adiciona no inicio da linha
    * 
    * MÃ©todo que ele vai sair percorrendo cada linha, e vai deixar todas as linhas com a mesma quantidade de elemeentos
    * Se baseando estritamente na quantidade de colunas atual desta Vectorization.Matrix
    */
    context.igualarColunasNoInicio = function(valorDefinirNoLugar){
        let maiorQuantidadeColunas = context.getMaiorQuantidadeColunas();
        let quantidadeLinhasMatrix = context.rows;

        //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix
            
        }).paraCadaElemento(function(i){
            let linhaAtual = context.getLinha(i);
            let tamanhoDaLinhaAtual = linhaAtual.tamanho();

            if( tamanhoDaLinhaAtual < maiorQuantidadeColunas )
            {
                let quantosElementosFaltam = Math.abs( tamanhoDaLinhaAtual - maiorQuantidadeColunas );
                
                let novoVetorASerAcrescentado = Vectorization.Vector({
                    valorPreencher: valorDefinirNoLugar,
                    elementos: quantosElementosFaltam
                });

                //Vai acrescentar um novo Vectorization.Vector dentro da linha atual desta Vectorization.Matrix
                //Vai usar um mÃ©todo chamado acrescentarVetor do Vectorization.Vector
                linhaAtual.acrescentarNoInicioVetor(novoVetorASerAcrescentado.valores());
            }
        });
    }

    context.adicionarEmTodasLinhas = function(){

    }

    /**
    * Percorre cada linha da matrix, aplicando uma funÃ§Ã£o de callback
    * @param {Function} callback(index, element, context)
    */
    context.forEach = function(callback){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            callback( i, context.content[i], context );
        }
    }

    /**
    * Percorre cada linha da matrix, aplicando uma funÃ§Ã£o de callback, retornando um resultado
    * @param {Function} callback(index, element, context)
    * @returns {Vectorization.Vector or Vectorization.Matrix}
    */
    context.map = function(callback){
        let novaMatrix = [];

        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novaMatrix[i] = callback( i, context.content[i], context );
        }

        //Se a funÃ§Ã£o de callback ao ser aplicada resultar numa matrix, entÃ£o ele converte resultado para Matrix
        if( Vectorization.Vector.isVector( novaMatrix[0] ) ){
            return Vectorization.Matrix(novaMatrix);
        }else{
            return Vectorization.Vector(novaMatrix);
        }
    }

    /**
     * Produto escalar de uma matriz com um vetor ou outra matriz
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matriz-com-vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matrizes
     * 
     * @param {Vectorization.Matrix} matrixA
     * @param {Object} matrixB
     * @returns {Object}
    */
    context.produtoEscalar = function( matrixB ){
        let matrixA = context;
        /**
        * Regra: percorre na vertical a matrixB, para cada coluna:
        * Coluna1 matrixB com linha1 matrixA, depois Coluna2 da matrixB com linha1 da matrixA.
        */

        if( !matrixB.objectName || (matrixB.objectName != 'Matrix' && matrixB.objectName != 'Vector') ){
            throw 'matrixB must be a Vectorization.Matrix';
        }

        if( matrixA.rows != (matrixB.columns || matrixB.length) ){
            throw 'The number of rows in matrixA must be exactly equal to the number of columns in matrixB. Impossible to calculate!';
        }

        //Se o segundo parametro for uma matrix
        if( matrixB.objectName == 'Matrix' ){
            let resultMatrix = [];
            let ordemColunasB = [];

            //Esse trecho Ã© semelhante a uma transposiÃ§Ã£o de matriz, pra tornar possivel os calculos
            for( let coluna = 0 ; coluna < matrixB.columns ; coluna++ ){

                //Extrair os valores da coluna atual da matrixB
                let valoresColunaBAtual = [];
                for( let linha = 0 ; linha < matrixB.rows ; linha++ ){
                    valoresColunaBAtual.push( matrixB.content[linha][coluna] );
                }

                //Salva isso numa lista, em ordem certa para os calculos abaixo no proximo bloco a seguir:
                ordemColunasB.push( valoresColunaBAtual );

            }   

            //Proxima etapa: percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){

                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];

                //Cria um array vazio para a linha. Esse array vai ser usado para armazenar os produtos feitos com os valores da linha abaixo:
                resultMatrix[linha] = [];
                
                //Percorre cada "fileira"(ou melhor dizendo, cada fileira Ã© um vetor contendo cada valor da colunaB atual, ou seja, em sentido vertical) da matrix B
                for( let colunaB = 0 ; colunaB < ordemColunasB.length ; colunaB++ ){

                    //Obtem a fileira atual da matrix B(o vetor atual)
                    let valoresColunaBAtual = ordemColunasB[colunaB];

                    //Inicializa a variavel que serÃ¡ usada para a soma ponderada
                    let produtoAtual = 0;
                    //Percorre cada indice dos valores da fileira atual da matrix B
                    for( let indexValor = 0 ; indexValor < valoresColunaBAtual.length ; indexValor++ ){
                        produtoAtual += ( valoresLinhaAtual[indexValor] * valoresColunaBAtual[indexValor] );
                    }

                    //Atribui o produto dentro da linha atual da matriz resultante, isso Ã© feito em ordem sequencial
                    resultMatrix[linha].push( produtoAtual );

                    //... vai pro prÃ³ximo produto [...], permanecendo na linha atual da matrixA

                }
            }

            return Vectorization.Matrix(resultMatrix);

        //Se o segundo objeto for um Vector
        }else if( matrixB.objectName == 'Vector' ){
            if( matrixA.rows != matrixB.length ){
                throw 'The number of lines in matrixA must be exactly equal to the number of elements in the vector. Impossible to calculate!';
            }
        
            let vetorResultado = [];
        
            //Percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){
        
                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];
        
                //Inicializa a variavel que serÃ¡ usada para a soma ponderada da linha atual
                let produtoAtual = 0;
        
                //Percorre cada elemento do vetor B
                for( let colunaB = 0 ; colunaB < matrixB.length ; colunaB++ ){
                    produtoAtual += ( valoresLinhaAtual[colunaB] * matrixB.readIndex(colunaB) );
                }
        
                //Vai adicionando os resultados no vetor de resultado
                vetorResultado.push(produtoAtual);
            }
        
            return Vectorization.Vector(vetorResultado);
        }
    }

    /**
     * Produto escalar de uma matriz com outra matriz
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matriz-com-vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matrizes
     * 
     * @param {Vectorization.Matrix} matrixA
     * @param {Vectorization.Matrix} matrixB
     * @returns {Vectorization.Matrix}
    */
    context.produtoEscalarMatrix = function( matrixB ){
        let matrixA = context;
        /**
        * Regra: percorre na vertical a matrixB, para cada coluna:
        * Coluna1 matrixB com linha1 matrixA, depois Coluna2 da matrixB com linha1 da matrixA.
        */

        if( !matrixB.objectName || (matrixB.objectName != 'Matrix' && matrixB.objectName != 'Vector') ){
            throw 'matrixB must be a Vectorization.Matrix';
        }

        if( matrixA.rows != (matrixB.columns || matrixB.length) ){
            throw 'The number of rows in matrixA must be exactly equal to the number of columns in matrixB. Impossible to calculate!';
        }

        //Se o segundo parametro for uma matrix
        if( matrixB.objectName == 'Matrix' ){
            let resultMatrix = [];
            let ordemColunasB = [];

            //Esse trecho Ã© semelhante a uma transposiÃ§Ã£o de matriz, pra tornar possivel os calculos
            for( let coluna = 0 ; coluna < matrixB.columns ; coluna++ ){

                //Extrair os valores da coluna atual da matrixB
                let valoresColunaBAtual = [];
                for( let linha = 0 ; linha < matrixB.rows ; linha++ ){
                    valoresColunaBAtual.push( matrixB.content[linha][coluna] );
                }

                //Salva isso numa lista, em ordem certa para os calculos abaixo no proximo bloco a seguir:
                ordemColunasB.push( valoresColunaBAtual );

            }   

            //Proxima etapa: percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){

                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];

                //Cria um array vazio para a linha. Esse array vai ser usado para armazenar os produtos feitos com os valores da linha abaixo:
                resultMatrix[linha] = [];
                
                //Percorre cada "fileira"(ou melhor dizendo, cada fileira Ã© um vetor contendo cada valor da colunaB atual, ou seja, em sentido vertical) da matrix B
                for( let colunaB = 0 ; colunaB < ordemColunasB.length ; colunaB++ ){

                    //Obtem a fileira atual da matrix B(o vetor atual)
                    let valoresColunaBAtual = ordemColunasB[colunaB];

                    //Inicializa a variavel que serÃ¡ usada para a soma ponderada
                    let produtoAtual = 0;
                    //Percorre cada indice dos valores da fileira atual da matrix B
                    for( let indexValor = 0 ; indexValor < valoresColunaBAtual.length ; indexValor++ ){
                        produtoAtual += ( valoresLinhaAtual[indexValor] * valoresColunaBAtual[indexValor] );
                    }

                    //Atribui o produto dentro da linha atual da matriz resultante, isso Ã© feito em ordem sequencial
                    resultMatrix[linha].push( produtoAtual );

                    //... vai pro prÃ³ximo produto [...], permanecendo na linha atual da matrixA

                }
            }

            return Vectorization.Matrix(resultMatrix);

        //Se o segundo objeto for um Vector
        }else if( matrixB.objectName == 'Vector' ){
            throw 'O segundo parametro precisa ser uma Matrix!';
        }
    }

    /**
     * Produto escalar de uma matriz com um vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matriz-com-vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matrizes
     * 
     * @param {Vectorization.Matrix} matrixA
     * @param {Vectorization.Vector} matrixB
     * @returns {Vectorization.Vector}
    */
    context.produtoEscalarVetor = function( matrixB ){
        let matrixA = context;
        /**
        * Regra: percorre na vertical a matrixB, para cada coluna:
        * Coluna1 matrixB com linha1 matrixA, depois Coluna2 da matrixB com linha1 da matrixA.
        */

        if( !matrixB.objectName || (matrixB.objectName != 'Matrix' && matrixB.objectName != 'Vector') ){
            throw 'matrixB must be a Vectorization.Matrix';
        }

        if( matrixA.rows != (matrixB.columns || matrixB.length) ){
            throw 'The number of rows in matrixA must be exactly equal to the number of columns in matrixB. Impossible to calculate!';
        }

        //Se o segundo parametro for uma matrix
        if( matrixB.objectName == 'Matrix' ){
            throw 'O segundo parametro precisa ser um Vector!';

        //Se o segundo objeto for um Vector
        }else if( matrixB.objectName == 'Vector' ){
            if( matrixA.rows != matrixB.length ){
                throw 'The number of lines in matrixA must be exactly equal to the number of elements in the vector. Impossible to calculate!';
            }
        
            let vetorResultado = [];
        
            //Percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){
        
                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];
        
                //Inicializa a variavel que serÃ¡ usada para a soma ponderada da linha atual
                let produtoAtual = 0;
        
                //Percorre cada elemento do vetor B
                for( let colunaB = 0 ; colunaB < matrixB.length ; colunaB++ ){
                    produtoAtual += ( valoresLinhaAtual[colunaB] * matrixB.readIndex(colunaB) );
                }
        
                //Vai adicionando os resultados no vetor de resultado
                vetorResultado.push(produtoAtual);
            }
        
            return Vectorization.Vector(vetorResultado);
        }
    }

    /**
     * Multiplica esta matrix com outra, de maneira elemento a elemento
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-elemento-a-elemento/codigo-principal.js
     * 
     * @param {Vectorization.Matrix} matrixB_param
     * @returns {Vectorization.Matrix}
    */
    context.multiplicarMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E nÃ£o um ' + String(matrixB_param.objectName);
        }

        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let matrixResultado = [];

        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                matrixResultado[i].push( matrixA[i][j] * matrixB[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Multiplica esta matrix por um nÃºmero
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Matrix}
     */
    context.multiplicarNumero = function(numero){
        let matrixA = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];
    
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                matrixResultado[i].push( matrixA[i][j] * numero );
            }
        }
    
        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Multiplica esta matrix por um vetor
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB_param
     * @returns {Vectorization.Matrix} 
     */
    context.multiplicarVetor = function(vectorB_param){
        let matrixA = context.content;
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let matrixResultado = [];

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( matrixA[i][j] * vectorB[j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Faz a transposta da matrix
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/matriz-transposta
     *
     * @returns {Vectorization.Matrix}
    */
    context.transposta = function(){
        let novaMatrix = [];

        for( let j = 0 ; j < context.content[0].length ; j++ ){
            novaMatrix[j] = [];

            for( let i = 0 ; i < context.content.length ; i++ ){
                novaMatrix[j].push( context.content[i][j] );
            }
        }

        const extraProps = {
            isTransposta: !context.isTransposta ? true : false
        }

        return Vectorization.Matrix(novaMatrix, extraProps);
    }

    /**
     * Obtem a matrix oposta
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/matriz-oposta/codigo-principal.js
     * @returns {Vectorization.Matrix}
     */
    context.matrixOposta = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] * -1;
            }
        }

        const extraProps = {
            isOposta: !context.isOposta ? true : false
        }
    
        return Vectorization.Matrix(novaMatrix, extraProps);
    }

    /**
     * Obtem a matrix absoluta
     * 
     * @returns {Vectorization.Matrix}
     */
    context.abs = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.abs(matrixA[i][j]);
            }
        }

        const extraProps = {
            isOposta: !context.isOposta ? true : false
        }
    
        return Vectorization.Matrix(novaMatrix, extraProps);
    }

    context.modulo = function(){
        return context.abs();
    }

    context.absoluto = function(){
        return context.abs();
    }

    /**
     * Obtem a raiz quadrada, de cada elemento da matrix 
     * @returns {Vectorization.Matrix}
     */
    context.sqrt = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.sqrt(matrixA[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Obtem o log2, de cada elemento da matrix 
     * @returns {Vectorization.Matrix}
     */
    context.log2 = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.log2(matrixA[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Tenta obter a matrix de identidade de ordem desta matrix 
    */
    context.identidade = function(){
        if( context.rows != context.columns ){
            throw 'A matrix precisa ser quadrada de ordem X'
        }
        
        return window.Vectorization.matrixIdentidade( context.rows );
    }

    /**
     * Soma esta matrix com outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.somarMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E nÃ£o um ' + String(matrixB_param.objectName);
        }

        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] + matrixB[i][j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Soma esta matrix com um nÃºmero
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-matrizes-por-um-numero-scalar/codigo-principal.js
    * @param {Number} numero
    * @returns {Vectorization.Matrix}
    */
    context.somarNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] + numero;
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Soma esta matrix com um vetor
     * 
     * @param {Vectorization.Matrix} vectorB_param 
     * @returns {Vectorization.Matrix}
    */
    context.somarVetor = function(vectorB_param){
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;

        if( vectorB.objectName != undefined && vectorB.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E nÃ£o um ' + String(vectorB.objectName);
        }
        
        let matrixA = context.content;

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        //let matrixB = (vectorB.objectName != undefined && vectorB.objectName == 'Vector') ? vectorB.content : vectorB;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] + vectorB[j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Subtrai esta matrix com outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.subtrairMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E nÃ£o um ' + String(matrixB_param.objectName);
        }

        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] - matrixB[i][j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Subtrai esta matrix com um nÃºmero
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-matrizes-por-um-numero-scalar/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix} 
    */
    context.subtrairNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] - numero;
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Subtrai esta matrix com um vetor
     * 
     * @param {Vectorization.Matrix} vectorB_param 
     * @returns {Vectorization.Matrix}
    */
    context.subtrairVetor = function(vectorB_param){
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;

        if( vectorB.objectName != undefined && vectorB.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E nÃ£o um ' + String(vectorB.objectName);
        }
        
        let matrixA = context.content;

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        //let matrixB = (vectorB.objectName != undefined && vectorB.objectName == 'Vector') ? vectorB.content : vectorB;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] - vectorB[j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Divide esta matrix com outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.dividirMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E nÃ£o um ' + String(matrixB_param.objectName);
        }
        
        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] / matrixB[i][j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Divide esta matrix por um nÃºmero
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero 
     * @returns {Vectorization.Matrix}
     */
    context.dividirNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];
        
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] / numero;
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Divide esta matrix por um vetor, aplicando o vetor a cada linha desta matrix 
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Matrix}
    */
    context.dividirVetor = function(vectorB_param){
        let matrixA = context.content;
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novaMatrix = [];

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser igual a quantidade de colunas da matrix!'
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] / vectorB[j];
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Eleva esta matrix a um nÃºmero
    * 
    * @param {Number} numero
    * @returns {Vectorization.Matrix}
    */
    context.elevarNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.pow(matrixA[i][j], numero);
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Eleva esta matrix a um vetor
     * 
     * @param {Vectorization.Vector} vectorB_param
     * @returns {Vectorization.Matrix} 
     */
    context.elevarVetor = function(vectorB_param){
        let matrixA = context.content;
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let matrixResultado = [];

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( Math.pow(matrixA[i][j], vectorB[j]) );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Eleva esta matrix a outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.elevarMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E nÃ£o um ' + String(matrixB_param.objectName);
        }
        
        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.pow(matrixA[i][j], matrixB[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Pega todos os elementos que estÃ£o dentro desta Vectorization.Matrix,
    * e deixa todos eles num unico Vectorization.Vector, desprezando as dimensÃµes, e deste modo: concentrando tudo em um unico Vectorization.Vector. 
    * @returns {Vectorization.Vector}
    */
    context.planificar = function(){
        let novoVetorASerRetornado = Vectorization.Vector([]);
        Vectorization.Matrix(context.duplicar())
        .paraCadaLinha(
            function(iLinha, vetorDaLinha){
                const vetorDaLinha_Vector = Vectorization.Vector.isVectorizationVector(vetorDaLinha) ? vetorDaLinha : Vectorization.Vector(vetorDaLinha);
                novoVetorASerRetornado.acrescentarVetor( Vectorization.Vector( vetorDaLinha_Vector ).duplicar() );
            }); 

        return Vectorization.Vector(novoVetorASerRetornado);
    }

    /**
    * DIFERENTE DO context.extrairValoresColuna
    * Esse mÃ©todo extrai os valores de uma ou mais colunas,
    * NOTA: Isso vai retornar um Vectorization.Vector para cada coluna
    * e nÃ£o recortar colunas da Vectorization.Matrix, entÃ£o o resultado nÃ£o serÃ¡ um Vectorization.Matrix
    * o resultado serÃ¡ um Vectorization.Vector, conteundo outros Vectorization.Vector(as colunas)
    * @param {Vectorization.Vector || Array} listaColunas - um Vectorization.Vector de indices(numeros inteiros)
    * @returns {Vectorization.Vector}
    */
    context.extrairValoresColunas = function( listaColunas='todasColunas' ){
        let listaColunas_Vector = listaColunas != 'todasColunas' ?
                                  Vectorization.Vector.isVectorizationVector(listaColunas) == false ? Vectorization.Vector(listaColunas) : listaColunas : 'todasColunas';
    
        let colunasExtraida = Vectorization.Vector([], {usarEscalares: false});

        if( listaColunas == 'todasColunas' ){
           //Para cada coluna
           Vectorization.Vector({
              valorPreencher: 1,
              //Vai criar uma iteraÃ§Ã£o em cada coluna
              elementos: matrix1.columns

           }).paraCadaElemento(function(j, numeroColuna){
               let valoresExtraidosColunaAtual = context.extrairValoresColuna(numeroColuna);
               colunasExtraida.adicionarElemento( valoresExtraidosColunaAtual );
           });

        }else{
           //Para cada coluna a ser extraida
           listaColunas_Vector.paraCadaElemento(function(j, numeroColuna){
               let valoresExtraidosColunaAtual = context.extrairValoresColuna(numeroColuna);
               colunasExtraida.adicionarElemento( valoresExtraidosColunaAtual );
           });
        }

        return colunasExtraida;
    }

    /**
    * DIFERENTE DO context.extrairValoresColuna
    * SIMILAR ao context.extrairValoresColunas
    * 
    * Esse mÃ©todo extrai os valores de todas as colunas EXCETO UMA,
    * NOTA: Isso vai retornar um Vectorization.Vector para cada coluna
    * e nÃ£o recortar colunas da Vectorization.Matrix, entÃ£o o resultado nÃ£o serÃ¡ um Vectorization.Matrix
    * o resultado serÃ¡ um Vectorization.Vector, conteundo outros Vectorization.Vector(as colunas)
    * @param {Vectorization.Vector || Array} listaColunas - um Vectorization.Vector de indices(numeros inteiros)
    * @returns {Vectorization.Vector}
    */
    context.extrairValoresColunasExceto = function(numeroColunaIgnorar){
        let colunasExtraida = Vectorization.Vector([], {usarEscalares: false});

        //Para cada coluna
        Vectorization.Vector({
            valorPreencher: 1,
            //Vai criar uma iteraÃ§Ã£o em cada coluna
            elementos: matrix1.columns

        }).paraCadaElemento(function(j, numeroColuna){
            if( j != numeroColunaIgnorar )
            {
                let valoresExtraidosColunaAtual = context.extrairValoresColuna(j);
                colunasExtraida.adicionarElemento( valoresExtraidosColunaAtual );
            
            }else{
                //Faz nada, IGNORA
            }
        });

        return colunasExtraida;
    }

    /**
     * Faz o onehot em uma coluna especifica
     * retorna um Vectorization.Vector, contendo outros Vectorization.Vector(coluna) contendo valores booleanos,
     * para cada valor unico na coluna especifica ele vai percorrer cada valor existente na coluna especifica(numeroColuna), e verificar se o item atual da coluna da matrix Ã© igual a esse valor unico atual
     * se sim, entÃ£o vai colocar 1, caso contrario vai colocar 0
     * 
     * NOTA: Isso sÃ³ faz o onehot para uma unica coluna especifica
     * e retorna um Vectorization.Vector para cada valor unico da coluna especifica a ser codificada
     * 
     * @param {Number} numeroColuna 
     * @param {Vectorization.Vector} dadosColunaAtual 
     * @returns {Vectorization.Vector}
     */
    context.aplicarCodificacaoONEHOT = function(numeroColuna, dadosColunaAtual){
        const valoresUnicosColunaAtual = dadosColunaAtual.valoresUnicos();

        //Cria as colunas que serÃ£o usadas
        const novasColunas_COLUNA_ATUAL = Vectorization.Vector({
            valorPreencher: Vectorization.Vector([], {usarEscalares: false}),
            elementos: valoresUnicosColunaAtual.elementos
        }, {
            usarEscalares: false
        });

        //Percorre essa numeroColuna coluna da matrix
        context.paraCadaLinha(function(ii){
            let dadosLinha = context.getLinha(ii);
            let dadosLinhaNACOLUNA = dadosLinha.lerIndice(numeroColuna);

            for( let jj = 0 ; jj < valoresUnicosColunaAtual.elementos ; jj++ )
            {
                const valorUnico = valoresUnicosColunaAtual.lerIndice(jj);
                const isIgual = dadosLinhaNACOLUNA.raw() == valorUnico;

                if( isIgual == true ){
                    novasColunas_COLUNA_ATUAL.lerIndice(jj)
                                             .adicionarElemento(1);

                }else{
                    novasColunas_COLUNA_ATUAL.lerIndice(jj)
                                             .adicionarElemento(0);
                }
            }
        });

        return novasColunas_COLUNA_ATUAL;
    }

    /**
    * Faz o onehot nas colunas definidas
    * @param {Number} numeroColunasQuero
    * @returns {Object} - objeto onde voce pode obter Vectorization.Vector(s) ou uma Vectorization.Matrix com os valores inclusos
    */
    context.oneHotColunas = function(numeroColunasQuero){
        const colunas_Vetor = context.extrairValoresColunas(numeroColunasQuero);

        /*
        * Vai fazer a codificaÃ§Ã£o de cada coluna passada em numeroColunasQuero, 
        * E armazenar aqui no resultadoOperacao
        */
        const resultadoOperacao = Vectorization.Vector([], {usarEscalares: false});
        const resultadoMatrix = context.duplicar();

        //Para cada coluna que quero aplicar
        colunas_Vetor.paraCadaElemento(function(i){
            
            //Obtenho os dados da coluna
            const dadosColunaAtual = colunas_Vetor.lerIndice(i);
            const dadosCodificadosColunaAtual = context.aplicarCodificacaoONEHOT( i , dadosColunaAtual );
        
            resultadoOperacao.adicionarElemento(dadosCodificadosColunaAtual);

            //Vai jogando tudo isso dentro da Vectorization.Matrix copiada
            dadosCodificadosColunaAtual.paraCadaElemento(function(jColuna, elementoColuna){
                if( 
                    Vectorization.Vector.isVector( elementoColuna ) == true || 
                    Vectorization.BendableVector.isBendableVector( elementoColuna ) == true 
                ){
                    resultadoMatrix.adicionarColuna(elementoColuna);
                }
            });
        });

        return {
            resultado_vector: resultadoOperacao,
            matrix_incluida: resultadoMatrix,

            raw: function(){
                return resultadoOperacao.raw();
            },

            obterMatrix: function(){
                return this.matrix_incluida;
            },

            obterVector: function(){
                return this.resultado_vector;
            }
        };
    }

    context._doDefaultBaseAfterCreate();

    //Se a opÃ§Ã£o advanced estiver ativa, ele roda um mÃ©todo adicional apÃ³s criar a matrix
    if( context.isAdvancedMatrix == true ){
        context._matrix2Advanced();
    }

    //Se existir uma traduÃ§Ã£o para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //Aplica arredondamentos, se o usuario desejar, mesmo nÃ£o sendo um Vectorization.Matrix aleatoria
    if( context._config != undefined &&
        (
            context._config['aleatorio'] == undefined || context._config['aleatorio'] == false
        ) == true && 
        (
            context._config['arredondar'] != undefined ||
            context.configRecebidaUsuario['arredondar'] != undefined
        ) == true
    ){
        context.aplicarArredondamento(context._config['arredondar'] || context.configRecebidaUsuario['arredondar']);
    }

    //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
    context.bloqueado = (config['bloqueado'] != undefined || classConfig['bloqueado'] != undefined) ? (config['bloqueado'] || classConfig['bloqueado']) : false;

    //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Vector
    if( context._isBloqueado() == true ){
        context.bloquearModificacoes();
    }

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //return context;
    //Cria um Proxy para permitir acessar os indices da matrix diretamente
    return new Proxy(context, {
        get: function(target, prop, receiver) {
          if (typeof prop === 'string' && !isNaN(prop)) {
            return target.content[Number(prop)];
          }
          return Reflect.get(target, prop, receiver);
        },

        set: function(target, prop, value) {
          //Consulta se a gravaÃ§Ã£o/modificaÃ§Ã£o de dados estÃ¡ bloqueada neste Vectorization.Matrix
          if( target._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix estÃ¡ bloqueado para novas gravaÃ§Ãµes!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
            throw 'VocÃª nÃ£o pode modificar esta atributo do Vectorization.Matrix!';
          }

          if (typeof prop === 'string' && !isNaN(prop)) {
            target.content[Number(prop)] = value;
            return true;
          }
          return Reflect.set(target, prop, value);
        }
    });
}

/**
* MÃ©todos estÃ¡ticos
*/
window.Vectorization.Matrix.isMatrix = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Matrix');
}

window.Vectorization.Matrix.isVectorizationMatrix = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Matrix');
}

module.exports = window.Vectorization.Matrix;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Matrix.js*/
/* ARQUIVO VECTORIZATION: ../src/Matrix-translation.js*/
/*
 * File Name: Matrix-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Matrix._translations = function(){
    const translatedMethods = {
        //English
        "deepLevel": "nivelProfundidade",
        "getDeepLevel": "nivelProfundidade",

        "dotProduct": "produtoEscalar",

        "dotProductMatrix": "produtoEscalarMatrix",

        "dotProductVector": "produtoEscalarVector",

        "multiplyMatrix": "multiplicarMatrix",

        "multiplyNumber": "multiplicarNumero",

        "multiplyVector": "multiplicarVetor",

        "addMatrix": "somarMatrix",

        "addNumber": "somarNumero",

        "addVector": "somarVetor",

        "subtractMatrix": "subtrairMatrix",

        "subtractNumber": "subtrairNumero",

        "subtractVector": "subtrairVetor",

        "divideMatrix": "dividirMatrix",

        "divideNumber": "dividirNumero",

        "divideVector": "dividirVetor",

        "powMatrix": "elevarMatrix",

        "powNumber": "elevarNumero",

        "powVector": "elevarVetor",

        "transposed": "tranposta",

        "oppostMatrix": "matrixOposta",

        "identity": "identidade",

        "extractColumnValues": "extrairValoresColuna",
        "extractColumnsValues": "extrairValoresColunas",
        "extractColumnsValuesExcept": "extrairValoresColunasExceto",

        "extractLineValues": "extrairValoresLinha",

        "blockModifications": "bloquearModificacoes",
        "unblockModifications": "desbloquearModificacoes",

        "planify": "planificar",

        "oneHotColumns": "oneHotColunas",
        "sliceLines": "slice",
        "sliceColumns": "sliceColunas",
        "sliceRegion": "recortarRegiao",

        //Portugues
        "obterTransposta": "transposta",
        "somarMatriz": "somarMatrix",
        "subtrairMatriz": "subtrairMatrix",
        "multiplicarMatriz": "multiplicarMatrix",
        "elevarMatriz": "elevarMatrix",
        "produtoEscalarMatriz": "produtoEscalarMatrix",
        "addColuna": "adicionarColuna",
        "preencherLinha": "zerarLinha",
        "preencherColuna": "zerarColuna",
        "preencherColunaOnde": "zerarColunaOnde",
        "paraCadaLinha": "forEach",
        "percorrerElementosColuna": "percorrerColuna",
        "mapearElementosColuna": "mapearColuna",
        "bloquear": "bloquearModificacoes",
        "desbloquear": "desbloquearModificacoes"
    };

    const translatedAttributes = {
        //Portugues
        "valorPreencher": "fillValue",
        "preencherValor": "fillValue",
        "matrizAvancada": "isAdvancedMatrix",
        "matrixAvancada": "isAdvancedMatrix",
        "linhas": "rows",
        "colunas": "columns",

        //English
        //Ingles
        "blocked": "bloqueado",
        "allowBlock": "permitirBloquear",
        "allowUnblock": "permitirDesbloquear",
        "deepMatrix": "matrixProfunda"
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Matrix._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Matrix-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/StringMatrix.js*/
/*
 * File Name: StringMatrix.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    require('./Root'); 
    require('./Scalar');
    require('./Vector');
    require('./StringVector');
    require('./Matrix');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringMatrix = function( config=[], classConfig={} ){
    //Define a traduÃ§Ã£o
    classConfig['translations'] = window.Vectorization.StringMatrix._translations || null;
    classConfig['advanced'] = false;
    classConfig['usarTexto'] = true;

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.StringMatrix.isStringMatrix(config) && config.objectName == 'StringMatrix' ){
        return Vectorization.StringMatrix( config.values() );
    }

    //O StringMatrix serÃ¡ baseado no Vectorization.Matrix
    let context = window.Vectorization.Matrix(config, classConfig);
    context.objectName = 'StringMatrix';
    context.extendedFrom = 'Matrix';
    context.path = 'Vectorization.StringMatrix';
    context.configRecebidaUsuario = config;

    /**
    * @override
    * MÃ©todo que converte a matrix para uma matrix avanÃ§ada, onde cada linha Ã© um Vector 
    */
    context._matrix2Advanced = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            extraPropsOfLine['index'] = i;
            extraPropsOfLine['usarTexto'] = true;

            context.content[i] = Vectorization.StringVector(context.content[i], extraPropsOfLine);
        }
        context.isAdvancedMatrix = true;
    }

    context._matrix2Advanced();

    //Se existir uma traduÃ§Ã£o para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    return context;
}

window.Vectorization.StringMatrix.isStringMatrix = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'StringMatrix' )
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringMatrix.js*/
/* ARQUIVO VECTORIZATION: ../src/StringMatrix-translation.js*/
/*
 * File Name: StringMatrix-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringMatrix._translations = function(){
    const translatedMethods = {
       
    };

    const translatedAttributes = {
       
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.StringMatrix._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringMatrix-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Random.js*/
/*
 * File Name: Random.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    
    require('./Root'); 

    if( window.Vectorization.Scalar == undefined ){
        require('./Scalar');
    }

    if( window.Vectorization.Vector == undefined ){
        require('./Vector');
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

//Classe que possui mÃ©todos para gerar nÃºmeros aleatÃ³rios do Vectorization
window.Vectorization.Random = function( classConfig={} ){
    let context = {... classConfig};
    context.value = value;
    context.objectName = 'Random';
    context.path = 'Vectorization.Random';
    return context;
}

/**
* MÃ©todos estÃ¡ticos
*/
window.Vectorization.Random._sementes = [
    //Passos por semente
    {
        sequencia: [2, -5, 8, 0.5, 3, 4.8, 1, 0.00001, 12, 2, 3, 7, 9, 15, 25, 0.8, 1, 0,5],
        multiplicador: 0.5
    },
    {
        sequencia: [5.555555555555555, -13.88888888888889, 22.22222222222222, 1.3888888888888888, 8.333333333333334, 13.333333333333332, 2.7777777777777777, 0.00002777777777777778, 33.333333333333336, 5.555555555555555, 8.333333333333334, 19.444444444444443, 25, 41.666666666666664, 69.44444444444444, 2.2222222222222223, 2.7777777777777777, 0.152, 13.88888888888889],
        multiplicador: 1.5
    },
    {
        sequencia: [0.75, -1.875, 3, 0.1875, 1.1250000000000002, 1.8000000000000003, 0.375, 0.00000375, 4.500000000000001, 0.75, 1.1250000000000002, 2.625, 3.375, 5.625, 9.375, 0.30000000000000004, 0.375, 0, 1.875],
        multiplicador: 4.5
    },
    {
        sequencia: [-1.0666666666666667, 2.6666666666666665, -4.266666666666667, -0.26666666666666666, -1.5999999999999999, -2.56, -0.5333333333333333, -0.000005333333333333334, -6.3999999999999995, -1.0666666666666667, -1.5999999999999999, -3.7333333333333334, -4.8, -8, -13.333333333333334, -0.42666666666666664, -0.5333333333333333, -0.25, -2.6666666666666665],
        multiplicador: 8
    }
]

//Inicializa a vezesJaUsouAteAgora de todas elas, pra nao repetir os mesmos numeros
for( let i = 0 ; i < window.Vectorization.Random._sementes.length ; i++ ){
    const sequenciaAtual = window.Vectorization.Random._sementes[i];
    sequenciaAtual.vezesJaUsouAteAgora = 0;
    sequenciaAtual.indiceAtual = 0;
}

window.Vectorization.Random._numeroSementePadraoDefinida = 5;

//Extrai os dados da semente definida pelo Ãºsuario
window.Vectorization.Random._get_dados_semente = function(numeroDaSemente){
    let iSemente = 0;
    let sementeAtual = {... window.Vectorization.Random._sementes[0]};
    let iContadorIteracao = 0;

    while( iContadorIteracao <= Number.parseInt(numeroDaSemente) )
    {
        if(iSemente > window.Vectorization.Random._sementes.length - 1){
            sementeAtual = {... window.Vectorization.Random._sementes[0]};
            iSemente = 0;
        }

        sementeAtual = {... window.Vectorization.Random._sementes[iSemente]};
        iSemente++;

        iContadorIteracao++;
    }

    if(sementeAtual){
        return sementeAtual;

    }else{
        throw 'Erro ao tentar obter os dados da semente!. Tente outra.'
    }
}

window.Vectorization.Random._sementeDefinida = window.Vectorization.Random._get_dados_semente( window.Vectorization.Random._numeroSementePadraoDefinida );

window.Vectorization.Random.definirSemente = function(numeroDaSemente){
    switch(typeof numeroDaSemente){
        case 'number':
            window.Vectorization.Random._sementeDefinida = window.Vectorization.Random._get_dados_semente(numeroDaSemente);
            window.Vectorization.Random._numeroSementeDefinida = numeroDaSemente;
            break;

        //Se for um objeto do Vectorization
        case 'object':
        case 'function':
            if( numeroDaSemente.sequencia != undefined &&
                numeroDaSemente.multiplicador != undefined &&
                numeroDaSemente.sequencia.length > 2 &&
                numeroDaSemente.vezesJaUsouAteAgora != undefined
            ){
                window.Vectorization.Random._sementeDefinida = window.Vectorization.Random._get_dados_semente(numeroDaSemente);
            }
            break;

    }
}

/**
* @param {Object} sementeAtual 
* @returns {Number}
*/
window.Vectorization.Random.proximoNumeroDaSequenciaSemente = function(sementeAtual){
    let sequenciaVector = Vectorization.Vector(sementeAtual.sequencia);
    if( sementeAtual.indiceAtual > sequenciaVector.length-1 ){
        sementeAtual.indiceAtual = 0;
    }

    let meuNumeroTal = sequenciaVector.readIndex(sementeAtual.indiceAtual);
    sementeAtual.indiceAtual++;
    sementeAtual.vezesJaUsouAteAgora++;

    //Vai variando os valores
    let operacaoAAplicar = sementeAtual.indiceAtual % 2 == 0 ? '+' : '-';

    if( sementeAtual.indiceAtual < sequenciaVector.length ){
        if( sementeAtual.numeroAnterior != undefined && typeof sementeAtual.numeroAnterior == 'number' ){
            switch(operacaoAAplicar){
                case '+':
                    sementeAtual.sequencia[sementeAtual.indiceAtual] += ( (1/100 * sementeAtual.numeroAnterior) );
                    break;
                case '-':
                    sementeAtual.sequencia[sementeAtual.indiceAtual] -= ( (1/100 * sementeAtual.numeroAnterior) );
                    break;
            }
        }
    }

    let numeroGeradoDeAgora = ( (meuNumeroTal * sementeAtual.multiplicador) / (sementeAtual.vezesJaUsouAteAgora < 100 ? sementeAtual.vezesJaUsouAteAgora+10 : sementeAtual.vezesJaUsouAteAgora) ) * meuNumeroTal * sementeAtual.multiplicador;
    sementeAtual.numeroAnterior = numeroGeradoDeAgora;
    return numeroGeradoDeAgora;
}

/**
 * Permite gerar um nÃºmero aleatorio entre um nÃºmero inicial e final
 * Isso respeita o template definido, fazendo com que os nÃºmeros gerado sejam sempre os mesmos
 * 
 * @param {Number} minimo 
 * @param {Number} maximo 
 * @param {Number} sementeDefinida 
 * @returns {Number}
 */
window.Vectorization.Random.gerarNumeroAleatorio = function(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida){
    //Verificar a semente
    let sementeAleatoria = null;
    if( sementeDefinida != undefined && typeof sementeDefinida == 'number' ){
        sementeAleatoria = window.Vectorization.Random._get_dados_semente(sementeDefinida);
    }else{
        sementeAleatoria = sementeDefinida;
    }

    //Gerar o valor
    let sequenciaVector = Vectorization.Vector(sementeAleatoria.sequencia);
    let base = sequenciaVector.media() + (Math.PI * sequenciaVector.media()/2);
    let meuNumeroQualquer = (base + (maximo / (minimo+1.2) ) * (25/100 * base)) + minimo;

    //Isso obriga o nÃºmero a ser menor que o limite(valor mÃ¡ximo que definimos)
    let maxTentativas = 500;
    let quantidadeTentativas = 0;
    while( meuNumeroQualquer > maximo ){
        if( quantidadeTentativas > maxTentativas ){
            break;
        }

        meuNumeroQualquer = window.Vectorization.Random.proximoNumeroDaSequenciaSemente(sementeAleatoria);
        quantidadeTentativas++;
    }

    if( quantidadeTentativas > maxTentativas ){
        meuNumeroQualquer = meuNumeroQualquer - maximo;

        if( meuNumeroQualquer < minimo ){
            meuNumeroQualquer += (minimo/2.5) * (2/100 * base);
        }
    }

    meuNumeroQualquer += minimo;

    return meuNumeroQualquer;
}

/**
 * Permite gerar um nÃºmero aleatorio entre um nÃºmero inicial e final
 * Isso respeita o template definido, fazendo com que os nÃºmeros gerado sejam sempre os mesmos
 * 
 * @param {Number} minimo 
 * @param {Number} maximo 
 * @param {Number} sementeDefinida 
 * @returns {Number}
 */
window.Vectorization.Random.gerarNumeroInteiroAleatorio = function(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida){
    let numeroAleatorioAtual = window.Vectorization.Random.gerarNumeroAleatorio(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida);
    return Number.parseInt(numeroAleatorioAtual);
}

/**
 * Permite gerar um nÃºmero aleatorio entre um nÃºmero inicial e final
 * Isso respeita o template definido, fazendo com que os nÃºmeros gerado sejam sempre os mesmos
 * 
 * @param {Number} minimo 
 * @param {Number} maximo 
 * @param {Number} sementeDefinida 
 * @returns {Number}
 */
window.Vectorization.Random.gerarNumeroFloatAleatorio = function(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida){
    let numeroAleatorioAtual = window.Vectorization.Random.gerarNumeroAleatorio(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida);
    return Number.parseFloat(numeroAleatorioAtual);
}


//Cria uma cÃ³pia segura das sementes como elas estavam antes de serem manipuladas/utilizadas pelo usuario
window.Vectorization.Random._sementesIniciais = Vectorization.Vector([... window.Vectorization.Random._sementes.copyWithin()]).duplicar();
window.Vectorization.Random._sementeDefinidaInicial = {... window.Vectorization.Random._sementeDefinida};

window.Vectorization.Random.resetarEstadoInicial = function(){
    window.Vectorization.Random._sementes = window.Vectorization.Random._sementesIniciais.duplicar().valores();
    window.Vectorization.Random.definirSemente( window.Vectorization.Random._numeroSementePadraoDefinida );
    window.Vectorization.Random._sementeDefinida = {... window.Vectorization.Random._sementeDefinidaInicial};
    console.warn('sementes aleatÃ³rias redefinidas!')
}


module.exports = window.Vectorization.Random;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Random.js*/
/* ARQUIVO VECTORIZATION: ../src/Random-translation.js*/
/*
 * File Name: Random-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Random._translations = function(){
    const translatedMethods = {
        //English
        'generateRandomNumericalValue': 'gerarNumeroAleatorio',
        'generateRandomFloatNumericalValue': 'gerarNumeroFloatAleatorio',
        'generateRandomIntegerNumericalValue': 'gerarNumeroInteiroAleatorio',
        'especifyOriginalInitialPoint': 'definirSemente'
    };

    const translatedAttributes = {
        
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

let randomClasseBase = window.Vectorization.Base(window.Vectorization.Random);

//Aplica a traduÃ§Ã£o dos mÃ©todos, pra ser capaz de entender nomes de atributos em outros idiomas
randomClassConfig = randomClasseBase.translateAttributes_andReturn(window.Vectorization.Random, window.Vectorization.Random._translations() );

//Se existir uma traduÃ§Ã£o para a classe
if(window.Vectorization.Random._translations && typeof window.Vectorization.Random._translations === 'function'){
    randomClasseBase.applyTranslations( window.Vectorization.Random._translations() );
}

//Passando as configuraÃ§Ãµes pra dentro da classe Vectorization.Random
let todasConfiguracoesClassConfig = randomClasseBase.getTodasConfiguracoesAplicadas();
let keysConfiguracoesClassConfig = [... Object.keys(randomClasseBase)];

for( let i = 0 ; i < todasConfiguracoesClassConfig.quantidadeDentro ; i++ )
{   
    let nomeConfiguracaoClassConfig = keysConfiguracoesClassConfig[i],
        valorConfiguracaoClassConfig = todasConfiguracoesClassConfig.configuracoesUsadas[nomeConfiguracaoClassConfig];

    if( window.Vectorization.Random[ nomeConfiguracaoClassConfig ] == undefined )
    {
        window.Vectorization.Random[ nomeConfiguracaoClassConfig ] = valorConfiguracaoClassConfig;
    }
}

module.exports = window.Vectorization.Random._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Random-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Vectorization.js*/
/*
 * File Name: Vectorization.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: WilliamJardim/Vectorization Â© 2024 by William Alves Jardim is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/**
*/

var Vectorization_4Node = class{
    constructor(){
        if( typeof window !== 'undefined' && window.isbrowser == true ){
            throw 'This class only works in Node';
        }

        //Se for node
        if( window.isbrowser == false && window.iscompilation == false )
        {
            //Importando classe raiz
            this.Root = require('./Root');

            this.Utilidades = require('./Utilidades');

            //Importando numeros escalares
            this.Scalar = require('./Scalar');
            this.Scalar_translation = require('./Scalar-translation');

            //Importando Text
            this.Scalar = require('./Text');
            this.Scalar_translation = require('./Text-translation');

            //Importando Vetores
            this.Vector = require('./Vector');
            this.Vector_translation = require('./Vector-translation');

            //Importando Vetores de String
            this.StringVector = require('./StringVector');
            this.StringVector_translation = require('./StringVector-translation');

            this.Random = require('./Random');
            this.Random_translation = require('./Random-translation');

            //Importando Matrizes
            this.Matrix = require('./Matrix');
            this.Matrix_translation = require('./Matrix-translation');
            
            this.StringMatrix = require('./StringMatrix');
            this.StringMatrix_translation = require('./StringMatrix-translation');
        }

        return window.Vectorization;
    }
}; 

module.exports = new Vectorization_4Node();
/* FIM DO ARQUIVO VECTORIZATION: ../src/Vectorization.js*/

window.isbrowser = true;

window.iscompilation = true
window.isbrowser = false;

module.exports = new Vectorization_4Node();