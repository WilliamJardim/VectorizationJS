
/*
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/
if(typeof window === 'undefined'){
    global.VECTORIZATION_BUILD = true;
    global.VECTORIZATION_BUILD_TYPE = 'node';
}else{
    window.VECTORIZATION_BUILD = true;
    window.VECTORIZATION_BUILD_TYPE = 'navegador';
}

/* COMPILADO: 1/2/2025 - 21:20:30*//* ARQUIVO VECTORIZATION: ../src/Root.js*/
/*
 * File Name: Root.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }

    globalThis.require = function(){};
}

if(!window.Vectorization){ window.Vectorization = {} };

/**
 * Base class for all other components.
 * @param {Object} config;
 * @returns {Vectorization.Base}
 */
window.Vectorization.Base = function(config){
    const context = {};
    context._config = config;
    context.objectName = 'Base';
    context.extendedFrom = 'Base';
    context.namespace = 'window.Vectorization';
    context.path = 'Vectorization.Base';
    context.autoGeneratedGetters = [];
    context.autoGeneratedSetters = [];
    context._translations = config.translations;
    context._pai = null;

    /**
    * Obtém o objeto pai deste objeto
    * Se existir 
    */
    context.getPai = function(){
        return context._pai;
    }

    /**
    * Obtém o objeto pai deste objeto
    * Se existir 
    */
    context.getFather = context.getPai;

    /**
    * Verifica se o valor deste objeto está presente em um Vectorization.Vector ou Vectorization.Matrix
    */
    context.in = function( objetoVerificar ){
        //Se este objeto for um Vector ou Matrix
        if( Vectorization.Matrix.isVectorizationMatrix( context ) == true ||
            Vectorization.Vector.isVectorizationVector( context ) == true 
        ){
            throw 'Ainda não implementado para verificar se Vetores e Matrizes estão presentes em outros Vetores e Matrizes!';
            
            //Se 'objetoVerificar' for um Vector ou Matrix
            if( Vectorization.Matrix.isVectorizationMatrix( objetoVerificar ) ||
                Vectorization.Vector.isVectorizationVector( objetoVerificar )
            ){
                
            }else{

            }

        //Se o este objeto for um Scalar ou Text
        }else{
            if( context.getTipo && 
                (context.getTipo() == 'Scalar' || context.getTipo() == 'Text')
            ){
                //Se 'objetoVerificar' for um Vector ou Matrix
                if( Vectorization.Matrix.isVectorizationMatrix( objetoVerificar ) == true ||
                    Vectorization.Vector.isVectorizationVector( objetoVerificar ) == true
                ){
                    return objetoVerificar.have( context.obterValor() );
                }
            }
        }
    }

    /**
    * Retorna o tipo do objeto
    * @returns {String}
    */
    context.getTipo = function(){
        return context.objectName;
    }

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    context.copyArgs = function(config){
        //Copia os argumentos
        let configKeys = Object.keys(config);
        for( let i = 0 ; i < configKeys.length ; i++){
            context[ configKeys[i] ] = config[ configKeys[i] ];
        }
    }

    context.copyArgsSeNaoExistir = function(config, aplicarBind=true){
        //Copia os argumentos
        let configKeys = Object.keys(config);

        for( let i = 0 ; i < configKeys.length ; i++){

            if( context[ configKeys[i] ] == undefined )
            {
                context[ configKeys[i] ] = config[ configKeys[i] ];
                if(aplicarBind == true && context[ configKeys[i] ].bind != undefined){
                    context[ configKeys[i] ].bind(context);
                }
            }

        }
    }

    context._doDefaultBaseAfterCreate = function(){
        context.createGettersFromOriginalProperties();
        context.createSettersFromOriginalProperties();
    }

    context.createGettersFromOriginalProperties = function(){
        //Getters
        Object.keys( context ).forEach( function(attrib){
            const nameOfGetter = `get${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfGetter] ){
                context[nameOfGetter] = function(){
                    return context[attrib];
                }
                context.autoGeneratedGetters.push(nameOfGetter);
            }
        });
    }

    context.createSettersFromOriginalProperties = function(){
        //Setters
        Object.keys( context ).forEach( function(attrib){
            const nameOfSetter = `set${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfSetter] ){
                context[nameOfSetter] = function(valueToDefine){
                    context[attrib] = valueToDefine; 
                }
                context.autoGeneratedSetters.push(nameOfSetter);
            }
        });
    }

    //Métodos responsavel por fazer as traduções dos métodos
    context.translateMethods = function(translations) {
        let translationsKeys;

        //Traduz os métodos
        translationsKeys = Object.keys(translations.translatedMethods);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedMethods[nomeMetodoTraduzido];

           //Aplica a tradução
           if(typeof context[nomeOriginal] === 'function'){
               context[nomeMetodoTraduzido] = context[nomeOriginal].bind(context);
           }
        }
    }

    //Métodos responsavel por fazer as traduções dos atributos
    context.translateAttributes = function(translations) {
        let translationsKeys;

        //Traduz os atributos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           //Aplica a tradução no atributo
           if(context[nomeOriginal] != undefined && typeof context[nomeOriginal] != 'function' && !context[nomeMetodoTraduzido] ){
              context[nomeMetodoTraduzido] = context[nomeOriginal];
           }
        }
    }

    //Parecido com a função translateAttributes, porém ele faz essa tradução e retorna um objeto com as traduções aplicadas
    //No caso o translationsDicionario pode ser um objeto ja pronto que só precisa ser traduzido
    //Isso vai ser usado na inicialização de algumas classes como Vectorization.Matrix e Vectorization.Vector
    context.translateAttributes_andReturn = function(propioDicionario, translations){
        let translationsKeys;
        let novoObjeto = {... propioDicionario};

        //Traduz os atributos
        translationsKeys = Object.keys(propioDicionario);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           if( nomeOriginal != undefined && !propioDicionario[nomeOriginal] ){
               novoObjeto[nomeOriginal] = propioDicionario[nomeMetodoTraduzido];
           }
        }

        return novoObjeto;
    }

    //Para não ter problemas com atributos desatualizados
    context.atualizarAtributosTraduzidos = function(translations=context._internal_translations){
        let translationsKeys;

        //Pegar os atributos traduzidos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
            const nomeMetodoTraduzido = translationsKeys[i];
            const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

            if( nomeOriginal != undefined && 
                typeof context[nomeMetodoTraduzido] != 'function' && 
                typeof context[nomeOriginal] != 'function' &&
                context[nomeOriginal] != undefined &&
                context[nomeMetodoTraduzido] != undefined
            ){
                context[nomeMetodoTraduzido] = context[nomeOriginal];
            }
        }
    }

    //Start class
    context.copyArgs(config);
    context._doDefaultBaseAfterCreate();

    context.applyTranslations = function(translationFunction=null){
        //Se existir uma tradução para a classe
        if(context._translations && typeof context._translations === 'function'){
            context._internal_translations = translationFunction || context._translations();
            context.translateMethods( context._internal_translations );
            context.translateAttributes( context._internal_translations );
        }
    }

    context.applyTranslations(null);

    context.getTodasConfiguracoesAplicadas = function(){
        let todasConfiguracoesClassConfig = {};
        let keysConfiguracoesClassConfig = [... Object.keys(context)];

        for( let i = 0 ; i < keysConfiguracoesClassConfig.length ; i++ )
        {
            let nomeConfiguracaoClassConfig = keysConfiguracoesClassConfig[i],
                valorConfiguracaoClassConfig = context[nomeConfiguracaoClassConfig];
            
            todasConfiguracoesClassConfig[nomeConfiguracaoClassConfig] = valorConfiguracaoClassConfig;
        }

        return { 
                  configuracoesUsadas: todasConfiguracoesClassConfig,
                  quantidadeDentro: keysConfiguracoesClassConfig.length
               };
    }

    context.herdarFuncoes = function(referenciaObjeto){
        const templateObjetoCriado = referenciaObjeto();
        const contextObjetoCriado = templateObjetoCriado;
        
        //Aplica dentro deste objeto do Vectorization
        context.copyArgsSeNaoExistir(contextObjetoCriado); 
    }

    return context;
}

//Funções a nivel principal

/**
 * Gera uma matrix de identidade
 * @param {Number} ordem 
 * @returns {Vectorization.Matrix}
*/
window.Vectorization.matrixIdentidade = function(ordem){
    const NON_DIAGONAL_VALUE = 0;
    const DIAGONAL_VALUE = 1;
    let matrix = [];

    for( let i = 0 ; i < ordem ; i++ )
    {
        matrix[i] = [];
        for( let j = 0 ; j < ordem ; j++ )
        {
            //NA LINHA ATUAL, Toda vez que o indice do número for igual ao indice da linha, ele faz parte da diagonal principal
            if( j == i ){
                matrix[i][j] = DIAGONAL_VALUE;

            }else{
                matrix[i][j] = NON_DIAGONAL_VALUE;
            }
        }
    }

    const extraProps = {
        isIdentidade: true
    }

    return Vectorization.Matrix(matrix, extraProps);
}

window.Vectorization.identificarTipo = function(obj){
    //Se for um objeto do Vectorization
    if( obj instanceof Object && obj.objectName != undefined ){

        if( Vectorization.Scalar.isScalar( obj ) ){
            return 'Scalar';

        }else if( Vectorization.Text.isText( obj ) ){
            return 'Text';

        }else{
            return undefined;
        }

    }else{
        if( typeof obj == 'number' ){
            return 'Scalar';

        }else if( typeof obj == 'string' ){
            return 'Text';
        }
    }

    return undefined;
}

window.Vectorization.isAlgumValorVectorization = function(obj){
    return window.Vectorization.identificarTipo(obj) != undefined && 
           obj instanceof Object && 
           obj.objectName != undefined;
}

window.Vectorization.isAlgumVetorVectorization = function(obj){
    return window.Vectorization.Vector.isVectorizationVector(obj) ||
           window.Vectorization.StringVector.isVectorizationStringVector(obj) ||
           window.Vectorization.BendableVector.isVectorizationBendableVector(obj);
}

module.exports = window.Vectorization.Root;

//Cria uma namespace para calculos matemáticos basicos
window.Vectorization.Math = {};

window.Vectorization.Math.log = function(base, valor){
    return Math.log(valor) / Math.log(base)
}

window.Vectorization.Math.log2 = function(valor){
    return Math.log2(valor);
}

window.Vectorization.Math.log10 = function(valor){
    return Math.log10(valor);
}

window.Vectorization.Math.sin = function(radians){
    return Math.sin(radians);
}

window.Vectorization.Math.cos = function(radians){
    return Math.cos(radians);
}

window.Vectorization.Math.pow = function(base, exponente){
    return Math.pow(base, exponente);
}

/**
* Calcula a correlação de Pearson entre dois vetores do Vectorization. 
* Valores altos proximos de 1 significa que é uma correlação positiva forte, ou seja, isso significa que quando os valores de X aumentam, os valores de Y tambem aumentam
* Valores altos proximos de -1 significa que é uma correlação negativa forte, ou seja, isso significa que quando os valores de X aumentam, os valores de Y diminuem
*
* @param {Vectorization.Vector} vetor1
* @param {Vectorization.Vector} vetor2
* @returns {Number}
*/
window.Vectorization.Math.correlation = function(vetor1, vetor2) {
    if( !Vectorization.Vector.isVector(vetor1) || !Vectorization.Vector.isVector(vetor2) ){
        throw new Error('Os parametros precisam ser Vectorization.Vector(s)');
    }
    if (vetor1.length !== vetor2.length) {
        throw new Error('Os dois vetores devem ter o mesmo tamanho.');
    }
    if (vetor1.length === 0) {
        throw new Error('Os vetores não podem estar vazios.');
    }

    //Pega a quantidade de elementos, que vai ser a mesma para ambas os vetores
    const qtdeElementos = vetor1.length;

    //Calcula as médias de ambos os vetores
    const mediaX = vetor1.media();
    const mediaY = vetor2.media();

    let numerador = 0;
    let denominadorX = 0;
    let denominadorY = 0;

    for (let i = 0; i < qtdeElementos; i++) {
        const deltaVetor1 = vetor1[i] - mediaX;
        const deltaVetor2 = vetor2[i] - mediaY;

        numerador += deltaVetor1 * deltaVetor2;
        denominadorX += deltaVetor1 ** 2;
        denominadorY += deltaVetor2 ** 2;
    }

    const denominador = Math.sqrt(denominadorX * denominadorY);

    if (denominador === 0) {
        throw new Error('Impossivel ter divisão por zero ao calcular a correlação.');
    }

    return numerador / denominador;
}

//Cria um alias para facilitar a chamada
if( typeof V == 'undefined' ){
    window.V = window.Vectorization;
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/Root.js*/
/* ARQUIVO VECTORIZATION: ../src/Utilidades.js*/
/*
 * File Name: Utils.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Utilidades = {};

window.Vectorization.Utilidades.apenasNumeros = function(stringObj){
    let apenasNumeros = true;
    let tamanhoString = stringObj.length;
    for( let letra = 0 ; letra < tamanhoString ; letra++ )
    {       
        if( !isNaN( Number(stringObj[letra]) ) || stringObj[letra] == '.' ){
            apenasNumeros = true;

        }else{
            apenasNumeros = false;
            break;
        }
    }

    return apenasNumeros;
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/Utilidades.js*/
/* ARQUIVO VECTORIZATION: ../src/Scalar.js*/
/*
 * File Name: Scalar.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 

    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Random'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Scalar = function( value=NaN, classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Scalar._translations || null;

    let classeBaseEscalar = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseEscalar.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( value.objectName != undefined && value.objectName == 'Scalar' ){
        return Vectorization.Scalar( value.raw(), {... classConfig} );
    }

    //let context = {... classConfig};
    let context = window.Vectorization.Base({... classConfig});

    if( value != undefined && 
        !(value instanceof Object) &&
        (typeof value == 'number' || Vectorization.Utilidades.apenasNumeros(value)) == true
    ){
        context.value = Number(value);
        context.configuracoesValue = {};
    
    //Se for um objeto com configurações
    }else if(value instanceof Object){

        //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
        value = classeBaseEscalar.translateAttributes_andReturn(value, classConfig['translations']() );

        //Salva a config
        context.configuracoesValue = {... value};

        if( value.aleatorio == true ){
            if( value.minimo != undefined && value.maximo != undefined ){
                context.aleatorio = true;
                context.ultimoMaximoUsado = value.maximo;
                context.ultimoMinimoUsado = value.minimo;
                context.sementeAleatoria = context.sementeAleatoria || Vectorization.Random._sementeDefinida;

                if( value.sementeAleatoria != undefined ){
                    context.sementeAleatoria = value.sementeAleatoria;

                    if( typeof value.sementeAleatoria == 'number' ){
                        context.numeroSemente = value.sementeAleatoria;
                    }
                }

                context.value = Vectorization.Random.gerarNumeroAleatorio( Number(value.minimo), Number(value.maximo), context.sementeAleatoria );
                if( value.arredondar != undefined ){
                    switch(value.arredondar){
                        case true:
                            context.value = Math.round(context.value);
                            break;

                        case 'cima':
                        case 'up':
                            context.value = Math.ceil(context.value);
                            break;
            
                        case 'baixo':
                        case 'down':
                            context.value = Math.floor(context.value);
                            break;

                        case 'automatico':
                        case 'auto':
                            context.value = Math.round(context.value);
                            break;
                    }
                }

            }else{
                throw 'Para criar um Scalar aleatório voce precisar passar a faixa de valores!';
            }

        }else{
            //Se nao for aleatorio
            if( value.value != undefined ){
                if( typeof value.value == 'string' ){
                    context.value = value.value;
                    
                }else{
                    context.value = Number(value.value);
                }
            }
        }
    }

    context.objectName = 'Scalar';
    context.path = 'Vectorization.Scalar';

    context.storedClassConfig = classConfig || {};

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

        }else{
            throw 'Ação não permitida para este Vectorization.Scalar!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;
        }else{
            throw 'Ação não permitida para este Vectorization.Scalar!';
        }
    }

    context.obterValor = function(){
        return context.value;
    }

    context.setValor = function(valorDefinir){
        context.valor = valorDefinir;
        context.value = valorDefinir;
        context.conteudo = valorDefinir;
    }

    //Troca o número aleatorio dentro desse Vectorization.Scalar
    context.trocarNumeroAleatorio = function(novoMinimo=context.ultimoMinimoUsado, novoMaximo=context.ultimoMaximoUsado, novaSemente=null){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Scalar
        if( context._isBloqueado() == true ){
           throw 'Este Vectorization.Scalar está bloqueado para novas gravações!';
        }

        if( context.aleatorio == true ){

            if( novoMinimo == null ){
                novoMinimo = context.ultimoMinimoUsado;
            }

            if( novoMaximo == null ){
                novoMaximo = context.ultimoMaximoUsado;
            }

            if( novaSemente == null ){
                novaSemente = context.sementeAleatoria;

            }else{
                context.sementeAleatoria = Vectorization.Random._get_dados_semente(novaSemente);
                
                if( typeof novaSemente == 'number' ){
                    context.numeroSemente = novaSemente;
                }
            }

            context.ultimoMaximoUsado = novoMaximo;
            context.ultimoMinimoUsado = novoMinimo;

            context.value = Vectorization.Random.gerarNumeroAleatorio( Number(novoMinimo), Number(novoMaximo), novaSemente );
            if( value.arredondar != undefined ){
                switch(value.arredondar){
                    case true:
                        context.value = Math.round(context.value);
                        break;

                    case 'cima':
                    case 'up':
                        context.value = Math.ceil(context.value);
                        break;
        
                    case 'baixo':
                    case 'down':
                        context.value = Math.floor(context.value);
                        break;

                    case 'automatico':
                    case 'auto':
                        context.value = Math.round(context.value);
                        break;
                }
            }

            return context.value;

        }else{
            throw 'Este objeto não é aleatório!';
        }
    }

    context.valueOf = function(){
        return Number.parseFloat( context.value );
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.Text( context.valueOf(), novasConfiguracoes );
    }

    context.toString = function(){
        return String(context.value);
    }

    context.raw = function(){
        return context.value + 0;
    }

    context.isIgual = function( outraCoisa ){
        if( Vectorization.Scalar.isScalar(outraCoisa) && outraCoisa.objectName != undefined ){
            return context.raw() == outraCoisa.raw();

        }else if( typeof outraCoisa == 'number' ){
            return context.raw() == outraCoisa
        }
    }

    context.somarNumero = function(numero){
        return Vectorization.Scalar(context.value + numero, {... classConfig});
    }

    context.subtrairNumero = function(numero){
        return Vectorization.Scalar(context.value - numero, {... classConfig});
    }

    context.dividirNumero = function(numero){
        return Vectorization.Scalar(context.value / numero, {... classConfig});
    }

    context.multiplicarNumero = function(numero){
        return Vectorization.Scalar(context.value * numero, {... classConfig});
    }

    context.elevarNumero = function(numero){
        return Vectorization.Scalar(Math.pow(context.value, numero), {... classConfig});
    }

    context.aoQuadrado = function(){
        return Vectorization.Scalar(context.elevarNumero(2), {... classConfig});
    }

    context.metade = function(){
        return Vectorization.Scalar(context.dividirNumero(2), {... classConfig});
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (classConfig['bloqueado'] != undefined) ? (classConfig['bloqueado']) : false;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //return context;
    return new Proxy(context, {
        
        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Scalar
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Scalar está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'Você não pode modificar esta atributo do Vectorization.Vector!';
          }

          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Scalar.isScalar = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Scalar') || typeof obj == 'number';
}

window.Vectorization.Scalar.isVectorizationScalar = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Scalar');
}

module.exports = window.Vectorization.Scalar;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Scalar.js*/
/* ARQUIVO VECTORIZATION: ../src/Scalar-translation.js*/
/*
 * File Name: Scalar-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Scalar._translations = function(){
    const translatedMethods = {
        'elevarQuadrado': 'aoQuadrado',
        'elevarAoQuadrado': 'aoQuadrado'
    };

    const translatedAttributes = {
        'valor': 'value',
        'conteudo': 'value'
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Scalar._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Scalar-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Text.js*/
/*
 * File Name: Text.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Scalar'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Text = function( value=NaN, classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Text._translations || null;

    let classeBaseEscalar = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseEscalar.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    if( value.objectName != undefined && value.objectName == 'Text' ){
        return Vectorization.Text( value.raw(), {... classConfig} );
    }

    //let context = {... classConfig};
    let context = window.Vectorization.Base({... classConfig});

    if( value != undefined && 
        !(value instanceof Object) &&
        (typeof value == 'string' || Vectorization.Utilidades.apenasNumeros(value)) == true
    ){

        context.value = String(value);
        context.configuracoesValue = {};
    
    //Se for um objeto com configurações
    }else if(value instanceof Object){

        //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
        value = classeBaseEscalar.translateAttributes_andReturn(value, classConfig['translations']() );

        //Salva a config
        context.configuracoesValue = {... value};

        if( value.value != undefined ){
            if( typeof value.value == 'string' ){
                context.value = value.value;
                
            }else{
                context.value = String(value.value);
            }
        }
    }

    if(context.value == undefined){
        if( Vectorization.Scalar.isScalar(value) == true ){
            context.value = String(value);   
        }
    }

    context.objectName = 'Text';
    context.path = 'Vectorization.Text';

    context.storedClassConfig = classConfig || {};

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

        }else{
            throw 'Ação não permitida para este Vectorization.Scalar!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;
        }else{
            throw 'Ação não permitida para este Vectorization.Scalar!';
        }
    }

    context.obterValor = function(){
        return context.value;
    }

    context.valueOf = function(){
        return String( context.value );
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.Scalar( context.valueOf(), novasConfiguracoes );
    }

    context.toString = function(){
        return String(context.value);
    }

    context.raw = function(){
        return context.value;
    }

    context.isIgual = function( outraCoisa ){
        if( Vectorization.Text.isText(outraCoisa) && outraCoisa.objectName != undefined ){
            return context.raw() == outraCoisa.raw();

        }else if( typeof outraCoisa == 'string' ){
            return context.raw() == outraCoisa
        }
    }

    /**
    * Transforma este Vectorization.Text em um Vectorization.StringVector
    * Transform this Vectorization.Text into a Vectorization.StringVector
    * @returns {Vectorization.StringVector}
    */
    context.toCharacterVector = function(){
        let esteTexto = context;
        return Vectorization.StringVector( esteTexto.obterValor().split('') );
    }
    context.paraVetorCaracteres = context.toCharacterVector;


    context.letrasMaiusculas = function(){
        return Vectorization.Text( String( context.obterValor() ).toUpperCase() );
    }
    context.toUpperCase = context.letrasMaiusculas;


    
    context.letrasMinusculas = function(){
        return Vectorization.Text( String( context.obterValor() ).toLowerCase() );
    }
    context.toLowerCase = context.letrasMinusculas;

    /**
    * Verifica se este Vectorization.Text é igual a outro Vectorization.Text
    * @param {Vectorization.Text} outroTexto 
    * @returns {Boolean}
    */
    context.isIgual = function(outroTexto){
        let outroTexto_Text = Vectorization.Text.isVectorizationText(outroTexto) == false ? Vectorization.Text(outroTexto) : outroTexto;
        return Vectorization.Text.isText(outroTexto) && context.obterValor() === outroTexto_Text.obterValor();
    }

    /**
    * Calcula a distancia hamming deste Vectorization.Text com outro Vectorization.Text
    * @param {Vectorization.Text} outroTexto 
    * @returns {Vectorization.Scalar}
    */
    context.distanciaHamming = function(outroTexto){
        let outroTexto_Text = Vectorization.Text.isVectorizationText(outroTexto) == false ? Vectorization.Text(outroTexto) : outroTexto;
        let caracteresOutroTexto = outroTexto_Text.toCharacterVector();

        let esteTexto_Text = context;
        let caracteresEsteTexto = esteTexto_Text.toCharacterVector();

        let distanciaTotalCalculada = Vectorization.Scalar(0);

        caracteresEsteTexto.paraCadaElemento(function(i){
            let isIgual = (caracteresEsteTexto.lerIndice(i).isIgual( caracteresOutroTexto.lerIndice(i) ) ) == true ? 0 : 1;
            distanciaTotalCalculada = distanciaTotalCalculada.somarNumero( Vectorization.Scalar(isIgual) );
        });

        return Vectorization.Scalar(distanciaTotalCalculada);
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (classConfig['bloqueado'] != undefined) ? (classConfig['bloqueado']) : false;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //return context;
    return new Proxy(context, {
        
        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Scalar
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Text está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'Você não pode modificar esta atributo do Vectorization.Vector!';
          }

          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Text.isText = function(obj){
    if(obj == undefined){return false};
    return (obj.objectName != undefined && obj.objectName == 'Text') || typeof obj == 'string';
}

window.Vectorization.Text.isVectorizationText = function(obj){
    if(obj == undefined){return false};
    return (obj.objectName != undefined && obj.objectName == 'Text');
}

module.exports = window.Vectorization.Text;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Text.js*/
/* ARQUIVO VECTORIZATION: ../src/Text-translation.js*/
/*
 * File Name: Text-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Text._translations = function(){
    const translatedMethods = {
        'isEquals': 'isIgual'
    };

    const translatedAttributes = {
        'valor': 'value',
        'conteudo': 'value'
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Text._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Text-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Boolean.js*/
/*
 * File Name: Boolean.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 

    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Random'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Boolean = function( value=NaN, classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Boolean._translations || null;

    let classeBaseEscalar = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseEscalar.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( value.objectName != undefined && value.objectName == 'Boolean' ){
        return Vectorization.Boolean( value.raw(), {... classConfig} );
    }

    //let context = {... classConfig};
    let context = window.Vectorization.Base({... classConfig});

    if( classConfig.value ){
        value = classConfig.value;
    }

    if( value != undefined && 
        !(value instanceof Object) &&
        (typeof value == 'number' || typeof value == 'false' || typeof value == 'true' || Vectorization.Utilidades.apenasNumeros(value)) == true
    ){
        if( value > 1 ){
            throw 'Esse Vectorization.Boolean não suporta valores maiores do que 1!';
        }

        if( value < 0 ){
            throw 'Esse Vectorization.Boolean não suporta valores menores do que 0!';
        }

        context.value = Number(value);
        context.configuracoesValue = {};
    
    //Se for um objeto com configurações
    }else if(value instanceof Object){

        //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
        value = classeBaseEscalar.translateAttributes_andReturn(value, classConfig['translations']() );

        //Salva a config
        context.configuracoesValue = {... value};

        if( value.value > 1 ){
            throw 'Esse Vectorization.Boolean não suporta valores maiores do que 1!';
        }

        if( value.value < 0 ){
            throw 'Esse Vectorization.Boolean não suporta valores menores do que 0!';
        }

        if( typeof value.value == 'string' ){
            context.value = value.value;
        }else{
            context.value = Number(value.value);
        }
    }

    if( typeof context.value == 'string' ){
        context.value = String(context.value).toLowerCase();
    }

    if( context.value == 'sim' || context.value == 'verdade' || context.value == 'afirmativo' || context.value == 'verdadeiro' ){
        context.value = Number(true);

    }else if( context.value == 'nao' || context.value == 'falso' || context.value == 'negativo' ){
        context.value = Number(false);
    }

    context.objectName = 'Boolean';
    context.path = 'Vectorization.Boolean';

    context.storedClassConfig = classConfig || {};

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

        }else{
            throw 'Ação não permitida para este Vectorization.Boolean!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;
        }else{
            throw 'Ação não permitida para este Vectorization.Boolean!';
        }
    }

    context.obterValor = function(){
        return context.value;
    }

    context.valueOf = function(){
        return Number.parseFloat( context.value );
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.Text( context.valueOf(), novasConfiguracoes );
    }

    context.toString = function(){
        return String(context.value);
    }

    context.raw = function(){
        return context.value + 0;
    }

    context.toggle = function(){
        if( context.value == Number(true) ){
            context.value = Number(false);
            
        }else{
            context.value = Number(true);
        }
    }

    context.isTrue = function(){
        return context.value == Number(true);
    }

    context.isFalse = function(){
        return context.value == Number(false);
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (classConfig['bloqueado'] != undefined) ? (classConfig['bloqueado']) : false;

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //return context;
    return new Proxy(context, {
        
        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Scalar
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Boolean está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'Você não pode modificar esta atributo do Vectorization.Boolean!';
          }

          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Boolean.isBoolean = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Boolean') || typeof obj == 'number';
}

window.Vectorization.Boolean.isVectorizationBoolean = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Boolean');
}

module.exports = window.Vectorization.Boolean;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Boolean.js*/
/* ARQUIVO VECTORIZATION: ../src/Boolean-translation.js*/
/*
 * File Name: Boolean-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Boolean._translations = function(){
    const translatedMethods = {
        
    };

    const translatedAttributes = {
        'valor': 'value',
        'conteudo': 'value'
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Boolean._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Boolean-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Vector.js*/
/*
 * File Name: Vector.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    require('./Scalar');
    require('./Root');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Vector = function( config=[], classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Vector._translations || null;

    //Por padrão o usarEscalares vai ser true
    if( config['usarEscalares'] == undefined && classConfig['usarEscalares'] == undefined && config['usarEscalares'] != false && classConfig['usarEscalares'] != false ){
        config['usarEscalares'] = true;
    }

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.Vector.isVector(config) && config.objectName == 'Vector' ){
        return Vectorization.Vector( config.values() );
    }

    let context = window.Vectorization.Base(classConfig);
    context.objectName = 'Vector';
    context.path = 'Vectorization.Vector';
    context.configRecebidaUsuario = config;

    context.storedClassConfig = classConfig || {};

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    //classConfig = context.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Aplica a tradução dos atributos também no config, EXCETO SE config FOR UM ARRAY
    if( config instanceof Object && !(config instanceof Array && (config instanceof Array || Vectorization.Vector.isVector(config) )) ){
        config = context.translateAttributes_andReturn(config, classConfig['translations']() );
    }

    context.initialColumnValue = config['fillValue'] || 0;
    context.content = [];

    context.permitirDesbloquear = (config['permitirDesbloquear'] != undefined || classConfig['permitirDesbloquear'] != undefined) ? (config['permitirDesbloquear'] || classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (config['permitirBloquear'] != undefined || classConfig['permitirBloquear'] != undefined) ? (config['permitirBloquear'] || classConfig['permitirBloquear']) : true;

    /**
    * Verifica se algum elemento está presente nesta Vectorization.Matrix
    * @param {Object} valor 
    * @returns {Boolean}
    */
    context.have = function( valor ){
        return context.rawProfundo().includes( valor );
    }

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

            if(context.usarEscalares != undefined && context.usarEscalares == true)
            {
                //Bloquear também os filhos dentro deste Vectorization.Vector
                context.paraCadaElemento(function(i, elementoVetor){
                    elementoVetor.bloquearModificacoes();
                });
            }

        }else{
            throw 'Ação não permitida para este Vectorization.Vector!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;

            if(context.usarEscalares != undefined && context.usarEscalares == true)
            {
                //Desbloquear também os filhos dentro deste Vectorization.Vector
                context.paraCadaElemento(function(i, elementoVetor){
                    elementoVetor.desbloquearModificacoes();
                });
            }
            
        }else{
            throw 'Ação não permitida para este Vectorization.Vector!';
        }
    }

    context.trocarValoresAleatorios = function(novoMinimo=null, novoMaximo=null, novaSemente=null){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }
        
        if( context.usarEscalares == true )    
        {
            context.paraCadaElemento(function(i, elementoVetor){
                elementoVetor.trocarNumeroAleatorio(novoMinimo, novoMaximo, novaSemente);
            });

        }else{
            context.substituirElementosPor(
                context.mapearValores(function(i, elementoVetor){
                    return Vectorization.Scalar({
                        aleatorio: true,
                        minimo: 0,
                        maximo: 10
                    }).trocarNumeroAleatorio(novoMinimo, novoMaximo, novaSemente);
                })
            );
        }

        return context;
    }

    context._update = function(){
        context.length = config.length;
        context.elementos = config.length;
    }

    //Se passar diretamente o conteudo
    if( config instanceof Array ){
        context.content = config;
        context.length = config.length;

    //Ou caso contrario
    }else{
        if( config instanceof Object && config['length'] ){
            context.length = config['length'];
        }

        //Inicializa o vetor
        for( let i = 0 ; i < context.length ; i++ )
        {
            if( Vectorization.Vector.isVectorizationVector(context.initialColumnValue) == true ||
                Vectorization.Matrix.isMatrix(context.initialColumnValue) == true
            ){
                context.content[i] = context.initialColumnValue.duplicar();

            }else{
                context.content[i] = context.initialColumnValue;
            }
        }
    }

    /**
     * Permite definir uma posição especifica deste vetor
     * @param {Number} indice 
     * @param {any} valor 
     */
    context.definirElementoNoIndice = function(indice, valor){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.content[indice] = valor;
    }

    context.estaVazio = function(){
        return context.tamanho() == 0 ? true : false;
    }
    context.isVazio = context.estaVazio;

    /**
     * Permite trocar todos os valores deste vetor, elemento a elemento
     * por valores que vem de outro vetor, com a mesma quantidade de elementos
     * 
     * @param {Vectorization.Vector} outroVector - O outro vetor que contem os valores
     * @returns {Vectorization.Vector}
     */
    context.substituirElementosPor = function(outroVector){
        let valoresASeremColocados = (Vectorization.Vector.isVector(outroVector) && Vectorization.Vector.isVectorizationVector(outroVector)) ? outroVector.valores() : outroVector;
        let tamanhoSegundoVetor = (Vectorization.Vector.isVector(outroVector) && Vectorization.Vector.isVectorizationVector(outroVector)) ? outroVector.tamanho() : outroVector.length;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        if(context.tamanho() != tamanhoSegundoVetor){
            throw 'O tamanho do outroVetor precisa ser o mesmo!';
        }
        
        if( context.tamanho() > 0 )
        {
            Vectorization.Vector(context.content).paraCadaElemento(function(indiceTrocar, elementoTrocar){
                context.definirElementoNoIndice(indiceTrocar, valoresASeremColocados[indiceTrocar]);
            });

        }else{
            throw 'O Vectorization.Vector não pode estar vazio!';
        }

        return valoresASeremColocados;
    }

    /**
     * Permite trocar todos os valores deste vetor, PORÈM não elemento a elemento
     * Ele vai casar os indices deste Vectorization.Vector com o vetor de objetos que identificam os indices e os valores
     * 
     * @param {Vectorization.Vector} outroVectorDeInformacoes - O outro vetor que contem os valores
     * @returns {Vectorization.Vector}
     */
    context.substituirElementosPorIndice = function(outroVectorDeInformacoes){
        let valoresASeremColocados = (Vectorization.Vector.isVector(outroVectorDeInformacoes) && Vectorization.Vector.isVectorizationVector(outroVectorDeInformacoes)) ? outroVectorDeInformacoes.valores() : outroVectorDeInformacoes;
    
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        if( context.tamanho() > 0 )
        {
            Vectorization.Vector(valoresASeremColocados).paraCadaElemento(function(indice, elementoComAsInformacoes){
                let indiceTrocar = elementoComAsInformacoes.indice;
                let valorASerColocado = elementoComAsInformacoes.valor;
                
                context.definirElementoNoIndice(indiceTrocar, valorASerColocado);
            });

        }else{
            throw 'O Vectorization.Vector não pode estar vazio!';
        }

        return context;
    }

    context.toText = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.StringVector( context.raw(), novasConfiguracoes);
    }

    context.values = function(){
        if( context.usarEscalares == true ){
            return context.raw();

        }else{
            return context.content;
        }
    }

    //Alias for context.values
    context.valores = context.values;

    context.toArray = function(){
        if( context.usarEscalares != undefined && context.usarEscalares == true )
        {
            let valoresSemEstarEmEscalar = [];
            context.paraCadaElemento(function(i, objetoEscalar){

                if( objetoEscalar.obterValor == undefined && 
                    typeof objetoEscalar == 'number' 
                
                ){
                    valoresSemEstarEmEscalar.push( objetoEscalar );

                }else{
                    valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );
                }
            });

            return valoresSemEstarEmEscalar;

        }else{
            return context.content;
        }
    }

    //Alias for context.toArray
    context.raw = context.toArray;

    context.rawProfundo = function(){
        if( context.usarEscalares != undefined && context.usarEscalares == true )
        {
            let valoresSemEstarEmEscalar = [];
            context.paraCadaElemento(function(i, objetoEscalar){

                if( objetoEscalar.obterValor == undefined && 
                    typeof objetoEscalar == 'number' 
                
                ){
                    valoresSemEstarEmEscalar.push( objetoEscalar );

                }else{
                    valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );
                }
            });

            return valoresSemEstarEmEscalar;

        }else{
            //if( context.content.some( (elementoAtual)=>{ return Vectorization.Vector.isVectorizationVector(elementoAtual) || Vectorization.BendableVector.isVectorizationBendableVector(elementoAtual) } ) 
            if( (elementoAtual) => Vectorization.Scalar.isScalar(elementoAtual) == true || 
                                   Vectorization.Text.isText(elementoAtual) == true )
            {
                let valoresSemEstarEmEscalar = [];
                context.paraCadaElemento(function(i, objetoEscalar){

                    if( Vectorization.Scalar.isScalar(objetoEscalar) || 
                        Vectorization.Text.isText(objetoEscalar)
                    
                    ){
                        if( objetoEscalar.obterValor != undefined )
                        {
                            valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );

                        }else{
                            valoresSemEstarEmEscalar.push( objetoEscalar );
                        }
    
                    }else{
                        valoresSemEstarEmEscalar.push( objetoEscalar );
                    }
                });

                return valoresSemEstarEmEscalar;
                
            }else{
                return context.content;
            }
        }
    }

    context.obterTiposRapido = function(includeNamespace=false){
        let tiposUsados = [];
        context.paraCadaElemento(function(i, elementoAtual){
            if( includeNamespace == true ){
                tiposUsados.push( 'Vectorization.' + String(elementoAtual.objectName) );

            }else{
                tiposUsados.push( String(elementoAtual.objectName) );
            }
        });

        return tiposUsados;
    }

    /**
    * Obtem um novo Vector exatamente igual a este Vector
    * Ou seja, faz uma copia do propio objeto, identido, porém sem manter as referencias. 
    * @returns {Vectorization.Vector}
    */
    context.duplicar = function(){
        let novoVector = [];
        
        for( let i = 0 ; i < context.length ; i++ )
        {
            novoVector.push( context.readIndex(i) );
        }

        //Adicionei para ele copiar o config também
        return Vectorization.Vector(novoVector, {...JSON.parse(JSON.stringify(context._config))} );
    }

    //Alias for duplicar
    context.clonar = context.duplicar;


    //Alias for context.content
    context.conteudo = context.content;

    context.sizeOf = function(){
        return context.length;
    }

    context.tamanho = function(){
        return context.sizeOf();
    }

    context.push = function(element){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        //Se este Vector está usando escalares, e se o objeto 'element' não é um Scalar, converte para Scalar
        if( context.usarEscalares == true ){
            context.content.push( !Vectorization.Scalar.isVectorizationScalar(element) ? Vectorization.Scalar(element) 
                                                                                       //Ou então caso o 'element' ja seja um scalar, mantém ele como scalar.
                                                                                       : element );

        //Caso este Vector não use escalares
        }else if( context.usarEscalares == false ){
                                 //Se ele ja for um número normal, mantem como está
            context.content.push( !Vectorization.Scalar.isVectorizationScalar(element) ? element
                                                                                       //Agora caso ele seja um Scalar e este Vector não usa escalares, ele converte para número normal
                                                                                       : element.raw() );
        }

        context._update();
    }
    context.adicionarElemento = context.push;

    context.adicionarElementoNoInicio = function(elemento){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }
        
        context.content.unshift(elemento);
        context._update();
    }

    context.readIndex = function(i){
        return context.content[i];
    }

    /**
    * @param {Function} funcao 
    * @returns {Vectorization.Vector} - o propio Vectorization.Vector
    * 
    * CUIDADO: isso vai modificar este propio Vectorization.Vector
    */
    context.aplicarFuncao = function(funcao){
        context.substituirElementosPor(
            context.mapearValores(function(indice, elementoVetor){
                return funcao(elementoVetor, indice);
            })
        );

        return context;
    }

    context.valorMinimo = function(){
        let valoresAnalisar = context.duplicar();
        let menorValorEncontrado = valoresAnalisar.readIndex(0);

        // Verificar se o vetor não está vazio
        if (valoresAnalisar.elementos == 0) {
            throw 'Este Vectorization.Vector não tem nada dentro.';
        }

        valoresAnalisar.paraCadaElemento(function(i){
            const elemento = valoresAnalisar.readIndex(i);

            if( elemento < menorValorEncontrado )
            {
                menorValorEncontrado = elemento;
            }
        });

        return menorValorEncontrado;
    }

    context.valorMaximo = function(){
        let valoresAnalisar = context.duplicar();
        let maiorElementoEncontrado = valoresAnalisar.readIndex(0);

        // Verificar se o vetor não está vazio
        if (valoresAnalisar.elementos == 0) {
            throw 'Este Vectorization.Vector não tem nada dentro.';
        }

        valoresAnalisar.paraCadaElemento(function(i){
            const elemento = valoresAnalisar.readIndex(i);

            if( elemento > maiorElementoEncontrado )
            {
                maiorElementoEncontrado = elemento;
            }
        });

        return maiorElementoEncontrado;
    }

    context.indexOf = function(elemento, comecandoAPartirDoIndice){
        return Vectorization.Vector(context).duplicar()
        .raw().indexOf( 
            Vectorization.Scalar.isVectorizationScalar(elemento) == true ? elemento.obterValor() : elemento, 
            comecandoAPartirDoIndice);
    }

    context.sum = function(){
        let result = 0;
        for( let i = 0 ; i < context.length ; i++ )
        {   
            result = result + Number.parseFloat( context.readIndex( i ) );
        }

        return result;
    }

    context.soma = function(){
        return context.sum();
    }

    context.mean = function(){
        let sum = context.sum();
        return sum / context.length;
    }

    context.media = function(){
        return context.mean();
    }

    /**
    * Calcula a mediana 
    * Ou seja, o valor do meio deste Vectorization.Vector quando ordenado em ordem crescente
    */
    context.mediana = function(){
        const valorDoMeio = Math.floor(context.length/2);
        const quantidadeIsImpar = context.length % 2 != 0;
        const quatidadeIsPar    = !quantidadeIsImpar;

        //Se tiver apenas um valor central
        if( quantidadeIsImpar == true ) {
            return context.ordenarCrescente()
                          .lerIndice( valorDoMeio );

        //Se tiver mais DOIS VALORES central
        }else if( quatidadeIsPar == true ){

            // Calcula a media dos dois valores centrais
            const valor1 = context.ordenarCrescente()
                                  .lerIndice(valorDoMeio - 1);

            const valor2 = context.ordenarCrescente()
                                  .lerIndice(valorDoMeio);

            const mediaDeles = (valor1 + valor2) / 2

            return mediaDeles;
        }
        
    }

    /**
    * Calcula a mediana 
    * Ou seja, o valor do meio deste Vectorization.Vector quando ordenado em ordem crescente
    */
    context.median = context.mediana;

    /**
    * Verifica se todos os elementos deste vetor são "true"
    * @returns {Boolean}
    */
    context.todosVerdadeiros = function(){
        let retorno = false;
        for( let i = 0 ; i < context.content.length ; i++ )
        {   
            if( context.content[i] == true ){
                retorno = true;
            }else{
                retorno = false;
                break;
            }
        }

        return retorno;
    }

    /**
    * Verifica se todos os elementos deste vetor são "false"
    * @returns {Boolean}
    */
    context.todosFalsos = function(){
        let retorno = false;
        for( let i = 0 ; i < context.content.length ; i++ )
        {   
            if( context.content[i] == false ){
                retorno = true;
            }else{
                retorno = false;
                break;
            }
        }

        return retorno;
    }

    /**
    * Verifica se todos os elementos deste vetor são iguais a um valor
    * @param {Number} valor - o valor
    * @returns {Boolean}
    */
    context.todosIguaisA = function(valor){
        let retorno = false;
        for( let i = 0 ; i < context.content.length ; i++ )
        {   
            if( context.content[i] == valor ){
                retorno = true;
            }else{
                retorno = false;
                break;
            }
        }

        return retorno;
    }

    /**
    * Verifica se este Vector é exatamente igual a outro Vector, no conteudo 
    */
    context.isExatamenteIgual = function(vectorB){
        let isIgual = false;

        if(!Vectorization.Vector.isVector(vectorB)){
            isIgual = false;
            return isIgual;
        }

        if( context.length != vectorB.length ){
            isIgual = false;
            return isIgual;
        }

        for( let i = 0 ; i < vectorB.length ; i++ )
        {
            const saoEscalaresOuTextos = (Vectorization.Text.isVectorizationText( vectorB.readIndex(i) ) == true && Vectorization.Text.isVectorizationText( context.readIndex(i) ) == true) == true ||
                                         (Vectorization.Scalar.isVectorizationScalar( vectorB.readIndex(i) ) == true && Vectorization.Scalar.isVectorizationScalar( context.readIndex(i) ) == true) == true;
            
            const condicao = saoEscalaresOuTextos == true ? vectorB.readIndex(i).isIgual( context.readIndex(i) )
                                                          : vectorB.readIndex(i) == context.readIndex(i);

            if( condicao == true ){
                isIgual = true;
            }else{
                isIgual = false;
                break;
            }
        }

        return isIgual;
    }

    /**
    * Permite fatiar(ou recortar) este vetor
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Vector} - o vetor recortado
    */
    context.slice = function(elementoInicial, elementoFinal, intervalo=1){
        let dadosRecortados = [];

        if( elementoInicial < 0 ){
            throw 'A elementoInicial precisa ser maior ou igual a zero!';
        }

        if( elementoFinal > context.length ){
            throw 'A elementoFinal precisa estar dentro da faixa de valores do Vector! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        for( let i = elementoInicial ; i < elementoFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.readIndex(i) );
        }

        return Vectorization.Vector(dadosRecortados);
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma função de callback
    * @param {Function} callback(index, element, context)
    */
    context.forEach = function(callback){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            let ultimoEstadoRetornado = callback( i, context.content[i], context );
    
            if( ultimoEstadoRetornado instanceof Object )
            {
                ultimoEstadoRetornado.propriedadesControle = {};

                switch(ultimoEstadoRetornado.acao){
                    case 'parar':
                    case 'parar_loop':
                    case 'interromper':
                    case 'stop':
                        ultimoEstadoRetornado.propriedadesControle.vaiPararLoop = true;
                        break;

                    case 'reiniciar':
                    case 'reiniciar_loop':
                    case 'restart':
                        i = 0;
                        break;

                    case 'ir_indice':
                    case 'ir_iteracao':
                    case 'go_iteration':
                        if( ultimoEstadoRetornado.valor != undefined )
                        {
                            i = ultimoEstadoRetornado.valor;
                        }else{
                            throw 'Não é possivel ir para uma iteração sem um numero';
                        }
                        break;
                }

                //Interromper este loop
                if( ultimoEstadoRetornado.propriedadesControle.vaiPararLoop == true ){
                    break;
                }
            }
        }
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma função de callback, porém faz isso de forma contrária/revertida
    * @param {Function} callback(index, element, context)
    */
    context.paraCadaElementoReverso = function(callback, executarNoContexto=null){
        let valorComecar = context.tamanho()-1;
        let valorVaiInterromper = 0;
        let vaiParar = false;

        for( let i = valorComecar ; vaiParar == false ; i-- )
        {
            if( i > valorVaiInterromper ){
                vaiParar = false;
            }else{
                //Brecar aqui
                vaiParar = true;
            }

            if( executarNoContexto != null ){
                callback = callback.bind(executarNoContexto);
            }

            ultimoEstadoRetornado = callback(
                     //O indice
                     i, 
                     //O elemento atual
                     context.content[i],
                     //O propio contexto deste Vectorization.Vector 
                     context
                    );

            if( ultimoEstadoRetornado instanceof Object )
            {
                ultimoEstadoRetornado.propriedadesControle = {};

                switch(ultimoEstadoRetornado.acao){
                    case 'parar':
                    case 'parar_loop':
                    case 'interromper':
                    case 'stop':
                        ultimoEstadoRetornado.propriedadesControle.vaiPararLoop = true;
                        break;

                    case 'reiniciar':
                    case 'reiniciar_loop':
                    case 'restart':
                        i = 0;
                        break;

                    case 'ir_indice':
                    case 'ir_iteracao':
                    case 'go_iteration':
                        if( ultimoEstadoRetornado.valor != undefined )
                        {
                            i = ultimoEstadoRetornado.valor;
                        }else{
                            throw 'Não é possivel ir para uma iteração sem um numero';
                        }
                        break;
                }

                //Interromper este loop
                if( ultimoEstadoRetornado.propriedadesControle.vaiPararLoop == true ){
                    break;
                }
            }
        }
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma função de callback, retornando um resultado
    * @param {Function} callback(index, element, context)
    * @returns {Vectorization.Vector}
    */
    context.map = function(callback){
        let novoVetor = [];

        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = callback( i, context.content[i], context );
        }

        return Vectorization.Vector(novoVetor);
    }

    /**
    * Percorre cada elemento do vetor, aplicando uma função de filtro, retornando um resultado que é filtrado de forma rígida.
    * Isso ignora elementos que não atendam aos critérios que voce estabeleceu na função de filtro
    * @param {Function} callback(index, element, context)
    * @returns {Vectorization.Vector} - um novo Vectorization.Vector
    */
    context.filtrar = function(funcaoDeFiltro, incluirDetalhes=false){
        let novoVetor = Vectorization.Vector([]);

        if(!funcaoDeFiltro){
            throw 'Voce precisa passar uma função de filtro!. Não permitido!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: context.tamanho()

        }).paraCadaElemento(function(i, element, contextoLoop){
            let checagemDoFiltro = funcaoDeFiltro( i, context.content[i], context );

            if(checagemDoFiltro == true || checagemDoFiltro == 'incluir' || checagemDoFiltro == 'manter' || checagemDoFiltro == 'keep' || checagemDoFiltro == 'ok'){
                if( incluirDetalhes == true ){
                    novoVetor.adicionarElemento({
                        valor: context.content[i],
                        indice: i,
                        parIndiceValor: [i, context.content[i]],
                        terminouExecutarFiltro: new Date().getTime(),
                        resultadoFuncaoFiltro: checagemDoFiltro,
                        context: context
                    });

                }else{
                    novoVetor.adicionarElemento( context.content[i] );
                }
            }
        });

        return Vectorization.Vector( novoVetor.valores() );
    }

    context.ignorarUndefined = function(){
        return context.filtrar(function(iAtualFiltragem, elementoAtualFiltragem){
            if( elementoAtualFiltragem != undefined && 
                elementoAtualFiltragem != null &&
                isNaN(elementoAtualFiltragem) == false
            ){
                return 'manter';
            }
        }, false);
    }

    context.ignorar = function(oElemento){
        return context.filtrar(function(iAtualFiltragem, elementoAtualFiltragem){
            if( elementoAtualFiltragem != oElemento ){
                return 'manter';
            }
        }, false);
    }
    context.ignorarOs = context.ignorar;

    context.sobrescreverConteudo = function(novoConteudoDoVetor){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.content = Vectorization.Vector.isVectorizationVector( novoConteudoDoVetor ) ? novoConteudoDoVetor.valores() : novoConteudoDoVetor;
        context.conteudo = context.content;
    }

    /**
    * Remove valores duplicados deste Vectorization.Vector com base em colunas específicas.
    */
    context.distinct = function(){
        const valoresJaVistos = {};
        const valoresUnicos = Vectorization.Vector([], context._config);

        context.forEach(function(indice, valor){
            const identificador = String(valor);

            if( valoresJaVistos[identificador] == undefined ){
                valoresJaVistos[identificador] = true;
                valoresUnicos.push( valor );
            }
        });

        return valoresUnicos;
    }

    /**
    * Similar ao context.filtrar
    * Percorre cada elemento do vetor, aplicando uma função de filtro, retornando um resultado que é filtrado de forma rígida.
    * Isso ignora elementos que não atendam aos critérios que voce estabeleceu na função de filtro
    * 
    * CUIDADO: Este método vai sobrescrever os valores deste Vectorization.Vector
    */
    context.aplicarFiltro = function(funcaoDeFiltro){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.sobrescreverConteudo(
            Vectorization.Vector(
                context.filtrar(funcaoDeFiltro, incluirDetalhes=true)

            ).mapearValores(function(indiceAtual, valorAtual){
                //Se for um objeto retornado pela função filtrar
                if(typeof valorAtual == 'object')
                {
                    return valorAtual.valor;
                }else{
                    return valorAtual;
                }
            })
        );
    }

    //Preenche tudo com um unico valor especifico
    context.preencherTudo = function(valorEspecifico){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.paraCadaElemento(function(indicePreencher, elemento, contextoVetor){
            context.content[indicePreencher] = valorEspecifico;
        });

        return context;
    }

    /**
    * Similar ao preencherTudo, porém ele só preenche valores que atendam a certo critério simples
    * Neste caso o critério é onde o valorEspecifico apareça no indice deste Vectorization.Vector
    * Mais ele vai preencher todos os valores onde a condição bate
    * @param {any} valorEspecifico 
    * @param {any} novoValorEspecifico 
    * @returns {Vectorization.Vector}
    */
    context.preencherTudoOnde = function(valorEspecifico, novoValorEspecifico){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.paraCadaElemento(function(indicePreencher, elemento, contextoVetor){
            let valorNaPosicaoAtualDoVetor = context.readIndex(indicePreencher);

            if( String(valorNaPosicaoAtualDoVetor) == String(valorEspecifico) &&
                String(valorNaPosicaoAtualDoVetor).length == String(valorEspecifico).length
            ){
                context.definirElementoNoIndice(indicePreencher, novoValorEspecifico);
            }
        });

        return context;
    }

    /**
    * Similar ao preencherTudoOnde, só que ele vai preencher só os N primeiros
    * @param {any} valorEspecifico 
    * @param {any} novoValorEspecifico 
    * @returns {Vectorization.Vector} - o propio Vectorization.Vector
    */
    context.preencherAlgunsOnde = function(valorEspecifico, novoValorEspecifico, quantidadeLimitePreencher, direcaoOperar='esquerda'){
        let quantidadeJaPreencheu = 0;
        let valorNaPosicaoAtualDoVetor;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        switch(direcaoOperar){
            case 'esquerda':
            case 'left':
            case 'inicio':
                context.paraCadaElemento(function(indicePreencher, elemento, contextoVetor){
                    valorNaPosicaoAtualDoVetor = context.readIndex(indicePreencher);
        
                    if( String(valorNaPosicaoAtualDoVetor) == String(valorEspecifico) &&
                        String(valorNaPosicaoAtualDoVetor).length == String(valorEspecifico).length
                    ){
                        if( quantidadeJaPreencheu < quantidadeLimitePreencher ){
                            context.definirElementoNoIndice(indicePreencher, novoValorEspecifico);
                        }
        
                        quantidadeJaPreencheu++;
                    }
                });
                break;

            case 'direita':
            case 'frente':
            case 'right':
                context.paraCadaElementoReverso(function(indicePreencher, elemento, contextoVetor){
                    valorNaPosicaoAtualDoVetor = context.readIndex(indicePreencher);
        
                    if( String(valorNaPosicaoAtualDoVetor) == String(valorEspecifico) &&
                        String(valorNaPosicaoAtualDoVetor).length == String(valorEspecifico).length
                    ){
                        if( quantidadeJaPreencheu < quantidadeLimitePreencher ){
                            context.definirElementoNoIndice(indicePreencher, novoValorEspecifico);
                        }
        
                        quantidadeJaPreencheu++;
                    }
                });
                break;

            default:
                throw 'Voce precisa dizer em qual direção voce quer usar'
                break;
        }

        return context;
    }

    //Também, se o config for um objeto(NÂO FOR UM ARRAY)
    if( config instanceof Object && !(config instanceof Array && (config instanceof Array || Vectorization.Vector.isVector(config) )) ){
        context.aleatorio = config['aleatorio'] || false;
        
        if( config['aleatorio'] != undefined &&
            config['numeros'] != undefined
        ){
            throw 'Voce não pode criar um Vectorization.Vector com contéudo definido, e ao mesmo tempo sendo aleatório!';
        }

        if( context.aleatorio == true ){
            context.content = []; // Zero o conteudo

            //Se tem outros detalhes
            if( config['minimo'] != undefined && 
                config['maximo'] != undefined && 
                config['elementos'] != undefined &&
                typeof config['minimo'] == 'number' &&
                typeof config['maximo'] == 'number' &&
                typeof config['elementos'] == 'number'
            ){
                //Grava os parametros
                context.minimoAleatorio = config['minimo'];
                context.maximoAleatorio = config['maximo'];

                //Se tiver um número base
                if( config['sementeAleatoria'] != undefined &&
                    typeof config['sementeAleatoria'] == 'number'
                ){
                    context.sementeAleatoria = config['sementeAleatoria'];
                }else{
                    context.sementeAleatoria = Vectorization.Random._sementeDefinida;
                }

                //Vai gerando os valores aleatorios enquanto não terminar a quantidade de elementos
                while( context.content.length < config['elementos'] )
                {
                    let numeroAleatorioGeradoParaOIndice = Vectorization.Random.gerarNumeroAleatorio( Number(context.minimoAleatorio), Number(context.maximoAleatorio), context.sementeAleatoria );
                    context.adicionarElemento( numeroAleatorioGeradoParaOIndice );
                }

                //Se o programador quiser arredondar
                if( config['arredondar'] != undefined ){
                    switch(config['arredondar']){
                        case true:
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.round(valor);
                                }).valores()
                            );
                            break;

                        case 'cima':
                        case 'up':
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.ceil(valor);
                                }).valores()
                            );
                            break;
            
                        case 'baixo':
                        case 'down':
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.floor(valor);
                                }).valores()
                            );
                            break;

                        case 'automatico':
                        case 'auto':
                            context.substituirElementosPor(
                                Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                                    return Math.round(valor);
                                }).valores()
                            );
                            break;
                    }
                }

            }else{
                if( typeof config['minimo'] != 'number' ||
                    typeof config['maximo'] != 'number' ||
                    typeof config['elementos'] != 'number' 
                ){
                    throw 'Os valores minimo, máximo e quantidade de elementos precisam ser números!. Tipo não permitido.'
                
                }else{
                    throw 'Para criar um Vector aleatório voce precisar passar a faixa de valores e a quantidade de elementos!';
                }
            }

            context.conteudo = context.content;
        
        //Se for um objeto, que não possui o atributo "aleatorio"
        }else if(context.aleatorio == false){
            
            if( config['numeros'] != undefined &&
                Vectorization.Vector.isVector(config['numeros'])
            ){
                if( config['aleatorio'] != undefined ){
                    throw 'Voce não pode criar um Vectorization.Vector com contéudo definido, e ao mesmo tempo sendo aleatório!';
                }

                context.content = config['numeros'] != undefined ? 
                                  (Vectorization.Vector.isVectorizationVector(config['numeros']) ? config['numeros'].valores() : 
                                   config['numeros']) : [];

                context.length = context.content.length;
                context.elementos = context.length;
            }

            context.conteudo = context.content;
        }
    }


    /**
    * Retorna os valores deste Vectorization.Vector como arredondados.
    * @param {String} tipoArredondamentoAplicar
    * @returns {Vectorization.Vector}
    */
    context.getValoresArredondados = function(tipoArredondamentoAplicar='cima'){
        let novoVetorArredondado = Vectorization.Vector( context.duplicar(), context._config );

        //Se o programador quiser arredondar
        if( tipoArredondamentoAplicar != undefined ){
            switch(tipoArredondamentoAplicar){
                case true:
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.round(valor);
                        }).valores()
                    );
                    break;

                case 'cima':
                case 'up':
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.ceil(valor);
                        }).valores()
                    );
                    break;
    
                case 'baixo':
                case 'down':
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.floor(valor);
                        }).valores()
                    );
                    break;

                case 'automatico':
                case 'auto':
                    novoVetorArredondado.substituirElementosPor(
                        Vectorization.Vector(context.content).mapearValores(function(iValor, valor){
                            return Math.round(valor);
                        }).valores()
                    );
                    break;

                default:
                    if(tipoArredondamentoAplicar != false){
                        throw 'Voce precisa falar que tipo de arredondamento voce quer fazer!';
                    }
                    break;
            }
        }

        return novoVetorArredondado;
    }

    /**
    * Aplica um arredondamento sobre os valores deste vetor
    * CUIDADO: isso vai sobrescrever os valores
    * 
    * @param {String} tipoArredondamentoAplicar
    * @returns {Vectorization.Vector} - o propio vetor
    */
    context.aplicarArredondamento = function(tipoArredondamentoAplicar='cima'){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        context.substituirElementosPor(
            context.getValoresArredondados(tipoArredondamentoAplicar)
        );

        return context;
    }

    /**
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Este propio Vectorization.Vector sobrescrito(CUIDADO!)
    */
    context.acrescentarVetor = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado : Vectorization.Vector(novoVetorASerAcrescentado, context._config); 
        let contextoEsteVetor = context;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = novoVetorASerAcrescentado_Vector.lerIndice(i);
            context.adicionarElemento(elementoVetorASerAdicionado);
        });
    }

    /**
    * Se parece muito ao context.acrescentarVetor, só que aqui, ele vai apenas retornar uma novo Vectorization.Vector, NÂO SUBSTITUI ESTE VETOR
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Um novo Vectorization.Vector
    */
    context.juntarComOutroVetor = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado : Vectorization.Vector(novoVetorASerAcrescentado, context._config); 
        let contextoEsteVetor = context;

        let novoVetorASerAcrescentado_VectorFinal = contextoEsteVetor.duplicar();

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = novoVetorASerAcrescentado_Vector.lerIndice(i);
            novoVetorASerAcrescentado_VectorFinal.adicionarElemento(elementoVetorASerAdicionado);
        });

        return novoVetorASerAcrescentado_VectorFinal;
    }

    /**
    * Se parece muito ao context.acrescentarVetor, porém ele pôem os elementos no inicio do vetor, ao invés de colocar no final do mesmo
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Este propio Vectorization.Vector sobrescrito(CUIDADO!)
    */
    context.acrescentarNoInicioVetor = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado : Vectorization.Vector(novoVetorASerAcrescentado, context._config); 
        let contextoEsteVetor = context;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: contextoEsteVetor.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = contextoEsteVetor.lerIndice(i);
            novoVetorASerAcrescentado_Vector.adicionarElemento(elementoVetorASerAdicionado);
        });

        let novoVetorASerAcrescentado_VectorFinal = Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        });

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_VectorFinal.tamanho()
        })
        .paraCadaElemento(function(i){
            novoVetorASerAcrescentado_VectorFinal[i] = novoVetorASerAcrescentado_Vector.lerIndice(i);
        });

        contextoEsteVetor.sobrescreverConteudo(
            novoVetorASerAcrescentado_VectorFinal.duplicar()
                                                 .valores()
        )
    }

    /**
    * Se parece muito ao context.acrescentarNoInicioVetor, só que aqui, ele vai apenas retornar uma novo Vectorization.Vector, NÂO SUBSTITUI ESTE VETOR
    * @param {Vectorization.Vector} novoVetorASerAcrescentado 
    * @returns {Vectorization.Vector} - Um novo Vectorization.Vector
    */
    context.juntarComOutroVetorNoInicio = function(novoVetorASerAcrescentado){
        let novoVetorASerAcrescentado_Vector = Vectorization.Vector.isVectorizationVector(novoVetorASerAcrescentado) ? novoVetorASerAcrescentado.duplicar() : Vectorization.Vector(novoVetorASerAcrescentado, context._config).duplicar(); 
        let contextoEsteVetorDuplicado = context.duplicar();

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: contextoEsteVetorDuplicado.tamanho()
        })
        .paraCadaElemento(function(i){
            const elementoVetorASerAdicionado = contextoEsteVetorDuplicado.lerIndice(i);
            novoVetorASerAcrescentado_Vector.adicionarElemento(elementoVetorASerAdicionado);
        });

        let novoVetorASerAcrescentado_VectorFinal = Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_Vector.tamanho()
        });

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: novoVetorASerAcrescentado_VectorFinal.tamanho()
        })
        .paraCadaElemento(function(i){
            novoVetorASerAcrescentado_VectorFinal[i] = novoVetorASerAcrescentado_Vector.lerIndice(i);
        });

        return novoVetorASerAcrescentado_VectorFinal;
    }

    //OUTROS MÉTODOS ABAIXO

    /**
     * Produto escalar entre dois vetores
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-vetor-com-vetor
     * 
     * @param {Vectorization.Vector} vectorA 
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Scalar}
    */
    context.produtoEscalar = function(vectorB){
        let vectorA = context;

        if( vectorA.length != vectorB.length ){
            throw 'The number of elements in vector A must be exactly equal to the number of elements in vector B. Impossible to calculate!';
        }

        if( !vectorB instanceof Object ){
            throw 'vectorB must be a Object'
        }

        if( vectorB.objectName != 'Vector' ){
            throw 'vectorB must be a instance of ' + String( context.path );
        }

        //Inicializa a variavel que será usada para a soma ponderada da linha atual
        let produtoAtual = 0;
        //Percorre cada elemento do vetor B
        for( let colunaB = 0 ; colunaB < vectorB.length ; colunaB++ ){
            produtoAtual += ( vectorA.readIndex(colunaB) * vectorB.readIndex(colunaB) );
        }

        return Vectorization.Scalar(produtoAtual);
    }

    //Alias for produtoEscalar
    context.produtoEscalarVetor = context.produtoEscalar;

    /**
     * Produto escalar entre este vetor e uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-vetor-com-matriz
     * @param {Vectorization.Vector} vectorA 
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Vector}
    */
    context.produtoEscalarMatrix = function(matrixA){
        let vectorB = context.content;

        if( matrixA.rows != vectorB.length ){
            throw 'O número de linhas da matrixA deve ser exatamente igual ao numero de elementos do vetor. Impossivel calcular!';
        }
    
        let vetorResultado = [];
    
        //Percorre cada linha da matrix A
        for( let linha = 0 ; linha < matrixA.rows ; linha++ ){
    
            //Inicializa a variavel que será usada para a soma ponderada
            let produtoAtual = 0;
    
            //Percorre cada elemento do vetor B
            for( let colunaB = 0 ; colunaB < vectorB.length ; colunaB++ ){
                /*
                * Obtem os valores da linha atual da matrix A(nesse caso, a linha é na verdade a colunaB)
                * Pois, quando vamos calcular o produto escalar entre um vetor e uma matrix, acessamos os elementos de forma diferente: ao invez de acessar matrix[linha][coluna](como fazemos no produto escalar entre matrix e vetor), fazemos o contrário e acessamos matrix[coluna][linha], 
                * Ou seja, na matrix A, acessamos a coluna correspondente ao elemento atual do vetor B.
                * Ou seja, a nivel de código, na matrixA acessamos a colunaB que é o elemento atual do vetor, de modo que matrixA.content[colunaB] retornará um vetor(isto é, a variavel colunaB da matrixA), e ai em seguida nós acessamos a linha atual da matrixA, ou seja, literalmente matrixA.content[coluna][linha], e é assim que vamos fazer a soma ponderada.
                * É assim que vamos fazer a soma ponderada.
                */
                let valoresAtualMatrixNaPosicaoColunaB = matrixA.content[colunaB]; //Aqui a linha vai ser na verdade a coluna, no caso, a linha da colunaB, da matrix em questão
    
                produtoAtual += ( vectorB[colunaB] * valoresAtualMatrixNaPosicaoColunaB[linha] ); //E a coluna vai ser a linha
            }
    
            //Vai adicionando os resultados no vetor de resultado
            vetorResultado.push(produtoAtual);
        }
    
        return Vectorization.Vector(vetorResultado, context._config);
    }

    /**
     * Multiplica este vetor com outro vetor
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-vetores-elemento-a-elemento/codigo-principal.js
     * @param {Vectorization.Vector} vectorB_param
     * @returns {Vectorization.Vector}
    */
    context.multiplicarVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content;
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let vetorResultado = [];

        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }

        for( let i = 0 ; i < vectorA.length ; i++ )
        {   
            vetorResultado.push( vectorA[i] * vectorB[i] );
        }

        return Vectorization.Vector(vetorResultado, context._config);
    }

    /**
     * Multiplica este vetor por um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-vetores-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.multiplicarNumero = function(numero){
        let vetorResultado = [];
        let vectorA = context.content;

        for( let i = 0 ; i < vectorA.length ; i++ )
        {   
            vetorResultado.push( vectorA[i] * numero );
        }

        return Vectorization.Vector(vetorResultado, context._config);
    }

    /**
     * Multiplica este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.multiplicarMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] * matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Divide este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.dividirMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] / matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Faz a soma deste vetor com outro vetor
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-vetores/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.somarVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] + vectorB[i];
        }
    
        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
     * Soma este vetor com um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-vetores-por-um-numero-scalar/codigo-principal.js 
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.somarNumero = function(numero){
        let novoVetor = [];
        let vectorA = context.content;

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] + numero;
        }

        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
     * Soma este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.somarMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] + matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Faz a subtração deste vetor com outro vetor
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-vetores/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.subtrairVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] - vectorB[i];
        }
    
        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
     * Subtrai este vetor com um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-vetores-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.subtrairNumero = function(numero){
        let novoVetor = [];

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] - numero;
        }

        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
     * Subtrai este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.subtrairMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( vectorB[j] - matrixA[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Faz a divisão deste vetor com outro vetor
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-vetores/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.dividirVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] / vectorB[i];
        }
    
        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
     * Divide este vetor com um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-vetores-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.dividirNumero = function(numero){
        let novoVetor = [];
        let vectorA = context.content;

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = vectorA[i] / numero;
        }

        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
     * Eleva este vetor a um número
     * 
     * @param {Number} numero
     * @returns {Vectorization.Vector}
    */
    context.elevarNumero = function(numero){
        let novoVetor = [];

        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = Math.pow(vectorA[i], numero);
        }

        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
    * Eleva este vetor a outro vetor
    * 
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Vector}
    */
    context.elevarVetor = function(vectorB_param){
        if( vectorB_param.objectName != undefined && vectorB_param.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB_param.objectName);
        }

        let vectorA = context.content; 
        let vectorB = (vectorB_param.objectName && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novoVetor = [];
    
        if( vectorA.length != vectorB.length ){
            throw 'Os vetores precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < vectorA.length ; i++ )
        {
            novoVetor[i] = Math.pow(vectorA[i], vectorB[i]);
        }
    
        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
     * Eleva este vetor com uma matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB
     * @returns {Vectorization.Matrix} 
     */
    context.elevarMatrix = function(matrixB){
        let matrixA = (matrixB.objectName != undefined && matrixB.objectName == 'Matrix') ? matrixB.content : matrixB;
        let vectorB = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( Math.pow(vectorB[j], matrixA[i][j]) );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
    * Obtem o vetor oposto
    * @returns {Vectorization.Vector}
    */
    context.vetorOposto = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = context.content[i] * -1;
        }

        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
    * Obtem o vetor absoluto
    * @returns {Vectorization.Vector}
    */
    context.abs = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.abs(context.content[i]);
        }

        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
    * Obtem o vetor absoluto
    * @returns {Vectorization.Vector}
    */
    context.absoluto = function(){
        return context.abs();
    }

    /**
    * Obtem a raiz quadrada de cada elemento do vetor
    * @returns {Vectorization.Vector}
    */
    context.sqrt = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.sqrt(context.content[i]);
        }

        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
    * Obtem o log2 de cada elemento do vetor
    * @returns {Vectorization.Vector}
    */
    context.log2 = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.log2(context.content[i]);
        }

        return Vectorization.Vector(novoVetor, context._config);
    }

    /**
    * Obtem o log10 de cada elemento do vetor
    * @returns {Vectorization.Vector}
    */
    context.log10 = function(){
        let novoVetor = [];
        
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novoVetor[i] = Math.log10(context.content[i]);
        }

        return Vectorization.Vector(novoVetor, context._config);
    }

    context.removerApenasUm = function(elementoRemover){
        let novoVectorRetirado = Vectorization.Vector([], context._config);
        let vetorPercorrer = context.duplicar();
        let jaFoi = false;

        vetorPercorrer.paraCadaElemento(function(i, elementoVetor){
            if( jaFoi == false && 
                (
                    //Se estiver usando escalares for true, ele precisa usar o raw pra conseguir acessar o valor
                    context.usarEscalares == true ? (elementoVetor.raw() == elementoRemover.raw()) 
                                                  //Caso contrario, se ja for um numero mesmo, ele faz do jeito que estava mesmo
                                                  : (elementoVetor == elementoRemover)
                                                    
                )
            
            ){
                
                jaFoi = true;

            }else{
                novoVectorRetirado.adicionarElemento( context.usarEscalares == true && !Vectorization.Scalar.isVectorizationScalar( elementoVetor ) ? Vectorization.Scalar(elementoVetor) 
                                                                                                                                                    : elementoVetor );
            }
        });

        novoVectorRetirado._update();
        return novoVectorRetirado;
    }

    /**
    * Ordena este Vectorization.Vector em ordem crescente
    * @returns {Vectorization.Vector} - um novo Vectorization.Vector ordenado
    */
    context.ordenarCrescente = function(){
        let novoVectorOrdenado = Vectorization.Vector([], context._config);
        let vetorPercorrer = context.duplicar();
        let vetorTrabalhando = vetorPercorrer.duplicar();

        while( novoVectorOrdenado.elementos != vetorPercorrer.elementos )
        {
            let valorMinimoVetorTrabalhando = vetorTrabalhando.valorMinimo();
    
            let jaFoiAPrimeira = false;
            vetorTrabalhando.paraCadaElemento(function(i, elementoVetor){

                if( jaFoiAPrimeira == false && 
                    (
                        //Se estiver usando escalares for true, ele precisa usar o raw pra conseguir acessar o valor
                        context.usarEscalares == true ? (elementoVetor.raw() == valorMinimoVetorTrabalhando.raw()) 
                                                      //Caso não esteja, pode continuar como antes
                                                      : (elementoVetor == valorMinimoVetorTrabalhando)

                    )
                
                ){
                    novoVectorOrdenado.adicionarElemento( context.usarEscalares == true && !Vectorization.Scalar.isVectorizationScalar( elementoVetor ) ? Vectorization.Scalar(elementoVetor) 
                                                                                                                                                        : elementoVetor );
                    jaFoiAPrimeira = true;

                    //Vai parar o loop do elementoVetor
                    return {
                        acao: 'parar_loop'
                    }
                }

            })

            //Substitui o vetorTrabalhando
            vetorTrabalhando = vetorTrabalhando.removerApenasUm(valorMinimoVetorTrabalhando);
            jaFoiAPrimeira = false;
        }

        return novoVectorOrdenado;
    }

    /**
    * Ordena este Vectorization.Vector em ordem decrescente
    * @returns {Vectorization.Vector} - um novo Vectorization.Vector ordenado
    */
    context.ordenarDecrescente = function(){
        let novoVectorOrdenado = Vectorization.Vector([], context._config);
        let vetorPercorrer = context.duplicar();
        let vetorTrabalhando = vetorPercorrer.duplicar();

        while( novoVectorOrdenado.elementos != vetorPercorrer.elementos )
        {
            let valorMaximoVetorTrabalhando = vetorTrabalhando.valorMaximo();
    
            let jaFoiAPrimeira = false;
            vetorTrabalhando.paraCadaElemento(function(i, elementoVetor){

                if( jaFoiAPrimeira == false && 
                    (
                        //Se estiver usando escalares for true, ele precisa usar o raw pra conseguir pegar o valor
                        context.usarEscalares == true ? (elementoVetor.raw() == valorMaximoVetorTrabalhando.raw())
                                                      //Caso não esteja, pode continuar como antes
                                                      : (elementoVetor == valorMaximoVetorTrabalhando)
                        
                    )

                ){
                    novoVectorOrdenado.adicionarElemento( context.usarEscalares == true && !Vectorization.Scalar.isVectorizationScalar( elementoVetor ) ? Vectorization.Scalar(elementoVetor) 
                                                                                                                                                        : elementoVetor );
                    jaFoiAPrimeira = true; 

                    //Vai parar o loop do elementoVetor
                    return {
                        acao: 'parar_loop'
                    }
                }

            })

            //Substitui o vetorTrabalhando
            vetorTrabalhando = vetorTrabalhando.removerApenasUm(valorMaximoVetorTrabalhando);
            jaFoiAPrimeira = false;
        }

        return novoVectorOrdenado;
    }

    /**
     * Permite dividir este Vectorization.Vector em N partes iguais.
     * @param {Number} numeroPartesDividir 
     * @returns {Vectorization.Vector} - um Vectorization.Vector de outros Vectorization.Vector(s)
     */
    context.dividirEmPartes = function(numeroPartesDividir){
        let esteVetorCopiado = context.duplicar();
        let tamanhosAproximados = Math.round( esteVetorCopiado.elementos / numeroPartesDividir );
        let ondeParou = 0;

        //Inicia um Envelope contendo "numeroPartesDividir" Vector(s)
        let listaResultadoDivisao = Vectorization.Envelope( Array(numeroPartesDividir).fill(null)
                                                                                      .map(()=>{ 
                                                                                         return Vectorization.Vector([]) 
                                                                                       }) );

        Vectorization.Vector({
            valorPreencher: tamanhosAproximados,
            elementos: numeroPartesDividir
        }).paraCadaElemento(function(iParte, tamanhoParte){

            let quantosJaColocou = 0;
            let jaTerminouEste = false;
            
            Vectorization.Vector(esteVetorCopiado)
            .paraCadaElemento(function(iElemento){
                let elementoAtual = esteVetorCopiado.lerIndice(iElemento);
                let consideradouEsteIndice = ( (ondeParou == 0 || iElemento > ondeParou) == true && quantosJaColocou <= (tamanhoParte-1) == true) == true;
                let jaColocouTudoDaParte = (quantosJaColocou <= (tamanhoParte-1)) == false;

                if( jaTerminouEste == false && (ondeParou == 0 || iElemento > ondeParou) && quantosJaColocou <= (tamanhoParte-1) )
                {
                    //Adiciona ao envelope
                    listaResultadoDivisao.getSeparatedContext()
                                         .lerIndice(iParte)
                                         .adicionarElemento(elementoAtual);

                    ondeParou = iElemento;
                    quantosJaColocou++;
                    
                }else{
                    //Se ele pulou o indice por que ainda não começou a faixa de valores do proximo pedaço, ele ignora e não vai marcar que ja terminou
                    if( jaColocouTudoDaParte == true ){
                        jaTerminouEste = true;

                        //Vai parar o loop do iElemento
                        return {
                            acao: 'parar_loop'
                        }
                    }
                }

            });
        })

        //Retorna o Envelope
        return listaResultadoDivisao;
    }
    context.split = context.dividirEmPartes;

    /**
     * Verifica se este Vectorization.Vector está ordenado de forma crescente
     * @returns {Boolean}
     */
    context.isOrdenadoCrescente = function(){
        let esteVetorCopiado = context.duplicar();
        let estaOrdenado = true;
        Vectorization.Vector(esteVetorCopiado)
        .paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);
            let elementoMaisUm = esteVetorCopiado.readIndex(i+1) || NaN;
            let elementoMenosUm = esteVetorCopiado.readIndex(i-1) || NaN;

            if( elementoMaisUm < elementoAtual || elementoMenosUm > elementoAtual ){
                estaOrdenado = false;

                return {
                    acao: 'parar_loop'
                }
            }
        });

        return estaOrdenado;
    }

    /**
     * Verifica se este Vectorization.Vector está ordenado de forma decrescente
     * @returns {Boolean}
     */
    context.isOrdenadoDecrescente = function(){
        let esteVetorCopiado = context.duplicar();
        let estaOrdenado = true;
        Vectorization.Vector(esteVetorCopiado)
        .paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);
            let elementoMaisUm = esteVetorCopiado.readIndex(i+1) || NaN;
            let elementoMenosUm = esteVetorCopiado.readIndex(i-1) || NaN;

            if( elementoMaisUm > elementoAtual || elementoMenosUm < elementoAtual ){
                estaOrdenado = false;

                return {
                    acao: 'parar_loop'
                }
            }
        });

        return estaOrdenado;
    }

    /**
     * Verifica se este Vectorization.Vector está ordenado de forma crescente ou então decrescente
     * @returns {Boolean}
     */
    context.isOrdenado = function(){
        return (context.isOrdenadoCrescente() || context.isOrdenadoDecrescente());
    }
    context.estaOrdenado = context.isOrdenado;
    context.estiverOrdenado = context.estaOrdenado;
    context.estiverOrdenadoCrescente = context.isOrdenadoCrescente;

    context.primeiroItem = function(){
        return context.lerIndice(0);
    }

    context.ultimoItem = function(){
        return context.lerIndice(context.elementos - 1) + 0;
    }

    context.segundoItem = function(){
        return context.lerIndice(1);
    }
    context.terceiroItem = function(){
        return context.lerIndice(2);
    }
    context.quartoItem = function(){
        return context.lerIndice(3);
    }
    context.quintoItem = function(){
        return context.lerIndice(4);
    }
    context.sextoItem = function(){
        return context.lerIndice(5);
    }
    context.setimoItem = function(){
        return context.lerIndice(6);
    }
    context.oitavoItem = function(){
        return context.lerIndice(7);
    }
    context.nonoItem = function(){
        return context.lerIndice(8);
    }
    context.decimoItem = function(){
        return context.lerIndice(9);
    }

    /**
    * @param {Number} numeroQuerendoPesquisar 
    * @returns {Object}
    */
    context.pesquisaBinaria = function(numeroQuerendoPesquisar, naoChecarOrdenacao=false){
        let resultado = {
            encontrou: false,
            indiceAchou: -1
        };

        if( naoChecarOrdenacao == true || context.estiverOrdenadoCrescente() )
        {
            let esteVetorCopiado = context.duplicar();
            let esteVetor_dividido = esteVetorCopiado.dividirEmPartes(2);
            let tamanhoEsteVetor = esteVetorCopiado.elementos;
            let tamanhoEsteVetor_pelaMetade = Math.round( tamanhoEsteVetor/2 );

            let parte1 = esteVetor_dividido.primeiroItem(),
                parte2 = esteVetor_dividido.segundoItem();

            if( numeroQuerendoPesquisar >= esteVetorCopiado.lerIndice(tamanhoEsteVetor_pelaMetade) ){
                resultado.indiceAchou = parte2.indiceDe(numeroQuerendoPesquisar);
                resultado.encontrou = resultado.indiceAchou > -1 ? true : false;

            }else{
                resultado.indiceAchou = parte1.indiceDe(numeroQuerendoPesquisar);
                resultado.encontrou = resultado.indiceAchou > -1 ? true : false;
            }   

        }else{
            throw 'Você precisa ordenar primeiro em ordem crescente!';
        }

        return resultado;
    }

    /**
    * Vai percorrer cada elemento deste Vectorization.Vector, visando localizar elementos que aparecem mais de uma vez.
    * E com isso, ele vai remover tais repetições de elementos, retornando um novo Vectorization.Vector que não contenha duplicidade. 
    */
    context.valoresUnicos = function(){
        const esteVetorCopiado = context.duplicar();
        const jaFoi = {};
        
        let novoVetor_sem_repeticoes = Vectorization.Vector([]);

        esteVetorCopiado.paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);

            if( jaFoi[ elementoAtual ] == undefined )
            {
                novoVetor_sem_repeticoes.adicionarElemento(elementoAtual);
                jaFoi[ elementoAtual ] = true;
            }
        });

        return novoVetor_sem_repeticoes;
    }

    /**
    * Conta quantas vezes um elemento em questão apareceu dentro deste Vectorization.Vector
    */
    context.contarFrequenciaElemento = function(elementoEmQuestao='nenhumElemento'){
        let quantidade = 0;
        if( elementoEmQuestao == 'nenhumElemento' ){
            throw 'Voce precisa passar um elemento!';
        }

        context.paraCadaElemento(function(iii){
            const elementoAtual = context.lerIndice(iii);
            if( elementoAtual == elementoEmQuestao )
            {
                quantidade = quantidade + 1;
            }
        });

        return quantidade;
    }

    /**
    * Pega os ultimos números deste Vectorization.Vector 
    */
    context.ultimos = function( qtdeElementos ){
        if(!qtdeElementos){
            throw Error('Voce precisa informar a quantidade de elementos!');
        }

        return context.clonar()
                      .slice( Number(context.length - qtdeElementos), context.length )
    }

    /**
    * Pega os ultimos números deste Vectorization.Vector 
    */
    context.obterUltimos = context.ultimos;

    /**
     * Sub-classe auxiliar, para uso interno
     * Possui uma estrutura personalizada para armazenar frequencias
     * @param { Object{contextVinculado:Vectorization.Vector, calcular:Vectorization.Vector||Array} } dadosFrequencias
     * @returns {Vectorization.Vector.FrequenciaComputada}
     */
    Vectorization.Vector.FrequenciaComputada = function(dadosFrequencias){
        let dadosFrequencias_Obj = {};
        let dadosProcurar = [];

        let contextPropioVector = null;
        if( !Vectorization.Vector.isVector(dadosFrequencias) ){
            dadosFrequencias_Obj = {... dadosFrequencias};
            contextPropioVector = dadosFrequencias_Obj.contextVinculado;
            dadosProcurar = dadosFrequencias_Obj.calcular;

            if( dadosProcurar == null || dadosProcurar == undefined ){
                throw 'Voce precisa informar o calcular';
            }

            if( contextPropioVector == null || contextPropioVector == undefined ){
                throw 'Voce precisa informar o contexto do Vectorization.Vector';
            }   
        }

        let informacoesCopiadas = Vectorization.Base(dadosFrequencias_Obj);
        let context_informacoesCopiadas = informacoesCopiadas;
        context_informacoesCopiadas.tabelaFrequencias = {};

        context_informacoesCopiadas.path = 'Vectorization.Vector.FrequenciaComputada';
        context_informacoesCopiadas.namespace = 'window.Vectorization';
        context_informacoesCopiadas.dadosProcurar = dadosProcurar;

        //Permite adicionar ao frequencias_Vector um elemento a ser contado
        informacoesCopiadas.adicionarInformacao = function(conteudo, quantidade=undefined){
            if(quantidade == undefined || quantidade == null){
                quantidade = context_informacoesCopiadas.contextVinculado.contarFrequenciaElemento(conteudo);
            }

            //Cadastra a quantidade informada(ou identificada)
            context_informacoesCopiadas.tabelaFrequencias[ conteudo ] = quantidade;
        }

        informacoesCopiadas.obterContagens = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.dados = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.obter = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.mostrar = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.raw = function(){
            return context_informacoesCopiadas.tabelaFrequencias;
        }

        informacoesCopiadas.maisAparece = function(){
            let contagens = informacoesCopiadas.obterContagens();
            let maiorValorPresente = Vectorization.Vector( Object.values( contagens ) ).valorMaximo();
            let valoresIndexados = Vectorization.Vector( Object.keys( contagens ).map( function(numero){return Number(numero)} ) );
            let maisAparece = contagens[ Object.keys( contagens )[0] ];

            valoresIndexados.paraCadaElemento(function(iii){
                const nomeIndice = valoresIndexados.lerIndice(iii);
                const quantidadeElementoEmQuestao = contagens[ nomeIndice ];

                if( quantidadeElementoEmQuestao == maiorValorPresente ){
                    maisAparece = nomeIndice;

                    return {
                        acao: 'parar_loop'
                    }
                }
            });

            return maisAparece;
        }

        //Nao precisa ser apenas um
        informacoesCopiadas.menosAparece = function(){
            let contagens = informacoesCopiadas.obterContagens();
            let menorValorPresente = Vectorization.Vector( Object.values( contagens ) ).valorMinimo();
            let valoresIndexados = Vectorization.Vector( Object.keys( contagens ).map( function(numero){return Number(numero)} ) );
            let menosAparece = contagens[ Object.keys( contagens )[0] ];

            valoresIndexados.paraCadaElemento(function(iii){
                const nomeIndice = valoresIndexados.lerIndice(iii);
                const quantidadeElementoEmQuestao = contagens[ nomeIndice ];

                if( quantidadeElementoEmQuestao == menorValorPresente ){
                    menosAparece = nomeIndice;

                    return {
                        acao: 'parar_loop'
                    }
                }
            });

            return menosAparece;
        }

        /**
        * Pega os elementos que mais aparecem neste Vectorization.Vector.
        * 
        * @param {Number|String} quantidade - Os TOP N frequencias dos elementos que mais aparecem
        * Isso não significa necessariamente que o resultado vai ter essa quantidade de elementos, mais apenas que, ele vai considerar apenas as TOP N frequencias para procurar pelos elementos.
        * Para explicar melhor, as frequencias serão ordenadas do menor pro maior, e mais TOP N frequencias MAIS ALTAS serão selecionadas.
        * 
        * @param {Number|String} limiar - (opcional) A frequencia especifica
        * 
        * @returns {Vectorization.Vector} - os elementos que mais aparecem
        */
        informacoesCopiadas.maisAparecem = function( quantidade='todos', limiar='media' ){
            let contagens = informacoesCopiadas.obterContagens();
            let mediaFrequencias = Vectorization.Vector( Object.values(contagens) ).media();
            let chavesElementos = Object.keys(contagens);
            let elementosMaisAparecem = [];
            let frequenciasMaisAparecem = [];
            let tabelaMaisAparecem = {};

            for( let i = 0 ; i < chavesElementos.length ; i++ ){
                const chaveElemento     = chavesElementos[i];
                const frequenciElemento = contagens[ chaveElemento ];

                if( limiar == 'media' ? (frequenciElemento > mediaFrequencias) 
                                      : (typeof limiar == 'number' && frequenciElemento > limiar)

                //Se bateu a condição
                ){
                    elementosMaisAparecem.push(chaveElemento);
                    frequenciasMaisAparecem.push( frequenciElemento );
                    tabelaMaisAparecem[ chaveElemento ] = frequenciElemento;
                }
            }

            if(quantidade != 'todos' && typeof quantidade == 'number'){
            
                let frequenciasMaisAparecemOrdenada = Vectorization.Vector( frequenciasMaisAparecem , {usarEscalares: false})
                                                                   //Ordena do menor pro maior
                                                                   .ordenarCrescente()
                                                                   //Pega as TOP "quantidade" que mais aparecem
                                                                   .ultimos( quantidade );

                let elementosMaisAparecemOrdenado = [];

                //Achar quem são os que tem essas TOP frequencias
                for( let f = 0 ; f < frequenciasMaisAparecemOrdenada.length ; f++ ){

                    const valorFreq = frequenciasMaisAparecemOrdenada.readIndex(f);

                    //Pega todos os elementos que tenham a frequencia "valorFreq". Lembrando que pode ser mais de um, por isso eu filtro por TODOS
                    const chavesFreq = elementosMaisAparecem.filter( ( nomeElemento, indiceElemento )=>{ return tabelaMaisAparecem[ nomeElemento ] == valorFreq } );

                    elementosMaisAparecemOrdenado = elementosMaisAparecemOrdenado.concat(chavesFreq);
                }

                //Uso o "valoresUnicos" para poder remover os elementos repetidos
                return Vectorization.Vector( elementosMaisAparecemOrdenado )
                                    .valoresUnicos();
            }

            return Vectorization.Vector( elementosMaisAparecem );
        }

        /**
        * Pega os elementos que MENOS aparecem neste Vectorization.Vector.
        * 
        * @param {Number|String} quantidade - Os TOP N frequencias dos elementos que MENOS aparecem
        * Isso não significa necessariamente que o resultado vai ter essa quantidade de elementos, mais apenas que, ele vai considerar apenas as TOP N frequencias para procurar pelos elementos.
        * 
        * @param {Number|String} limiar - (opcional) A frequencia especifica
        * 
        * @returns {Vectorization.Vector} - os elementos que MENOS aparecem
        */
        informacoesCopiadas.menosAparecem = function( quantidade='todos', limiar='media' ){
            let contagens = informacoesCopiadas.obterContagens();
            let mediaFrequencias = Vectorization.Vector( Object.values(contagens) ).media();
            let chavesElementos = Object.keys(contagens);
            let elementosMenosAparecem = [];
            let frequenciasMenosAparecem = [];
            let tabelaMenosAparecem = {};

            for( let i = 0 ; i < chavesElementos.length ; i++ ){
                const chaveElemento     = chavesElementos[i];
                const frequenciElemento = contagens[ chaveElemento ];

                if( limiar == 'media' ? (frequenciElemento < mediaFrequencias) 
                                      : (typeof limiar == 'number' && frequenciElemento < limiar)

                //Se bateu a condição
                ){
                    elementosMenosAparecem.push(chaveElemento);
                    frequenciasMenosAparecem.push( frequenciElemento );
                    tabelaMenosAparecem[ chaveElemento ] = frequenciElemento;
                }
            }

            if(quantidade != 'todos' && typeof quantidade == 'number'){
            
                let frequenciasMenosAparecemOrdenada = Vectorization.Vector( frequenciasMenosAparecem , {usarEscalares: false})
                                                                   //Ordena do menor pro maior
                                                                   .ordenarDecrescente()
                                                                   //Pega as TOP "quantidade" que MENOS aparecem
                                                                   .ultimos( quantidade );

                let elementosMenosAparecemOrdenado = [];

                //Achar quem são os que tem essas TOP frequencias
                for( let f = 0 ; f < frequenciasMenosAparecemOrdenada.length ; f++ ){

                    const valorFreq = frequenciasMenosAparecemOrdenada.readIndex(f);

                    //Pega todos os elementos que tenham a frequencia "valorFreq". Lembrando que pode ser mais de um, por isso eu filtro por TODOS
                    const chavesFreq = elementosMenosAparecem.filter( ( nomeElemento, indiceElemento )=>{ return tabelaMenosAparecem[ nomeElemento ] == valorFreq } );

                    elementosMenosAparecemOrdenado = elementosMenosAparecemOrdenado.concat(chavesFreq);
                }

                //Uso o "valoresUnicos" para poder remover os elementos repetidos
                return Vectorization.Vector( elementosMenosAparecemOrdenado )
                                    .valoresUnicos();
            }

            return Vectorization.Vector( elementosMenosAparecem );
        }

        informacoesCopiadas.atualizarContagem = function(novosDadosProcurar=null){
            context_informacoesCopiadas.tabelaFrequencias = {};

            if(novosDadosProcurar != null){
                informacoesCopiadas.dadosProcurar = novosDadosProcurar;
                informacoesCopiadas.calcular = novosDadosProcurar;
            }

            if( Vectorization.Vector.isVector(informacoesCopiadas.dadosProcurar) && !Vectorization.Vector.isVectorizationVector(informacoesCopiadas.dadosProcurar) ){
                Vectorization.Vector(informacoesCopiadas.dadosProcurar).paraCadaElemento(function(ii, elementoAtualSublaco, contextoEsteDadosProcurar){
                    const elementoAtual = contextoEsteDadosProcurar.lerIndice(ii);
                    informacoesCopiadas.adicionarInformacao(elementoAtual.obterValor(), null);
                });
    
            }else if(Vectorization.Vector.isVectorizationVector(informacoesCopiadas.dadosProcurar) == true){
                informacoesCopiadas.dadosProcurar.paraCadaElemento(function(ii, elementoAtualSublaco, contextoEsteDadosProcurar){
                    const elementoAtual = contextoEsteDadosProcurar.lerIndice(ii);
                    informacoesCopiadas.adicionarInformacao(elementoAtual.obterValor(), null);
                });
            }
        }

        informacoesCopiadas.atualizarContagem();
        return informacoesCopiadas;
    }

    /**
    * Vai percorrer cada elemento deste Vectorization.Vector, visando contabilizar a quantia de cada elemento que aparece. 
    * Ou seja, a quantidade de cada elemento, caso haja repetiçoes. Similar a um histograma
    */
    context.contabilizarFrequencias = function(valoresBrutos=false){
        let frequenciaComputada = Vectorization.Vector.FrequenciaComputada({
            contextVinculado: context,
            calcular: context.duplicar().valores()
        });

        return valoresBrutos == true ? frequenciaComputada.obterContagens() : frequenciaComputada;
    }

    /**
    * Vai percorrer cada elemento deste Vectorization.Vector, visando contabilizar a quantia de cada elemento que aparece. 
    * Ou seja, a quantidade de cada elemento, caso haja repetiçoes. Similar a um histograma
    * Similar ao context.contabilizarFrequencias
    * porém este contabiliza apenas valores especificos
    * @param {Vectorization.Vector} valoresAnalisar
    */
    context.contabilizarFrequenciasValores = function(valoresAnalisar){
        let frequenciaComputada = Vectorization.Vector.FrequenciaComputada({
            contextVinculado: context,
            calcular: valoresAnalisar
        });

        return frequenciaComputada;
    }

    /**
    * Calcula a moda(valor que mais aparece neste Vector)
    */
    context.moda = function(){
        return context.contabilizarFrequencias().maisAparece();
    }

    /**
    * Calcula a moda(valor que mais aparece neste Vector)
    */
    context.maisAparece = context.moda;

    /**
    * Similar a moda, só que para vários elementos!
    * Pega os elementos que mais aparecem neste Vectorization.Vector.
    * 
    * @param {Number|String} quantidade - Os TOP N frequencias dos elementos que mais aparecem
    * Isso não significa necessariamente que o resultado vai ter essa quantidade de elementos, mais apenas que, ele vai considerar apenas as TOP N frequencias para procurar pelos elementos.
    * 
    * @param {Number|String} limiar - (opcional) A frequencia especifica
    * 
    * @returns {Vectorization.Vector} - os elementos que mais aparecem
    */
    context.maisAparecem = function( quantidade='todos', limiar='media' ){
        return context.contabilizarFrequencias().maisAparecem(quantidade, limiar);
    }

    /**
    * Calcula valor que menos aparece neste Vector
    */
    context.menosAparece = function(){
        return context.contabilizarFrequencias().menosAparece();
    }

    /**
    * Similar ao menosAparece, só que para vários elementos!
    * Pega os elementos que MENOS aparecem neste Vectorization.Vector.
    * 
    * @param {Number|String} quantidade - Os TOP N frequencias dos elementos que MENOS aparecem
    * Isso não significa necessariamente que o resultado vai ter essa quantidade de elementos, mais apenas que, ele vai considerar apenas as TOP N frequencias para procurar pelos elementos.
    * Para explicar melhor, as frequencias serão ordenadas do menor pro maior, e mais TOP N frequencias MAIS ALTAS serão selecionadas.
    * 
    * @param {Number|String} limiar - (opcional) A frequencia especifica
    * 
    * @returns {Vectorization.Vector} - os elementos que MENOS aparecem
    */
    context.menosAparecem = function( quantidade='todos', limiar='media' ){
        return context.contabilizarFrequencias().menosAparecem(quantidade, limiar);
    }

    /**
    * Calcula a correlação deste Vectorization.Vector com a de outro Vectorization.Vector
    */
    context.correlationWith = function( outroVector ){
        return Vectorization.Math.correlation( Vectorization.Vector(context.raw()), outroVector );
    }

    /**
    * Calcula as diferenças com os valores anteriores:
    * 
    * Para cada número no Vector, vai subtrair ele com um número anterior(ou melhor dizendo com o número cujo índice seja "indiceNumero - quantidadeElementosAtraz", caso exista. Se não existir, ele coloca um valor inválido. 
    * Voce pode incluir um parâmetro adicional que permite fazer uma subtração acumulada 
    * 
    * Por exemplo:
    *   V.Vector([10,5,2,50,9]).diferencaValores(1).raw()
    * 
    *      Ele vai retornar: [NaN, -5, -3, 48, -41]
    * 
    * Então, ele vai fazer:
    *   10 - NADA = NADA
    *   5 - 10 = -5
    *   2 - 5 =  -3
    *   50 - 2 = 48
    *   9 - 50 = -41
    * 
    *   NOTA: Ou seja, resultando nesse vetor [NaN, -5, -3, 48, -41]
    * 
    * @param {number} quantidadeElementosAtraz
    * @param {string} acumulacao
    * 
    * @returns {Vectorization.Vector}
    */
    context.diferencaValores = function( quantidadeElementosAtraz, acumulacao="nenhuma" ){
        if( !quantidadeElementosAtraz ){
            throw 'Voce precisa dizer quantos elementos atraz de cada elemento voce quer usar!';
        }

        let vetorResultado = Vectorization.Vector([]);

        context.forEach(function(indiceAtual, valorAtual, contextoEste){

            const indiceAnterior = indiceAtual - Number(quantidadeElementosAtraz);
            const valorAnterior  = context.lerIndice( indiceAnterior );

            if( valorAnterior != undefined ) {
                const subtracaoFeita   = valorAtual - valorAnterior;
                const subtracaoTratada = context.usarEscalares == true ? Vectorization.Scalar(subtracaoFeita) : subtracaoFeita;

                vetorResultado.adicionarElemento( subtracaoTratada );

            //Caso não exista
            }else{
                vetorResultado.adicionarElemento( context.usarEscalares == true ? Vectorization.Scalar( NaN ) : NaN );
            }

        });

        return vetorResultado;
    }

    /**
    * Subfatiar este Vector em varias partes, cada uma com uma CERTA QUANTIDADE FIXA DE ELEMENTOS
    *  
    * Agrupa sequencialmente os números, de acordo com O TAMANHO DA FATIA , por exemplo, se for uma fatia de 7 números, então, ele vai dividir o Vector em subgrupos, cada um tendo 7 números cada.
    * Ou seja, o Vector seria dividido de 7 em 7 números. Ou seja, cada fatia teria 7 números.
    * 
    * NOTA: Cada parte vai ser um novo Vectorization.Vector, contendo números dentro. 
    * 
    * @param {Number} tamanhoFatia - O tamanho das fatias(quantidade de números por fatia)
    * @param {Number} iniciarEm - O indice que ele vai iniciar o fatiamento
    * 
    * Exemplo:
    *   V.Vector([5, 10, 5, 6]).subfatiar(2).soma().raw()
    *       vai retornar: [15, 11]
    *  
    *   o uso do Envelope permite fazer operações mais facilmente.
    * 
    * @returns { Vectorization.Envelope }
    */
    context.subfatiar = function( tamanhoFatia, iniciarEm=0 ){
        if(!tamanhoFatia){
            throw 'Voce precisa definir uma quantidade de números para as fatias!';
        }
        if( tamanhoFatia > context.length ){
            console.warn(`O tamanho de fatia ${tamanhoFatia} é maior do que a quantidade de números deste Vector`);
        }

        let fatiasFeitas = [];
        let indiceFinalFatia = (tamanhoFatia - iniciarEm);;

        for( let indiceAtual = iniciarEm ; indiceAtual < context.length ; indiceAtual += tamanhoFatia ){

            const sliceAtual = context.clonar()
                                      .slice( indiceAtual, indiceFinalFatia );

            indiceFinalFatia = indiceFinalFatia + tamanhoFatia;

            fatiasFeitas.push( sliceAtual );
        }

        return Vectorization.Envelope(fatiasFeitas);
    }
    
    /**
    * Concatena dois Vector(s), retornando um novo Vector contendo a junção desses dois.
    * @param {Vectorization.Vector} outroVector 
    * @returns {Vectorization.Vector}
    */
    context.concat = function( outroVector ){
        return Vectorization.Vector( context.raw().concat( Vectorization.Vector.isVectorizationVector( outroVector ) ? outroVector.raw() : outroVector ), context.classConfig );
    }

    /**
    * Cria varias "áreas deslizantes". Cada área vai ter <N> números.
    * Pode ser usado para calcular médias móveis, desvio padrão movel, variancia movel, etc. 
    * 
    * Em outras palavras, O método 'deslizes' serve para gerar vários deslizes por assim dizer, ou seja, vai deslizando os elementos deste Vector, gerando outros sub Vetores com uma mesma quantidade fixa de elementos, cada parte contendo seu slice atual da posição atual ATÈ a posição atual MAIS O TAMANHO DO PEDAÇO. 
    * O método retorna um objeto Envelope.
    * 
    * @returns {Vectorization.Envelope}
    */
    context.deslizes = function( quantidadeDeslizes=4, incluirIncompletos=false, iniciarEm=0 ){
        let deslizesProntos = Vectorization.Envelope([]);

        if( String(quantidadeDeslizes).indexOf('.') != -1 ){
            throw `O parametro quantidadeDeslizes tem valor '${quantidadeDeslizes}', porém ele precisa ser inteiro!. `;
        }

        if( iniciarEm < 0 ){
            throw `O parametro 'iniciarEm' tem valor ${ iniciarEm }. Porém, ele precisa ser positivo!`;
        }

        if( quantidadeDeslizes < 0 ){
            throw `O parametro 'quantidadeDeslizes' tem valor ${ quantidadeDeslizes }. Porém, ele precisa ser positivo!`;
        }

        if( quantidadeDeslizes == 0 ){
            throw `O parametro 'quantidadeDeslizes' tem valor ${ quantidadeDeslizes }. Porém, ele precisa ser maior que zero!`;
        }

        //Preenche com zeros nos deslizes iniciais
        if( incluirIncompletos == true )
        {
            let primeiroPosicaoQueVaiTerInicio = context.clonar().slice(0, quantidadeDeslizes);
            let posicaoAtualDoInicio = 1;

            for( let i = 0 ; i < primeiroPosicaoQueVaiTerInicio.length-1 ; i++ ){
                let valoresColocarNessaIteracao = primeiroPosicaoQueVaiTerInicio.slice( 0, posicaoAtualDoInicio );
                posicaoAtualDoInicio++;

                let quantosFaltamNessaIteracao = Math.abs( valoresColocarNessaIteracao.raw().length - quantidadeDeslizes );

                let arrayPreencher = Vectorization.Vector( Array( quantosFaltamNessaIteracao ).fill(0) ).concat( valoresColocarNessaIteracao );

                /* 
                NOTAS DE DESENVOLVIMENTO 02/01/2025

                TODO: Identificar quantos faltam para interar a quantidade de 'quantidadeDeslizes'
                TODO: Ir preenchendo a direita os números que faltam
                TODO EXEMPLO:
                [
                    [0, 0, 0, 1]
                    [0, 0, 0, 2]
                    [0, 0, 0, 3]
                    [1, 2, 3, 4]
                    [2, 3, 4, 5]
                    [3, 4, 5, 6]
                    [4, 5, 6, 7]
                    [5, 6, 7, 8]
                    [6, 7, 8, 9]
                    [7, 8, 9, 10]
                    [8, 9, 10, 11]
                    [9, 10, 11, 12]
                    [10, 11, 12, 13]
                ]
                
                BUGS:

                    AO INVEZ DE SER [0, 0, 0, 1]
                                    [0, 0, 0, 2]
                                    [0, 0, 0, 3]
                                    [.... etc]

                    PRECISARIA SER:
                                [0, 0, 0, 1]
                                [0, 0, 1, 2]
                                [0, 1, 2, 3]
                                [.... etc]
                */
                //arrayPreencher.definirElementoNoIndice( primeiroPosicaoQueVaiTerJanela.length-1, primeiroPosicaoQueVaiTerJanela[ 0+i ] );
                
                deslizesProntos.adicionarObjeto( arrayPreencher );
            }
        }

        //Continua para os "delizes" que vão estar completos(que não vão faltar nenhuma amostra)
        for( let i = iniciarEm ; i < context.length ; i++ ){

            //Se a proxima iteração for ultrapassar os limites deste Vector, interompe, pois ja terminou
            if( i + quantidadeDeslizes > context.length ){
                break;
            }

            const sliceAtual = context.clonar()
                                      .slice( i, i + quantidadeDeslizes );

            deslizesProntos.adicionarObjeto( sliceAtual );
        }

        return deslizesProntos;
    }

    /**
    * Calcula a variancia dos números.
    * Baseado em conceitos matemáticos de estatística.
    * 
    * Isso é, mede o quanto os números do Vector estão se afastando da média.
    * Quanto menor o valor, mais perto da média os números desse Vector estão.
    * @returns {Number} - a variancia
    */
    context.variancia = function(){

        /**
        * A média aritmética normal mesmo 
        */
        const mediaVetor = context.media();

        const diferencasAoQuadrado = Vectorization.Vector([]);

        /**
        * Para cada número dentro deste Vector 
        */
        context.paraCadaElemento(function( indiceElemento, numeroAtual ){

            const subtracao = numeroAtual - mediaVetor;

            /**
            * Adiciona a subtração atual no vetor 'diferencasAoQuadrado'
            */
            diferencasAoQuadrado.adicionarElemento( Math.pow(subtracao, 2 ) );

        });

        const qtdeElementosVetor = context.tamanho();
        const variancia          = diferencasAoQuadrado.soma() / ( qtdeElementosVetor-1 );

        return variancia;
    }

    /**
    * Calcula o desvio padrão.
    * Baseado nos conceitos estatísticos de variância.
    * 
    * Desvio padrão significa o quanto os números do Vector estão se afastando da média.
    * Quanto menor o valor, mais perto da média os números desse Vector estão.
    * 
    * NOTA: Muito semelhante à variancia. É basicamente uma maneira diferente de ver a variancia. 
    */
    context.desvioPadrao = function(){
        return Math.sqrt( context.variancia() );
    }

    /**
    * Método que converte este Vectorization.Vector para um Vectorization.Vector avançado, onde cada elemento dentro do mesmo é um Vectorization.Scalar
    */
    context._vectorElementos2Escalares = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            context.content[i] = Vectorization.Scalar(context.content[i], extraPropsOfLine);
        }
    }

    if( context.configRecebidaUsuario['usarEscalares'] != undefined || classConfig['usarEscalares'] != undefined ){
        if( context.configRecebidaUsuario['usarEscalares'] == true || classConfig['usarEscalares'] == true )
        {
            context.usarEscalares = true;
            context._vectorElementos2Escalares();
        }
    }

    context._doDefaultBaseAfterCreate();

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //Aplica arredondamentos, se o usuario desejar, mesmo não sendo um Vectorization.Vector aleatorio
    if( context._config != undefined &&
        (
            context._config['aleatorio'] == undefined || context._config['aleatorio'] == false
        ) == true && 
        (
            context._config['arredondar'] != undefined ||
            context.configRecebidaUsuario['arredondar'] != undefined
        ) == true
    ){
        context.aplicarArredondamento(
            context._config['arredondar'] != undefined ? context._config['arredondar'] : context.configRecebidaUsuario['arredondar'] 
        );
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (config['bloqueado'] != undefined || classConfig['bloqueado'] != undefined) ? (config['bloqueado'] || classConfig['bloqueado']) : false;

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    if( context._isBloqueado() == true ){
        context.bloquearModificacoes();
    }

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    //Se tiver uma função a ser aplicada por cima de tudo
    if( config['funcaoAplicar'] != undefined || classConfig['funcaoAplicar'] != undefined ){
        context.aplicarFuncao( config['funcaoAplicar'] || classConfig['funcaoAplicar'] );
    }

    //return context;
    //Cria um Proxy para permitir acessar os indices do vetor diretamente
    return new Proxy(context, {
        get: function(target, prop, receiver) {
          if (typeof prop === 'string' && !isNaN(prop)) {
            return target.content[Number(prop)];
          }
          return Reflect.get(target, prop, receiver);
        },

        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
          if( target._isBloqueado() == true ){
             throw 'Este Vectorization.Vector está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
             throw 'Você não pode modificar esta atributo do Vectorization.Vector!';
          }

          if (typeof prop === 'string' && !isNaN(prop)) {
            target.content[Number(prop)] = value;
            return true;
          }
          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Vector.isVector = function(obj){
    if( obj == undefined ){ return false };
    return ((obj.objectName != undefined && obj.objectName == 'Vector') || 
           Array.isArray(obj)) ? true : false;
}

window.Vectorization.Vector.isVectorizationVector = function(obj){
    if( obj == undefined ){ return false };
    return (obj.objectName != undefined && obj.objectName == 'Vector')
}

module.exports = window.Vectorization.Vector;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Vector.js*/
/* ARQUIVO VECTORIZATION: ../src/Vector-translation.js*/
/*
 * File Name: Vector-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Vector._translations = function(){
    const translatedMethods = {
        //English
        "dotProduct": "produtoEscalar",

        "dotProductMatrix": "produtoEscalarMatrix",

        "dotProductVector": "produtoEscalarVector",

        "multiplyMatrix": "multiplicarMatrix",

        "multiplyNumber": "multiplicarNumero",

        "multiplyVector": "multiplicarVetor",

        "addMatrix": "somarMatrix",

        "addNumber": "somarNumero",

        "addVector": "somarVetor",

        "subtractMatrix": "subtrairMatrix",

        "subtractNumber": "subtrairNumero",

        "subtractVector": "subtrairVetor",

        "divideMatrix": "dividirMatrix",

        "divideNumber": "dividirNumero",

        "divideVector": "dividirVetor",

        "powMatrix": "elevarMatrix",

        "powNumber": "elevarNumero",

        "powVector": "elevarVetor",

        "transposed": "tranposta",

        "oppostMatrix": "matrixOposta",

        "identity": "identidade",

        "filter": "filtrar",

        "blockModifications": "bloquearModificacoes",
        "unblockModifications": "desbloquearModificacoes",

        "findMin": "valorMinimo",
        "findMax": "valorMaximo",
        "sortAscending": "ordenarCrescente",
        "sortDescending": "ordenarDecrescente",
        "mapFunction": "aplicarFuncao",
        "unicalValues": "valoresUnicos",

        //Portugues
        "somarMatriz": "somarMatrix",
        "subtrairMatriz": "subtrairMatrix",
        "multiplicarMatriz": "multiplicarMatrix",
        "elevarMatriz": "elevarMatrix",
        "produtoEscalarMatriz": "produtoEscalarMatrix",
        
        "paraCadaElemento": "forEach",
        "adicionarElemento": "push",
        "mapearValores": "map",
        "filtrarValores": "filtrar",
        "lerIndice": "readIndex",
        "getIndice": "readIndex",
        "bloquear": "bloquearModificacoes",
        "desbloquear": "desbloquearModificacoes",
        "indiceDe": "indexOf",
        "encontrarIndiceDe": "indexOf",
        "encontrarIndice": "indexOf",
        "ordemCrescente": "ordenarCrescente",
        "ordemDecrescente": "ordenarDecrescente",
        "isOrdemCrescente": "isOrdenadoCrescente",
        "isOrdemDecrescente": "isOrdenadoDecrescente",

        "subdividir": "dividirEmPartes",

        "contarFrequencias": "contabilizarFrequencias",
        "frequencias": "contabilizarFrequencias"
    };

    const translatedAttributes = {
        //English
        "blocked": "bloqueado",
        "allowBlock": "permitirBloquear",
        "allowUnblock": "permitirDesbloquear",
        "mapUsingFunction": "funcaoAplicar",

        //Portugues
        "valorPreencher": "fillValue",
        "elementos": "length",
        "conteudo": "numeros"
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Vector._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Vector-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/StringVector.js*/
/*
 * File Name: StringVector.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    require('./Root'); 
    require('./Scalar');
    require('./Vector');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringVector = function( config=[], classConfig={} ){
    //Por padrão o usarEscalares vai ser true
    if( config['usarTextos'] == undefined && classConfig['usarTextos'] == undefined && config['usarTextos'] != false && classConfig['usarTextos'] != false ){
        config['usarTextos'] = true;
    }
    
    //Define a tradução
    classConfig['translations'] = window.Vectorization.StringVector._translations || null;

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Este Vectorization.StringVector NÂO usa números, em vez disso, ele é especifico pra texto
    classConfig['usarEscalares'] = false;

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.StringVector.isStringVector(config) && config.objectName == 'StringVector' ){
        return Vectorization.StringVector( config.values() );
    }

    //O StringVector será baseado no Vectorization.Vector
    let context = window.Vectorization.Vector(config, classConfig);
    context.objectName = 'StringVector';
    context.extendedFrom = 'Vector';
    context.path = 'Vectorization.StringVector';
    context.configRecebidaUsuario = config;

    context.letrasMaiusculas = function(){
        let novoStringVector = Vectorization.StringVector([]);
        let contextoMetodo = this instanceof Window ? context : this; 
        
        //Usei o this acima pois isso permite herdar este código em outro objeto
        contextoMetodo.paraCadaElemento(function(i){
            novoStringVector.adicionarElemento( contextoMetodo.lerIndice(i).letrasMaiusculas() );
        });

        return novoStringVector;
    }
    context.toUpperCase = context.letrasMaiusculas;


    context.letrasMinusculas = function(){
        let novoStringVector = Vectorization.StringVector([]);
        let contextoMetodo = this instanceof Window ? context : this; 

        //Usei o this acima pois isso permite herdar este código em outro objeto
        contextoMetodo.paraCadaElemento(function(i){
            novoStringVector.adicionarElemento( contextoMetodo.lerIndice(i).letrasMinusculas() );
        });

        return novoStringVector;
    }
    context.toLowerCase = context.letrasMinusculas;

    
    /**
     * Retorna um Vectorization.Vector, contendo as distancias hamming de cada elemento Vectorizaion.Text
     * @param {Vectorization.StringVector} outroStringVector 
     * @returns {Vectorization.Vector}
     */
    context.distanciaPalavras = function(outroStringVector){
        let distancias = Vectorization.Vector([]);
        let contextoMetodo = this instanceof Window ? context : this; 

        //Usei o this acima pois isso permite herdar este código em outro objeto
        contextoMetodo.paraCadaElemento(function(i){
            let elementoAtual_esteStringVector = contextoMetodo.lerIndice(i),
                elementoAtual_outroStringVector = ( Vectorization.StringVector.isVectorizationStringVector(outroStringVector) == false ? Vectorization.StringVector(outroStringVector) : outroStringVector ).lerIndice(i);

            if( elementoAtual_outroStringVector != undefined ){
                let distanciaElementoIndiceAtual = Vectorization.Text(elementoAtual_esteStringVector)
                                                  .distanciaHamming( Vectorization.Text(elementoAtual_outroStringVector) )
                
                distancias.adicionarElemento( distanciaElementoIndiceAtual );

            }else{
                distancias.adicionarElemento( 1 );
            }
        });

        return distancias;
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    /**
    * Método que converte este Vectorization.StringVector para um Vectorization.StringVector avançado, onde cada elemento dentro do mesmo é um Vectorization.Text
    */
    context._vectorElementos2Textos = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            context.content[i] = Vectorization.Text(context.content[i], extraPropsOfLine);
        }
    }

    /**
    * @override
    * @returns {Array}
    */
    context.toArray = function(){
        if( context.usarTextos != undefined && context.usarTextos == true )
        {
            let valoresSemEstarEmTextos = [];
            context.paraCadaElemento(function(i, objetoTexto){
                valoresSemEstarEmTextos.push( objetoTexto.obterValor() );
            });

            return valoresSemEstarEmTextos;

        }else{
            return context.content;
        }
    }
    /**
    * @override
    * @returns {Array}
    */
    context.raw = context.toArray;

    if( context.configRecebidaUsuario['usarTextos'] != undefined || classConfig['usarTextos'] != undefined ){
        if( context.configRecebidaUsuario['usarTextos'] == true || classConfig['usarTextos'] == true )
        {
            context.usarTextos = true;
            context._vectorElementos2Textos();
        }
    }

    //Se tiver uma função a ser aplicada por cima de tudo
    if( config['funcaoAplicar'] != undefined || classConfig['funcaoAplicar'] != undefined ){
        context.aplicarFuncao( config['funcaoAplicar'] || classConfig['funcaoAplicar'] );
    }

    return context;
};

/**
* Métodos estáticos
*/
window.Vectorization.StringVector.isStringVector = function(obj){
    return ((obj.objectName != undefined && (obj.objectName == 'StringVector' || obj.objectName == 'Vector')) || 
           Array.isArray(obj)) ? true : false;
}

window.Vectorization.StringVector.isVectorizationStringVector = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'StringVector' )
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringVector.js*/
/* ARQUIVO VECTORIZATION: ../src/StringVector-translation.js*/
/*
 * File Name: StringVector-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringVector._translations = function(){
    const translatedMethods = {
        
    };

    const translatedAttributes = {
        
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.StringVector._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringVector-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/BendableVector.js*/
/*
 * File Name: BendableVector.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    require('./Root'); 
    require('./Scalar');
    require('./Vector');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.BendableVector = function( config=[], classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.BendableVector._translations || null;

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Este Vectorization.BendableVector NÂO usa números, em vez disso, vamos especificar o que queremos
    classConfig['usarEscalares'] = false;

    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.BendableVector.isVectorizationBendableVector(config) && config.objectName == 'BendableVector' ){
        return Vectorization.BendableVector( config.values(), classConfig );
    }

    //O StringVector será baseado no Vectorization.Vector
    let context = window.Vectorization.Vector(config, classConfig);
    context.objectName = 'BendableVector';
    context.extendedFrom = 'Vector';
    context.path = 'Vectorization.BendableVector';
    context.configRecebidaUsuario = config;
    
    context.storedClassConfig = classConfig || {};

    context.flexibilidade = classConfig['flexibilidade'] || false;

    //Mais opções de flexibilidade
    if( context.flexibilidade != undefined )
    {
        //Se for apenas um texto, com o nome do tipo, ele trata isso aqui
        if( typeof context.flexibilidade == 'string' ){
            context.flexibilidade = [ context.flexibilidade ];
        }

        //Se o usuario passar um array contendo apenas um elemento, ele vai usar ele como tipo para todos os elementos deste Vectorization.BendableVector
        if( context.flexibilidade instanceof Array && context.flexibilidade.length == 1 && context.content.length > 1 )
        {
            
            for( let i = 0 ; i < context.content.length-1 ; i++ )
            {
                //Completa com o tipo que veio
                context.flexibilidade.push(context.flexibilidade[0]);
            }

        }
    }

    if( context.flexibilidade ){
        if( context.flexibilidade.length != context.content.length ){
            throw 'o array flexibilidade precisa conter a mesma quantidade de elementos deste Vectorization.Vector'
        }
    }

    if( context.flexibilidade ){
        //Verifica se todos são do tipo Vectorization.Text
        context.isTudoTexto = Vectorization.StringVector( Vectorization.isAlgumVetorVectorization(context.flexibilidade) ? [... context.flexibilidade.raw()] : [... context.flexibilidade] ).todosIguaisA('Text');
        
    }else{
        context.isTudoTexto = null;
    }

    //Se for tudo texto
    if( context.isTudoTexto == true ){
        context.herdarFuncoes( Vectorization.StringVector );
    }

    context.toText = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        return Vectorization.StringVector( context.raw(), novasConfiguracoes);
    }

    context.toScalar = function(){
        let novasConfiguracoes = {... context.storedClassConfig};
        novasConfiguracoes['usarEscalares'] = true;

        return Vectorization.Vector( context.raw(), novasConfiguracoes );
    }

    /**
    * @override
    * @param {Boolean} includeNamespace 
    * @returns {Array}
    */
    context.obterTiposRapido = function(includeNamespace=false){
        let tiposUsados = [];
        context.paraCadaElemento(function(i, elementoAtual){
            if( includeNamespace == true ){
                tiposUsados.push( 'Vectorization.' + String(elementoAtual.objectName) );

            }else{
                tiposUsados.push( String(elementoAtual.objectName) );
            }
        });

        return tiposUsados;
    }

    /**
    * @override 
    */
    context.rawProfundo = function(){
        
        if( (elementoAtual) => Vectorization.Scalar.isScalar(elementoAtual) == true || 
                               Vectorization.Text.isText(elementoAtual) == true ||
                               Vectorization.Boolean.isBoolean(elementoAtual) == true 
                            
        ){
            let valoresSemEstarEmEscalar = [];
            context.paraCadaElemento(function(i, objetoEscalar){

                if( Vectorization.Scalar.isScalar(objetoEscalar) || 
                    Vectorization.Text.isText(objetoEscalar) ||
                    Vectorization.Boolean.isBoolean(objetoEscalar) 

                ){
                    if( objetoEscalar.obterValor != undefined )
                    {
                        valoresSemEstarEmEscalar.push( objetoEscalar.obterValor() );

                    }else{
                        valoresSemEstarEmEscalar.push( objetoEscalar );
                    }

                }else{
                    valoresSemEstarEmEscalar.push( objetoEscalar );
                }
            });

            return valoresSemEstarEmEscalar;

        }else{
            return context.content;
        }

    }

    /**
    * @override
    * Permite fatiar(ou recortar) este vetor
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Vector} - o vetor recortado
    */
    context.slice = function(elementoInicial, elementoFinal, intervalo=1){
        let dadosRecortados = [];

        if( elementoInicial < 0 ){
            throw 'A elementoInicial precisa ser maior ou igual a zero!';
        }

        if( elementoFinal > context.length ){
            throw 'A elementoFinal precisa estar dentro da faixa de valores do Vector! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        let quantosForam = 0;
        for( let i = elementoInicial ; i < elementoFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.readIndex(i) );
            quantosForam = quantosForam + 1;
        }

        let quantidadeFalta = Math.abs(dadosRecortados.length - context.flexibilidade.length);
        let flexibilidadeAjustada = [... context.flexibilidade];

        if( context.flexibilidade.length < quantidadeFalta ){
            for( let i = 0 ; i < quantidadeFalta ; i++ ){
                //Completa com um tipo de dado qualquer
                flexibilidadeAjustada.push('texto');
            }
        }

        let novoVetorCriado = Vectorization.BendableVector(dadosRecortados, {
            flexibilidade: flexibilidadeAjustada
        } );

        return novoVetorCriado;
    }

    /**
    * @override
    * Obtem um novo Vector exatamente igual a este Vector
    * Ou seja, faz uma copia do propio objeto, identido, porém sem manter as referencias. 
    * @returns {Vectorization.Vector}
    */
    context.duplicar = function(){
        let novoVector = [];
        
        for( let i = 0 ; i < context.length ; i++ )
        {
            novoVector.push( context.readIndex(i) );
        }

        //Pra ser compativel com este Vectorization.BendableVector
        let extraPropsOfLine = {};
        if( context.flexibilidade ){
            extraPropsOfLine['flexibilidade'] = context.flexibilidade;
        }

        return Vectorization.BendableVector(novoVector, extraPropsOfLine);
    }

    /**
    * @override
    * Vai percorrer cada elemento deste Vectorization.Vector, visando localizar elementos que aparecem mais de uma vez.
    * E com isso, ele vai remover tais repetições de elementos, retornando um novo Vectorization.Vector que não contenha duplicidade. 
    * @returns {Vectorization.BendableVector} 
    */
    context.valoresUnicos = function(){
        const esteVetorCopiado = context.duplicar();
        const jaFoi = {};
        
        //Pra ser compativel com este Vectorization.BendableVector
        let extraPropsOfLine = {};
        //if( context.flexibilidade ){
        //    extraPropsOfLine['flexibilidade'] = context.flexibilidade;
        //}

        let novoVetor_sem_repeticoes = Vectorization.BendableVector([], extraPropsOfLine);

        esteVetorCopiado.paraCadaElemento(function(i){
            let elementoAtual = esteVetorCopiado.readIndex(i);

            if( jaFoi[ elementoAtual ] == undefined )
            {
                novoVetor_sem_repeticoes.adicionarElemento(elementoAtual);
                jaFoi[ elementoAtual ] = true;
            }
        });

        return novoVetor_sem_repeticoes;
    }

    //Alias for duplicar
    context.clonar = context.duplicar;

    /**
    * Método que converte este Vectorization.Vector para um Vectorization.Vector avançado, onde não importa qual o tipo de valor usado
    */
    context._vectorElementos2Flexibilidade = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};

            //context.content[i] = 'vamos identificar abaixo';
            switch( Vectorization.isAlgumValorVectorization( context.flexibilidade[i] ) ? context.flexibilidade[i].raw() : context.flexibilidade[i] ){
                case 'Escalar':
                case 'Scalar':
                case 'Number':
                case 'Numero':
                case 'numero':
                case 'escalar':
                    context.content[i] = Vectorization.Scalar(context.content[i], extraPropsOfLine);
                    break;

                case 'texto':
                case 'Texto':
                case 'Text':
                case 'String':
                case 'Letras':
                    context.content[i] = Vectorization.Text(context.content[i], extraPropsOfLine);
                    break;

                case 'booleano':
                case 'Booleano':
                case 'Boolean':
                case 'boolean':
                case 'Logico':
                    context.content[i] = Vectorization.Boolean(context.content[i], extraPropsOfLine);
                    break;

                default:
                    throw 'Tipo não aceito';
            }
        }
    }

    context._vectorElementos2Flexibilidade();

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //Se tiver uma função a ser aplicada por cima de tudo
    if( config['funcaoAplicar'] != undefined || classConfig['funcaoAplicar'] != undefined ){
        context.aplicarFuncao( config['funcaoAplicar'] || classConfig['funcaoAplicar'] );
    }

    return context;
};

/**
* Métodos estáticos
*/
window.Vectorization.BendableVector.isBendableVector = function(obj){
    if( obj == undefined ){ return false };
    return ((obj.objectName != undefined && (obj.objectName == 'BendableVector' || obj.objectName == 'Vector')) || 
           Array.isArray(obj)) ? true : false;
}

window.Vectorization.BendableVector.isVectorizationBendableVector = function(obj){
    if( obj == undefined ){ return false };
    return (obj.objectName != undefined && obj.objectName == 'BendableVector' )
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/BendableVector.js*/
/* ARQUIVO VECTORIZATION: ../src/BendableVector-translation.js*/
/**
 * File Name: BendableVector-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.BendableVector._translations = function(){
    const translatedMethods = {
        
    };

    const translatedAttributes = {
        
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.BendableVector._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/BendableVector-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Matrix.js*/
/*
 * File Name: Matrix.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    require('./Root');
    require('./Scalar');
    require('./Vector');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Matrix = function( config, classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Matrix._translations || null;

    let classeBaseMatrix = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseMatrix.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    //Se o usuario tentar criar uma matrix a partir de outra matrix, ele recria a propio matrix passada, mantendo a estrutura como ainda sendo uma Matrix
    if( Vectorization.Matrix.isMatrix(config) && config.objectName == 'Matrix' ){
        return Vectorization.Matrix( config.raw() );
    }

    let context = window.Vectorization.Base(classConfig);
    context.objectName = 'Matrix';
    context.path = 'Vectorization.Matrix';
    
    context.configRecebidaUsuario = config;

    context.storedClassConfig = classConfig || {};

    //Aplica a tradução dos atributos, pra ser capaz de entender nomes de atributos em outros idiomas
    //classConfig = context.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Aplica a tradução dos atributos também no config, EXCETO SE config FOR UM ARRAY
    if( config instanceof Object && !(config instanceof Array && (config[0] instanceof Array || Vectorization.Vector.isVector(config[0]) || Vectorization.BendableVector.isVectorizationBendableVector(config[0]) )) ){
        config = context.translateAttributes_andReturn(config, classConfig['translations']() );
    }


    context.rows = config['rows'];
    context.columns = config['columns'];
    context.initialColumnValue = config['fillValue'] || 0;
    context.flexivel = config['flexibilidade'] || classConfig['flexibilidade'] || null;

    //Mais opções de flexibilidade
    if( context.flexivel != undefined && 
        config.length > 0 && 
        config[0] != undefined 
    ){
        //Se for apenas um texto, com o nome do tipo, ele trata isso aqui
        if( typeof context.flexivel == 'string' ){
            context.flexivel = [ context.flexivel ];
        }

        //Se o usuario passar um array contendo apenas um elemento, ele vai usar ele como tipo para todos os elementos deste Vectorization.BendableVector
        if( context.flexivel instanceof Array && context.flexivel.length == 1 && config[0].length > 1 )
        {
            
            for( let i = 0 ; i < config[0].length-1 ; i++ )
            {
                //Completa com o tipo que veio
                context.flexivel.push(context.flexivel[0]);
            }

        }
    }

    context.isFlexivelNasColunas = context.flexivel != undefined && context.flexivel != null ? true : false;

    context.content = [];

    context.permitirDesbloquear = (classConfig['permitirDesbloquear'] != undefined) ? (classConfig['permitirDesbloquear']) : true;
    context.permitirBloquear = (classConfig['permitirBloquear'] != undefined) ? (classConfig['permitirBloquear']) : true;

    context._isBloqueado = function(){
        if( context.bloqueado != undefined && context.bloqueado == true ){
            return true;
        }
        return false;
    }

    context.bloquearModificacoes = function(){
        if( context.permitirBloquear == true ){
            context.bloqueado = true;

            if(context.isAdvancedMatrix == true)
            {
                //Bloquear também os filhos Vectorization.Vector dentro deste Vectorization.Matrix
                context.paraCadaLinha(function(i, elementoVetorLinhaMatrix){
                    elementoVetorLinhaMatrix.bloquearModificacoes();
                });
            }

        }else{
            throw 'Ação não permitida para este Vectorization.Matrix!';
        }
    }

    context.desbloquearModificacoes = function(){
        if( context.permitirDesbloquear == true ){
            context.bloqueado = false;

            if(context.isAdvancedMatrix == true)
            {
                //Desbloquear também os filhos Vectorization.Vector dentro deste Vectorization.Matrix
                context.paraCadaLinha(function(i, elementoVetorLinhaMatrix){
                    elementoVetorLinhaMatrix.desbloquearModificacoes();
                });
            }
        }else{
            throw 'Ação não permitida para este Vectorization.Matrix!';
        }
    }

    /**
    * Atualiza a quantidade de linhas e colunas
    */
    context.atualizarQuantidadeColunasLinhas = function(){
        //Atualiza a quantidade das colunas
        context.columns = context.calcTamanhos().lerIndice(1);
        context.colunas = context.columns;

        //Atualiza a quantidade de linhas
        context.rows    = context.content.length; 
        context.linhas  = context.rows;
    }

    //Alguns atributos uteis
    context.isTransposta = classConfig['isTransposta'] || false;
    context.isOposta = classConfig['isOposta'] || false;
    context.isIdentidade = classConfig['isIdentidade'] || false;
    context.isAdvancedMatrix = classConfig['advanced'] || true;

    if( classConfig['advanced'] == false ){
        context.isAdvancedMatrix = false;
    }

    //Se passar diretamente o conteudo
    if( config instanceof Array && (config[0] instanceof Array || Vectorization.Vector.isVector(config[0]) || Vectorization.BendableVector.isVectorizationBendableVector(config[0]) ) ){

        //Se as linhas forem vetores do pacote Vectorization
        if( Vectorization.Vector.isVectorizationVector( config[0] ) == true ||
            Vectorization.BendableVector.isVectorizationBendableVector( config[0] ) == true
        ){
            context.content = config;
            context.rows = config.length;
            context.columns = config[0].length;

        //Se as linhas forem vetores normais
        }else{
            context.content = config;
            context.rows = config.length;
            context.columns = config[0].length;
        }

    //Ou caso contrario
    }else{
        //Inicializa a matrix
        for( let i = 0 ; i < context.rows ; i++ )
        {
            context.content[i] = [];
            for( let j = 0 ; j < context.columns ; j++ )
            {
                context.content[i][j] = context.initialColumnValue;
            }
        }

        /**
        * 25/07/2024 16:55 PM
        *  BUG CORRIGIDO:
        *    se o objeto for uma lista de objetos Vectorization.Vector, da certo
        *    AGORA se o objeto for um Vectorization.Vector que contem outros Vectorization.Vector
        *    dava erro na linha 251
        */
        //Se a matrix nao foi inicializada E SE FOR UM VETOR DO VECTORIZATION QUE CONTEM OUTROS VETORES DO VECTORIZATION
        if( context.rows == undefined && Vectorization.Vector.isVectorizationVector(config) ){
            context.content = config.raw();
            context.rows = config.length;
            context.columns = config.lerIndice(0).length;
        }
    }


    //Também, se o config for um objeto(NÂO FOR UM ARRAY)
    if( config instanceof Object && !(config instanceof Array && (config instanceof Array || Vectorization.Vector.isVector(config) )) ){
        context.aleatorio = config['aleatorio'] || false;

        if( config['aleatorio'] != undefined &&
            config['numeros'] != undefined
        ){
            throw 'Voce não pode criar um Vectorization.Matrix com contéudo definido, e ao mesmo tempo sendo aleatório!';
        }
        
        if( context.aleatorio == true ){
            context.content = []; // Zero o conteudo

            //Se tem outros detalhes
            if( config['minimo'] != undefined && 
                config['maximo'] != undefined && 
                config['linhas'] != undefined &&
                config['colunas'] != undefined &&
                typeof config['minimo'] == 'number' &&
                typeof config['maximo'] == 'number' &&
                typeof context.rows == 'number' &&
                typeof context.columns == 'number'
            ){
                //Grava os parametros
                context.minimoAleatorio = config['minimo'];
                context.maximoAleatorio = config['maximo'];

                //Se tiver um número base
                if( config['sementeAleatoria'] != undefined &&
                    typeof config['sementeAleatoria'] == 'number'
                ){
                    context.sementeAleatoria = config['sementeAleatoria'];
                }else{
                    context.sementeAleatoria = Vectorization.Random._sementeDefinida;
                }

                //Vai gerando os valores aleatorios enquanto não terminar a quantidade de elementos
                Vectorization.Vector({
                    valorPreencher: 1,
                    elementos: context.rows

                }).paraCadaElemento(function(iLinhaMatrix, linhaMatrix){
                    let objLinhaMatrix = linhaMatrix;
                    context.content[iLinhaMatrix] = [];

                    Vectorization.Vector({
                        valorPreencher: 1,
                        elementos: context.columns

                    }).paraCadaElemento(function(jColunaMatrix, colunaMatrix){
                        let objColunaMatrix = colunaMatrix;
                        
                        let numeroAleatorioGeradoParaOIndice = Vectorization.Random.gerarNumeroAleatorio( Number(context.minimoAleatorio), Number(context.maximoAleatorio), context.sementeAleatoria );
                        context.content[iLinhaMatrix][jColunaMatrix] = numeroAleatorioGeradoParaOIndice;
                    });
                });

                //Se o programador quiser arredondar
                if( config['arredondar'] != undefined ){
                    Vectorization.Vector({
                        valorPreencher: 1,
                        elementos: context.rows
    
                    }).paraCadaElemento(function(iLinhaMatrix, linhaMatrix){
                        let objLinhaMatrix = context.content[iLinhaMatrix];

                        if( Vectorization.Vector.isVector(objLinhaMatrix) &&
                            Vectorization.Vector.isVectorizationVector(objLinhaMatrix)
                        ){
                           objLinhaMatrix.aplicarArredondamento(config['arredondar']);

                        }else{
                            if( Vectorization.Vector.isVector(objLinhaMatrix) )
                            {
                                let valoresObtidos = Vectorization.Vector(objLinhaMatrix).getValoresArredondados(config['arredondar']);
                                
                                for( let i = 0 ; i < valoresObtidos.tamanho() ; i++ )
                                {
                                    objLinhaMatrix[i] = valoresObtidos.readIndex(i);
                                }
                            }
                        }
                    });
                }

            }else{
                if( typeof config['minimo'] != 'number' ||
                    typeof config['maximo'] != 'number' ||
                    typeof context.rows != 'number' || 
                    typeof context.columns != 'number'
                ){
                    throw 'Os valores minimo, máximo e quantidade de elementos das linhas e colunas precisam ser números!. Tipo não permitido.'
                
                }else{
                    throw 'Para criar uma Matrix aleatório voce precisar passar a faixa de valores e a quantidade de elementos nas linhas e colunas!';
                }
            }

        }else if(context.aleatorio == false){
        
            if( config['numeros'] != undefined &&
                Vectorization.Vector.isVector(config['numeros'])
            ){
                if( config['aleatorio'] != undefined ){
                    throw 'Voce não pode criar um Vectorization.Matrix com contéudo definido, e ao mesmo tempo sendo aleatório!';
                }

                context.content = config['numeros'] != undefined ? 
                                  (Vectorization.Matrix.isVectorizationMatrix(config['numeros']) ? config['numeros'].valores() : 
                                   config['numeros']) : [];
            }

            context.conteudo = context.content;

            if( config['numeros'] != undefined )
            {
                context.rows = config['numeros'].length;
                context.columns = config['numeros'][0].length;

            }else{
                context.rows = context.content.length;
                
                if( context.content[0] != undefined ){
                    context.columns = context.content[0].length;
                }else{
                    context.columns = 0;
                }
            }
        }
    }


    //Alias em portugues
    context.linhas = context.rows;
    context.colunas = context.columns;
    context.conteudo = context.content;

    //Uma matriz simples nunca vai ser profunda
    context.matrixProfunda = false;

    /**
    * Método que converte a matrix para uma matrix avançada, onde cada linha é um Vector 
    */
    context._matrix2Advanced = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            extraPropsOfLine['index'] = i;
            extraPropsOfLine['_pai']  = context; 

            if( context.isFlexivelNasColunas == true ){
                if( Vectorization.Vector.isVector(context.flexivel) ){
                    extraPropsOfLine['flexibilidade'] = [... context.flexivel];

                }else{
                    extraPropsOfLine['flexibilidade'] = context.flexivel;
                }

                context.content[i] = Vectorization.BendableVector(context.content[i], extraPropsOfLine);

            }else{
                context.content[i] = Vectorization.Vector(context.content[i], extraPropsOfLine);
            }

        }
        context.isAdvancedMatrix = true;
    }

    context.adicionarVetorComoColuna = function(vectorAdicionar){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        if( context.isAdvancedMatrix ){
            if( context.isFlexivelNasColunas == false ){
                context.content.push( vectorAdicionar );

            }else{
                context.content.push( vectorAdicionar );
            }

        }else{
            if( context.isFlexivelNasColunas == false ){
                context.content.push( vectorAdicionar );

            }else{
                context.content.push( vectorAdicionar );
            }
        }

        if( context.content != undefined ){
            context.rows = context.content.length;
        }

        if( context.content != undefined && 
            context.columns[0] != undefined
        ){
            context.columns = context.columns[0].length;
        }
    }

    /**
    * Obtem uma nova matriz exatamente igual a esta matrix.
    * Ou seja, faz um copia do propio objeto, identico, porém sem manter as referencias. 
    * @returns {Vectorization.Matrix}
    */
    context.duplicar = function(){
        let novaMatrix = [];
        let novaMatrix_Matrix = null; //Se for necessario

        if( context.isFlexivelNasColunas == true ){
            //Nesse caso foi necessario usar o novaMatrix_Matrix como Vectorization.Matrix
            novaMatrix_Matrix = Vectorization.Matrix([], {
                flexibilidade: context.flexivel
            });
        }

        for( let i = 0 ; i < context.rows ; i++ )
        {
            if( context.isFlexivelNasColunas == false ){
                novaMatrix.push( Vectorization.Vector(context.getLinha(i)).clonar() );

            }else{
                novaMatrix_Matrix.adicionarVetorComoColuna( Vectorization.BendableVector(context.getLinha(i), {
                    flexibilidade: context.flexivel
                }).clonar() );
            }
        }

        return context.isFlexivelNasColunas == false ? Vectorization.Matrix(novaMatrix) : 
                                                       novaMatrix_Matrix;
    }

    //Alias for duplicar
    context.clonar = context.duplicar;

    /**
    * Calcula a forma (shape) da matrix
    * @returns {Array} - A forma da matrix.
    */
    context.calcTamanhos = function() {
        let dadosMatrix = context.content || [];
        let formato = [];
        let nivelAtual = [... dadosMatrix.copyWithin()];

        while ( Vectorization.Vector.isVector(nivelAtual) ) 
        {
            formato.push(nivelAtual.length);
            nivelAtual = nivelAtual[0];
            if(nivelAtual == undefined){
                break;
            }
        }

        return Vectorization.Vector(formato);
    }

    //Alias for calcTamanhos
    context.calcSizes = context.calcTamanhos;
    context.calcShape = context.calcTamanhos;
    context.calcFormato = context.calcTamanhos;
    context.getFormato = context.calcTamanhos;

    /*
    Calcula o formato da matrix e armazena no objeto sizes
    Por padrão o formato vai ser [qtdeLinhas, qtdeColunas]
    */
    context.sizes = context.calcTamanhos();
    context.formato = context.sizes;

    context.tamanho = function(){
        return context.sizes;
    }

    /**
    * Verifica se esta matrix possui exatamente o mesmo formato de outra matrix
    * @param {Vectorization.Matrix} matrixB - A outra matrix.
    * @returns {Boolean} - Verdadeiro se as formas forem iguais, falso caso contrário.
    */
    context.isExatoMesmoTamanho = function(matrixB){
        if( context.calcTamanhos().isExatamenteIgual( matrixB.calcTamanhos() ) ){
            return true;
        }

        return false;
    }

    //Alias for isExatoMesmoTamanho
    context.isExatamenteMesmoTamanho = context.isExatoMesmoTamanho;
    context.isExatamenteMesmoFormato = context.isExatoMesmoTamanho;
    context.isMesmoTamanhoDe = context.isExatoMesmoTamanho;
    context.isMesmoFormatoDe = context.isExatoMesmoTamanho;
    context.isSameSizes = context.isExatoMesmoTamanho;

    /**
    * Compara se o contéudo desta matrix é exatamente igual ao contéudo da outra matrix  
    * Ele faz isso comparando linha por linha.
    * @param {Vectorization.Matrix} matrixB - A outra matrix
    * @returns {Boolean} - Se o contéudo é exatamente igual ou não
    */
    context.isExatamenteMesmoConteudo = function(matrixB){
        //Verifica se cada linha da matrixB é exatamente igual a linha correspondende da matrix atual
        const mappedVector = Vectorization.Vector( context.map(function(i, valor, selfContext){
            const linhaAtual = i;
            return matrixB.getLinha(linhaAtual).isExatamenteIgual( context.getLinha(linhaAtual) );
        }) );

        //Verifica os resultados de mappedMatrix, se todos são verdadeiros
        return mappedVector.todosVerdadeiros();
    }

    /**
    * Compara se esta matrix é exatamente igual a outra matrix, tanto em formato quanto em contéudo
    * @param {Vectorization.Matrix} matrixB - A outra matrix
    * @returns {Boolean} - Se são iguais ou não
    */
    context.isIgual = function(matrixB){
        return (context.isExatamenteMesmoTamanho(matrixB) == true && 
                context.isExatamenteMesmoConteudo(matrixB) == true);
    }

    //Alias for isIgual
    context.isEquals = context.isIgual;

    context.valueOf = function(){
        return context.content;
    }

    context.toString = function(){
        return String(context.content);
    }

    context.get = function(linha, coluna){
        return context.content[linha][coluna];
    }

    context.getLinha = function(linha){
        return context.content[linha];
    }

    //Alias for getLinha
    context.getLine = context.getLinha;

    context.values = function(){
        return context.content;
    }

    context.rawProfundo = function(){
        let rawValues = [];

        for( let i = 0 ; i < context.rows ; i++ )
        {
            rawValues[i] = context.content[i].rawProfundo();
        }

        return rawValues;
    }

    context.rawValues = function(){
        let rawValues = [];

        //Se for um Vectorization.Matrix com essa opcao especifica ativa, usa por padrao o profundo
        if( context.isFlexivelNasColunas == true ){
            return context.rawProfundo();
        }

        for( let i = 0 ; i < context.rows ; i++ )
        {
            rawValues[i] = context.content[i].values();
        }

        return rawValues;
    }

    context.raw = function(){
        return context.rawValues();
    }

    /**
    * Verifica se algum elemento está presente nesta Vectorization.Matrix
    * @param {Object} valor 
    * @returns {Boolean}
    */
    context.have = function( valor ){
        let tem = false;

        for( let i = 0 ; i < context.rows ; i++ ){
            if( (context.getLinha( i ).have || context.getLinha( i ).includes)( valor ) ){
                tem = true;
                break;
            }
        }

        return tem;
    }

    context.mostrarTabela = function(){
        console.table( context.rawValues() );
    }

    context.mostrar = function(){
        console.log( context.rawValues() );
    }

    context.push = function(element){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        if( context.isAdvancedMatrix ){
            if( context.isFlexivelNasColunas == true ){
                context.content.push( element.objectName != undefined && element.objectName == 'Vector' ? element : Vectorization.BendableVector(element, context._config) );

            //Se não tem flexibilidade
            }else{
                context.content.push( element.objectName != undefined && element.objectName == 'Vector' ? element : Vectorization.Vector(element) );
            }

        }else{
            context.content.push(element);
        }

        //Atualiza a quantidade de linhas e colunas
        context.atualizarQuantidadeColunasLinhas();
    }

    context.obterTiposRapido = function(includeNamespace=false){
        let tiposUsados = [];
        context.paraCadaLinha(function(i, elementoAtual){
            tiposUsados.push( elementoAtual.obterTiposRapido(includeNamespace) );
        });

        return tiposUsados;
    }

    context.identificarTiposColuna = function(numeroColuna){
        const resultado = Vectorization.Base({
            tipos: Vectorization.Vector([], {usarEscalares: false})
        });

        context.percorrerColuna(numeroColuna, function(iColuna, valorColuna){
            resultado.tipos.adicionarElemento( window.Vectorization.identificarTipo( valorColuna ) );
        });

        resultado.tiposUnicos = resultado.tipos.valoresUnicos();
        resultado.raw = function(){
            return resultado.tipos.raw();
        }

        return resultado;
    }
    context.getTiposColuna = context.identificarTiposColuna;
    context.obterTiposColuna = context.identificarTiposColuna;

    /**
    * Permite fatiar(ou recortar) a matrix
    * @param {linhaInicial} - inicio
    * @param {linhaFinal} - final
    * @param {intervalo} - intervalo
    * @returns {Vectorization.Matrix} - a matriz recortada
    */
    context.slice = function(linhaInicial, linhaFinal, intervalo=1){
        let dadosRecortados = [];

        if( linhaInicial < 0 ){
            throw 'A linhaInicial precisa ser maior ou igual a zero!';
        }

        if( linhaFinal > context.rows ){
            throw 'A linhaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        if( intervalo <= 0 ){
            throw 'O intervalo precisa ser maior que zero!';
        }

        for( let i = linhaInicial ; i < linhaFinal ; i = i + intervalo )
        {
            dadosRecortados.push( context.getLinha(i).raw() );
        }

        if( context.flexibilidade ){
            return Vectorization.Matrix(dadosRecortados, {
                flexibilidade: context.flexibilidade || []
            });
        }

        return Vectorization.Matrix(dadosRecortados);
    }

    context.recortarLinhas = context.slice;
    context.sliceLinhas = context.slice;

    /**
     * Similar ao context.slice, porém executado nas colunas
     * @param {Number} colunaInicial 
     * @param {Number} colunaFinal 
     * @param {Number} intervaloLinhas 
     * @param {Number} intervaloColunas 
     * @returns {Vectorization.Matrix}
     */
    context.recortarColunas = function(colunaInicial, colunaFinal='nao_definida', intervaloLinhas=1, intervaloColunas=1){
        let dadosRecortados = [];

        if( colunaFinal == 'nao_definida' ){
            colunaFinal = context.columns + 1;
        }

        if( colunaInicial < 0 ){
            throw 'A colunaInicial precisa ser maior ou igual a zero!';
        }

        if( colunaFinal > context.rows ){
            throw 'A colunaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        for( let i = 0 ; i < context.rows ; i = i + intervaloLinhas )
        {
            dadosRecortados[ i ] = context.getLinha(i)
                                          .slice( colunaInicial, colunaFinal, intervaloColunas );
        }

        return Vectorization.Matrix(dadosRecortados);
    }

    /**
     * Similar ao context.slice, porém executado nas colunas
     * @param {Number} colunaInicial 
     * @param {Number} colunaFinal 
     * @param {Number} intervaloLinhas 
     * @param {Number} intervaloColunas 
     * @returns {Vectorization.Matrix}
     */
    context.sliceColunas = context.recortarColunas;

    /**
     * Similar ao context.slice, porém executado nas linhas e também nas colunas
     * @param {Number} linhaInicial 
     * @param {Number} linhaFinal 
     * @param {Number} colunaInicial 
     * @param {Number} colunaFinal 
     * @param {Number} intervaloLinhas 
     * @param {Number} intervaloColunas 
     * @returns {Vectorization.Matrix}
     */
    context.recortarRegiao = function(linhaInicial, linhaFinal, colunaInicial, colunaFinal='nao_definida', intervaloLinhas=1, intervaloColunas=1){
        let dadosRecortados = [];

        if( linhaInicial < 0 ){
            throw 'A linhaInicial precisa ser maior ou igual a zero!';
        }

        if( linhaFinal > context.rows ){
            throw 'A linhaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        if( colunaFinal == 'nao_definida' ){
            colunaFinal = context.columns + 1;
        }

        if( colunaInicial < 0 ){
            throw 'A colunaInicial precisa ser maior ou igual a zero!';
        }

        if( colunaFinal > context.rows ){
            throw 'A colunaFinal precisa estar entre as linhas da matriz! valor muito alto!';
        }

        for( let i = linhaInicial ; i < linhaFinal ; i = i + intervaloLinhas )
        {
            dadosRecortados[ i ] = context.getLinha(i)
                                          .slice( colunaInicial, colunaFinal, intervaloColunas );
        }

        return Vectorization.Matrix(dadosRecortados);
    }

    /**
    * Similar ao context.slice, porém executado nas linhas e também nas colunas
    * @param {Number} linhaInicial 
    * @param {Number} linhaFinal 
    * @param {Number} colunaInicial 
    * @param {Number} colunaFinal 
    * @param {Number} intervaloLinhas 
    * @param {Number} intervaloColunas 
    * @returns {Vectorization.Matrix}
    */
    context.slice2 = context.recortarRegiao;

    /**
    * Permite extrair valores de uma coluna especifica
    * @param {Number} indiceColuna - o indice da coluna que queremos extrair os valores
    * @returns {Vectorization.Vector || Array}
    */
    context.extrairValoresColuna = function(indiceColuna){
        let valoresColuna = [];
        for( let i = 0 ; i < context.rows ; i++ )
        {
            valoresColuna.push( Vectorization.Vector(context.getLinha(i)).readIndex(indiceColuna) );
        }

        if( context.isAdvancedMatrix ){
            if( context.isFlexivelNasColunas == true ){
                let extraPropsOfLine = {};

                //Cada coluna pode ter o seu
                if( Vectorization.Text.isText( valoresColuna[0] ) ){
                    extraPropsOfLine['flexibilidade'] = Vectorization.Vector({
                        usarEscalares: false,
                        valorPreencher: 'Texto',
                        elementos: valoresColuna.length
                    });

                }else if( Vectorization.Scalar.isScalar( valoresColuna[0] ) ){
                    extraPropsOfLine['flexibilidade'] = Vectorization.Vector({
                        usarEscalares: false,
                        valorPreencher: 'Numero',
                        elementos: valoresColuna.length
                    });
                }

                return Vectorization.BendableVector( valoresColuna, extraPropsOfLine );

            }else if (context.isFlexivelNasColunas == false ){
                return Vectorization.Vector( valoresColuna );
            }

        }else{
            return valoresColuna;
        }
    }

    /**
    * Subfatiar esta matriz em varias partes, cada uma com uma CERTA QUANTIDADE FIXA DE AMOSTRAS
    *  
    * Agrupa sequencialmente amostras, de acordo com O TAMANHO DA FATIA , por exemplo, se for uma fatia de 7 amostras, então, ele vai dividir o dataset em subgrupos, cada um tendo 7 amostras cada.
    * Ou seja, o dataset seria dividido de 7 em 7 amostras. Ou seja, cada fatia teria 7 amostras.
    * 
    * NOTA: Cada parte vai ser uma nova Vectorization.Matrix, contendo Vectorization.Vector(s) dentro. Ou seja, cada Vectorization.Vector dentro dessa matrix resultado, vai ser uma amostra.
    * 
    * @param {Number} tamanhoFatia - O tamanho das fatias(quantidade de amostras por fatia)
    * @param {Number} iniciarEm - O indice que ele vai iniciar o fatiamento
    * 
    * @returns { Vectorization.Envelope }
    */
    context.subfatiar = function( tamanhoFatia, iniciarEm=0 ){
        if(!tamanhoFatia){
            throw 'Voce precisa definir uma quantidade de amostras para as fatias!';
        }
        if( tamanhoFatia > context.linhas ){
            console.warn(`O tamanho de fatia ${tamanhoFatia} é maior do que a quantidade de linhas da matrix`);
        }

        let fatiasFeitas = [];
        let indiceFinalFatia = (tamanhoFatia - iniciarEm);

        for( let indiceAtual = iniciarEm ; indiceAtual < context.linhas ; indiceAtual += tamanhoFatia ){

            const sliceAtual = context.clonar()
                                      .slice( indiceAtual, indiceFinalFatia );

            indiceFinalFatia = indiceFinalFatia + tamanhoFatia;

            fatiasFeitas.push( sliceAtual );
        }

        return Vectorization.Envelope(fatiasFeitas);
    }

    /**
    * Concatena duas matrizes 
    */
    context.concat = function( outraMatrix ){
        let matrixAtualArray = context.clonar();

        outraMatrix.paraCadaLinha(function(indiceLinha, vetorDaLinha){
            matrixAtualArray.push( vetorDaLinha );
        });

        return matrixAtualArray;
    }

    /**
    * Cria varias "áreas deslizantes". Cada área vai ter <N> números.
    * Pode ser usado para calcular médias móveis, desvio padrão movel, variancia movel, etc. 
    * 
    * Em outras palavras, O método 'deslizes' serve para gerar vários deslizes por assim dizer, ou seja, vai deslizando as linhas desta Matrix, gerando outras sub Matrizes com uma mesma quantidade fixa de linhas, cada parte contendo seu slice atual da posição atual ATÈ a posição atual MAIS O TAMANHO DO PEDAÇO. 
    * O método retorna um objeto Envelope.
    * 
    * @returns {Vectorization.Envelope}
    */
    context.deslizes = function( quantidadeDeslizes=4, incluirIncompletos=false, iniciarEm=0 ){
        let deslizesProntos = Vectorization.Envelope([]);

        if( String(quantidadeDeslizes).indexOf('.') != -1 ){
            throw `O parametro quantidadeDeslizes tem valor '${quantidadeDeslizes}', porém ele precisa ser inteiro!. `;
        }

        if( iniciarEm < 0 ){
            throw `O parametro 'iniciarEm' tem valor ${ iniciarEm }. Porém, ele precisa ser positivo!`;
        }

        if( quantidadeDeslizes < 0 ){
            throw `O parametro 'quantidadeDeslizes' tem valor ${ quantidadeDeslizes }. Porém, ele precisa ser positivo!`;
        }

        if( quantidadeDeslizes == 0 ){
            throw `O parametro 'quantidadeDeslizes' tem valor ${ quantidadeDeslizes }. Porém, ele precisa ser maior que zero!`;
        }

        //Preenche com zeros nos deslizes iniciais
        if( incluirIncompletos == true )
        {
            let primeiroPosicaoQueVaiTerInicio = context.clonar().slice(0, quantidadeDeslizes);
            let posicaoAtualDoInicio = 1;

            for( let i = 0 ; i < primeiroPosicaoQueVaiTerInicio.linhas-1 ; i++ ){
                let valoresColocarNessaIteracao = primeiroPosicaoQueVaiTerInicio.slice( 0, posicaoAtualDoInicio );
                posicaoAtualDoInicio++;

                let quantosFaltamNessaIteracao = Math.abs( valoresColocarNessaIteracao.raw().length - quantidadeDeslizes );

                let arrayPreencher = Vectorization.Matrix( Array( quantosFaltamNessaIteracao )
                                                        .fill( Array( primeiroPosicaoQueVaiTerInicio.raw()[0].length ).fill(0) ) )
                                                .concat( valoresColocarNessaIteracao );

                deslizesProntos.adicionarObjeto( arrayPreencher );
            }
        }

        for( let i = iniciarEm ; i < context.linhas ; i++ ){

            //Se a proxima iteração for ultrapassar os limites(a ultima linha desta Matrix), interompe, pois ja terminou
            if( i + quantidadeDeslizes > context.linhas ){
                break;
            }

            const sliceAtual = context.clonar()
                                      .slice( i, i + quantidadeDeslizes );

            deslizesProntos.adicionarObjeto( sliceAtual );
        }

        return deslizesProntos;
    }

    context.extrairValoresLinha = context.getLinha;

    context._definirValorLinha = function(indice, indiceAdicionar, vetorDaLinha){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        context.getLinha(indice)
               .definirElementoNoIndice(indiceAdicionar, vetorDaLinha);
    }

    /**
    * 
    * @param {Number} indice - O indice da linha
    * @param {Number} indiceAdicionar - O indice da coluna
    * @param {Array} vetorDaLinha 
    */
    context.definirValorLinha = function(indice, indiceAdicionar, vetorDaLinha){
        context._definirValorLinha(indice, indiceAdicionar, vetorDaLinha);
    }

    //Cria uma nova coluna nesta Vectorization.Matrix
    context.adicionarColuna = function(valoresNovaColuna){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        let isVetorVectorization = (
            Vectorization.Vector.isVector(valoresNovaColuna || []) == true &&
            Vectorization.Vector.isVectorizationVector(valoresNovaColuna || []) 
        ) == true;
           
        let valoresNovaColuna_Vector = isVetorVectorization == true ? valoresNovaColuna : Vectorization.Vector(valoresNovaColuna || []);
        let tamanhoVetorNovo = valoresNovaColuna_Vector.tamanho();
        let quantidadeLinhasMatrix = context.getRows();

        if( typeof valoresNovaColuna_Vector == 'object' &&
            tamanhoVetorNovo == quantidadeLinhasMatrix
        ){
            //Para cada linha
            Vectorization.Vector({
                valorPreencher: 1,
                elementos: quantidadeLinhasMatrix

            }).paraCadaElemento(function(iLinha){
                let valoresDaLinhaObtidos = context.getLinha(iLinha);

                switch( Vectorization.Vector.isVectorizationVector(valoresDaLinhaObtidos) || 
                        Vectorization.BendableVector.isVectorizationBendableVector(valoresDaLinhaObtidos) 
                ){
                    case true:
                        valoresDaLinhaObtidos.adicionarElemento( valoresNovaColuna[iLinha] );
                        break;

                    case false:
                        let novoVetorVectorization = Vectorization.Vector(valoresDaLinhaObtidos).adicionarElemento( valoresNovaColuna[iLinha] )
                        context._definirValorLinha(iLinha, valoresDaLinhaObtidos.length, [... novoVetorVectorization.valores()] );
                        break;
                }
            });

            //Atualiza a quantidade das colunas
            context.columns = context.calcTamanhos().lerIndice(1);
            context.colunas = context.columns;

        }else{
            throw 'Não da pra adicionar uma nova coluna se a quantidade de elementos não bater com a quantidade de linhas!. Não permitido.';
        }
    }

    //Remove uma coluna nesta Vectorization.Matrix e retorna uma nova Vectorization.Matrix
    context.removerColuna = function( indiceColuna ){
        let matrixNova = [];
        //Para cada linha
        for( let i = 0 ; i < context.linhas ; i++ )
        {
            const LinhaVector = context.getLinha(i);
            const NovaVector  = Vectorization.Vector([]);

            //Para cada elemento no LinhaVector
            LinhaVector.forEach(function( indiceElemento, valorElemento, contextoLinhaVector ){
                //Se o indice não for o indice que estamos ignorando
                if( indiceElemento != indiceColuna ){
                    NovaVector.push( valorElemento );
                }
            });

            matrixNova.push(NovaVector.raw());
        }

        return Vectorization.Matrix(matrixNova);
    }     
    
    //Remove varias coluna nesta Vectorization.Matrix e retorna uma nova Vectorization.Matrix
    context.removerColunas = function( VectorIndiceColuna=[] ){
        let matrixNova = [];
        //Para cada linha
        for( let i = 0 ; i < context.linhas ; i++ )
        {
            const LinhaVector = context.getLinha(i);
            const NovaVector  = Vectorization.Vector([]);

            //Para cada elemento no LinhaVector
            LinhaVector.forEach(function( indiceElemento, valorElemento, contextoLinhaVector ){
                //Se o indice não for o indice que estamos ignorando
                if( VectorIndiceColuna.includes(indiceElemento) == false ){
                    NovaVector.push( valorElemento );
                }
            });

            matrixNova.push(NovaVector.raw());
        }

        return Vectorization.Matrix(matrixNova);
    }  

    context.zerarColuna = function(indiceColuna, valorDefinirNoLugar=0){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        let quantidadeLinhasMatrix = context.getLinhas();

        //Para cada linha
        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix

        }).paraCadaElemento(function(iLinha){
            context._definirValorLinha(iLinha, indiceColuna, valorDefinirNoLugar );
        });
    }

    /**
    * @param {Number} indiceColuna 
    * @param {Number} valorDefinirNoLugar 
    * @param {Number} funcaoDeCondicao - a função(indiceDaLinhaAtual, indiceDaColunaEmQuestao, vetorDaLinhaAtual, valoresBrutosDaLinha, valorDaColunaAtualDaLinhaAtual, contextoPropiaMatrix) 
    */
    context.zerarColunaOnde = function(indiceColuna, valorDefinirNoLugar=0, funcaoDeCondicao){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }
        
        if( typeof funcaoDeCondicao == 'function' && funcaoDeCondicao != undefined )
        {
            let quantidadeLinhasMatrix = context.getLinhas();

            //Para cada linha
            Vectorization.Vector({
                valorPreencher: 1,
                elementos: quantidadeLinhasMatrix

            }).paraCadaElemento(function(iLinha){
                let vetorDaLinhaAtual = context.getLinha(iLinha),
                    valoresBrutosDaLinha = vetorDaLinhaAtual.valores(),
                    indiceDaLinhaAtual = iLinha,
                    indiceDaColunaEmQuestao = indiceColuna,
                    valorDaColunaAtualDaLinhaAtual = vetorDaLinhaAtual.readIndex(indiceColuna),
                    contextoPropiaMatrix = context;

                let checagemDaFuncaoDeCondicao = funcaoDeCondicao(indiceDaLinhaAtual, indiceDaColunaEmQuestao, vetorDaLinhaAtual, valoresBrutosDaLinha, valorDaColunaAtualDaLinhaAtual, contextoPropiaMatrix);

                if( checagemDaFuncaoDeCondicao == true || checagemDaFuncaoDeCondicao == 'limpar' || checagemDaFuncaoDeCondicao == 'zerar' || checagemDaFuncaoDeCondicao == 'clear' || checagemDaFuncaoDeCondicao == 'clean'){
                    context._definirValorLinha(iLinha, indiceColuna, valorDefinirNoLugar );
                }
            });

        }else{
            throw 'Precisa ter a funcaoDeCondicao';
        }
    }

    context.zerarLinha = function(indiceLinha, valorDefinirNoLugar=0){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        context.getLinha(indiceLinha).substituirElementosPor( Vectorization.Vector({
            valorPreencher: valorDefinirNoLugar,
            elementos: context.columns
        }) );
    }

    /**
    * Aplica um arredondamento sobre os valores deste vetor
    * CUIDADO: isso vai sobrescrever os valores
    * 
    * @param {String} tipoArredondamentoAplicar
    * @returns {Vectorization.Matrix} - a matrix arredondada
    */
    context.aplicarArredondamento = function(tipoArredondamentoAplicar='cima'){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: context.rows

        }).paraCadaElemento(function(i){
            let subVetorAplicarArredondamento = context.getLinha(i);

            if( Vectorization.Vector.isVectorizationVector(subVetorAplicarArredondamento) ){
                subVetorAplicarArredondamento.aplicarArredondamento(tipoArredondamentoAplicar);
            }
        });

        return context;
    }

    /**
    * Vai tornar possivel que voce ande por todos os elementos que estão presentes dentro da coluna especifica que vc passar como parametro.
    * @param {Number} indiceColuna - o indice da coluna em questão
    * @param {Function} callbackPercorrer - callbackPercorrer(valorNoIndiceDeInteresse, iLinha, LinhaMatrix_Vector, context)
    */
    context.percorrerColuna = function(indiceColuna, callbackPercorrer){
        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let valorNoIndiceDeInteresse = LinhaMatrix_Vector.lerIndice(indiceColuna);

            callbackPercorrer( 
                      indiceColuna,
                      valorNoIndiceDeInteresse, 
                      iLinha, 
                      LinhaMatrix_Vector, 
                      context 
                    );
        });
    }

    context.paraCadaColuna = context.percorrerColuna;

    /** 
    * Remove amostras duplicadas deste Vectorization.Vector com base em colunas específicas.
    */
    context.distinct = function(){
        const valoresJaVistos = {};
        const valoresUnicos = Vectorization.Matrix([], { flexibilidade: context.flexibilidade });

        context.forEach(function(indice, linhaVector){
            const identificador = linhaVector.raw()
                                             .join('|');

            if( valoresJaVistos[identificador] == undefined ){
                valoresJaVistos[identificador] = true;
                valoresUnicos.push( linhaVector );
            }
        });

        return valoresUnicos;
    }

    /**
    * Vai tornar possivel que voce ande por todos os elementos que estão presentes dentro da coluna especifica que vc passar como parametro.
    * SIMILAR AO context.percorrerColuna, porém ele vai implementar algo mais parecido com o Vectorization.Vector.mapearValores
    * @param {Number} indiceColuna - o indice da coluna em questão
    * @param {Function} callbackMapeamento - callbackMapeamento(valorNoIndiceDeInteresse, iLinha, LinhaMatrix_Vector, context)
    * @returns {Vectorization.Vector} - a coluna após a aplicação desta função
    */
    context.mapearColuna = function(indiceColuna, callbackMapeamento){
        let valoresAposAplicacaoMetodo = Vectorization.Vector([]);

        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let valorNoIndiceDeInteresse = LinhaMatrix_Vector.lerIndice(indiceColuna);

            let resultadoAplicacaoFuncao = callbackMapeamento( valorNoIndiceDeInteresse, 
                      iLinha, LinhaMatrix_Vector, context 
                    );

            valoresAposAplicacaoMetodo.adicionarElemento(resultadoAplicacaoFuncao);
        });

        return Vectorization.Vector(valoresAposAplicacaoMetodo);
    }

    /**
    * Vai permitir "Peneirar" os elementos que estão presentes dentro da coluna especifica que vc passar como parametro.
    * SIMILAR AO Vectorization.Vector.filtrarValores
    * @param {Number} indiceColuna - o indice da coluna em questão
    * @param {Function} callbackFiltragem - callbackFiltragem(valorNoIndiceDeInteresse, iLinha, LinhaMatrix_Vector, context)
    * @returns {Vectorization.Vector} - a coluna após a aplicação deste filtro
    */
    context.filtrarColuna = function(indiceColuna, callbackFiltragem){
        let valoresAposAplicacaoMetodo = Vectorization.Vector([]);

        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let valorNoIndiceDeInteresse = LinhaMatrix_Vector.lerIndice(indiceColuna);

            if(!callbackFiltragem){
                throw 'Voce precisa passar uma função de filtro!. Não permitido!';
            }

            let resultadoAplicacaoFuncao = callbackFiltragem( valorNoIndiceDeInteresse, 
                      iLinha, LinhaMatrix_Vector, context 
                    );

            let checagemDoFiltro = resultadoAplicacaoFuncao;

            if(checagemDoFiltro == true || checagemDoFiltro == 'incluir' || checagemDoFiltro == 'manter' || checagemDoFiltro == 'keep' || checagemDoFiltro == 'ok'){
                valoresAposAplicacaoMetodo.adicionarElemento(valorNoIndiceDeInteresse);
            }

        });

        return Vectorization.Vector(valoresAposAplicacaoMetodo);
    }

    /**
    * Aplica um "peneiramento" na coluna desta Vectorization.Matrix
    * @param {Number} indiceColuna - o indice da coluna em questão
    * @param {Function} callbackFiltragem - callbackFiltragem(iColuna, elementoNaPosicaoAtual, context)
    * @returns {Vectorization.Matrix} - Esta propia Vectorization.Matrix
    * 
    * CUIDADO: isso vai sobrescrever esta Vectorization.Matrix
    */
    context.aplicarFiltroColuna = function(indiceColuna, callbackFiltragem){
        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        context.paraCadaLinha(function(iLinha){
            let LinhaMatrix_Vector = context.getLinha(iLinha);
            let LinhaMatrix_Vector_copia = ( LinhaMatrix_Vector || Vectorization.Vector([]) ).duplicar();
            let dadosLinhaMatrix_Vector_Filtrados = Vectorization.Vector( LinhaMatrix_Vector_copia.filtrarValores(callbackFiltragem) );

            if(!callbackFiltragem){
                throw 'Voce precisa passar uma função de filtro!. Não permitido!';
            }

            if( Vectorization.Vector.isVectorizationVector(dadosLinhaMatrix_Vector_Filtrados) ){
                //Atualiza esta Vectorization.Matrix
                LinhaMatrix_Vector.sobrescreverConteudo(
                    Vectorization.Vector( dadosLinhaMatrix_Vector_Filtrados.valores() || [] )
                );

            }else{
                console.warn('Nenhum filtro foi aplicado');
            }

        });

        return context;
    }

    /**
    * Descobre qual que é a maior quantidade de elementos das linhas cadastradas na matrix
    */
    context.getMaiorQuantidadeColunas = function(){
        let primeiraLinha = context.getLinha(0);
        let maiorQuantiaAtualmenteObtida = primeiraLinha.tamanho();
        let quantidadeLinhasMatrix = context.rows;

        Vectorization.Vector({
           valorPreencher: 1,
           elementos: quantidadeLinhasMatrix
           
        }).paraCadaElemento(
            function(i){
                let linhaAtual = context.getLinha(i);
                let tamanhoDaLinhaAtual = linhaAtual.tamanho();
                maiorQuantiaAtualmenteObtida = (maiorQuantiaAtualmenteObtida <= tamanhoDaLinhaAtual) ? tamanhoDaLinhaAtual : maiorQuantiaAtualmenteObtida;
            });

        return maiorQuantiaAtualmenteObtida;
    }

    /**
    Descobre qual que é a linha que tem mais quantidade de elementos.
    */
    context.getMaiorLinha = function(){
        let primeiraLinha = context.getLinha(0);
        let maiorLinha = primeiraLinha;
        let quantidadeLinhasMatrix = context.rows;
        let maiorQuantidadeColunas = context.getMaiorQuantidadeColunas();

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix
            
         }).paraCadaElemento(
             function(i){
                 let linhaAtual = context.getLinha(i);
                 let tamanhoDaLinhaAtual = linhaAtual.tamanho();
                 if( tamanhoDaLinhaAtual >= maiorQuantidadeColunas ){ maiorLinha = linhaAtual };
             });

        return maiorLinha;
    }

    /**
    * Método que ele vai sair percorrendo cada linha, e vai deixar todas as linhas com a mesma quantidade de elemeentos
    * Se baseando estritamente na quantidade de colunas atual desta Vectorization.Matrix
    */
    context.igualarColunas = function(valorDefinirNoLugar){
        let maiorQuantidadeColunas = context.getMaiorQuantidadeColunas();
        let quantidadeLinhasMatrix = context.rows;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix
            
        }).paraCadaElemento(function(i){
            let linhaAtual = context.getLinha(i);
            let tamanhoDaLinhaAtual = linhaAtual.tamanho();

            if( tamanhoDaLinhaAtual < maiorQuantidadeColunas )
            {
                let quantosElementosFaltam = Math.abs( tamanhoDaLinhaAtual - maiorQuantidadeColunas );
                
                let novoVetorASerAcrescentado = Vectorization.Vector({
                    valorPreencher: valorDefinirNoLugar,
                    elementos: quantosElementosFaltam
                });

                //Vai acrescentar um novo Vectorization.Vector dentro da linha atual desta Vectorization.Matrix
                //Vai usar um método chamado acrescentarVetor do Vectorization.Vector
                linhaAtual.acrescentarVetor(novoVetorASerAcrescentado);
            }
        });
    }

    /**
    * Quase identico ao context.igualarColunas, porém com uma diferença drástica: ele adiciona no inicio da linha
    * 
    * Método que ele vai sair percorrendo cada linha, e vai deixar todas as linhas com a mesma quantidade de elemeentos
    * Se baseando estritamente na quantidade de colunas atual desta Vectorization.Matrix
    */
    context.igualarColunasNoInicio = function(valorDefinirNoLugar){
        let maiorQuantidadeColunas = context.getMaiorQuantidadeColunas();
        let quantidadeLinhasMatrix = context.rows;

        //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
        if( context._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
        }

        Vectorization.Vector({
            valorPreencher: 1,
            elementos: quantidadeLinhasMatrix
            
        }).paraCadaElemento(function(i){
            let linhaAtual = context.getLinha(i);
            let tamanhoDaLinhaAtual = linhaAtual.tamanho();

            if( tamanhoDaLinhaAtual < maiorQuantidadeColunas )
            {
                let quantosElementosFaltam = Math.abs( tamanhoDaLinhaAtual - maiorQuantidadeColunas );
                
                let novoVetorASerAcrescentado = Vectorization.Vector({
                    valorPreencher: valorDefinirNoLugar,
                    elementos: quantosElementosFaltam
                });

                //Vai acrescentar um novo Vectorization.Vector dentro da linha atual desta Vectorization.Matrix
                //Vai usar um método chamado acrescentarVetor do Vectorization.Vector
                linhaAtual.acrescentarNoInicioVetor(novoVetorASerAcrescentado.valores());
            }
        });
    }

    context.adicionarEmTodasLinhas = function(){

    }

    /**
    * Percorre cada linha da matrix, aplicando uma função de callback
    * @param {Function} callback(index, element, context)
    */
    context.forEach = function(callback){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            callback( i, context.content[i], context );
        }
    }

    /**
    * Percorre cada linha da matrix, aplicando uma função de callback, retornando um resultado
    * @param {Function} callback(index, element, context)
    * @returns {Vectorization.Vector or Vectorization.Matrix}
    */
    context.map = function(callback){
        let novaMatrix = [];

        for( let i = 0 ; i < context.content.length ; i++ )
        {
            novaMatrix[i] = callback( i, context.content[i], context );
        }

        //Se a função de callback ao ser aplicada resultar numa matrix, então ele converte resultado para Matrix
        if( Vectorization.Vector.isVector( novaMatrix[0] ) ){
            return Vectorization.Matrix(novaMatrix);
        }else{
            return Vectorization.Vector(novaMatrix);
        }
    }

    /**
     * Produto escalar de uma matriz com um vetor ou outra matriz
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matriz-com-vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matrizes
     * 
     * @param {Vectorization.Matrix} matrixA
     * @param {Object} matrixB
     * @returns {Object}
    */
    context.produtoEscalar = function( matrixB ){
        let matrixA = context;
        /**
        * Regra: percorre na vertical a matrixB, para cada coluna:
        * Coluna1 matrixB com linha1 matrixA, depois Coluna2 da matrixB com linha1 da matrixA.
        */

        if( !matrixB.objectName || (matrixB.objectName != 'Matrix' && matrixB.objectName != 'Vector') ){
            throw 'matrixB must be a Vectorization.Matrix';
        }

        if( matrixA.rows != (matrixB.columns || matrixB.length) ){
            throw 'The number of rows in matrixA must be exactly equal to the number of columns in matrixB. Impossible to calculate!';
        }

        //Se o segundo parametro for uma matrix
        if( matrixB.objectName == 'Matrix' ){
            let resultMatrix = [];
            let ordemColunasB = [];

            //Esse trecho é semelhante a uma transposição de matriz, pra tornar possivel os calculos
            for( let coluna = 0 ; coluna < matrixB.columns ; coluna++ ){

                //Extrair os valores da coluna atual da matrixB
                let valoresColunaBAtual = [];
                for( let linha = 0 ; linha < matrixB.rows ; linha++ ){
                    valoresColunaBAtual.push( matrixB.content[linha][coluna] );
                }

                //Salva isso numa lista, em ordem certa para os calculos abaixo no proximo bloco a seguir:
                ordemColunasB.push( valoresColunaBAtual );

            }   

            //Proxima etapa: percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){

                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];

                //Cria um array vazio para a linha. Esse array vai ser usado para armazenar os produtos feitos com os valores da linha abaixo:
                resultMatrix[linha] = [];
                
                //Percorre cada "fileira"(ou melhor dizendo, cada fileira é um vetor contendo cada valor da colunaB atual, ou seja, em sentido vertical) da matrix B
                for( let colunaB = 0 ; colunaB < ordemColunasB.length ; colunaB++ ){

                    //Obtem a fileira atual da matrix B(o vetor atual)
                    let valoresColunaBAtual = ordemColunasB[colunaB];

                    //Inicializa a variavel que será usada para a soma ponderada
                    let produtoAtual = 0;
                    //Percorre cada indice dos valores da fileira atual da matrix B
                    for( let indexValor = 0 ; indexValor < valoresColunaBAtual.length ; indexValor++ ){
                        produtoAtual += ( valoresLinhaAtual[indexValor] * valoresColunaBAtual[indexValor] );
                    }

                    //Atribui o produto dentro da linha atual da matriz resultante, isso é feito em ordem sequencial
                    resultMatrix[linha].push( produtoAtual );

                    //... vai pro próximo produto [...], permanecendo na linha atual da matrixA

                }
            }

            return Vectorization.Matrix(resultMatrix);

        //Se o segundo objeto for um Vector
        }else if( matrixB.objectName == 'Vector' ){
            if( matrixA.rows != matrixB.length ){
                throw 'The number of lines in matrixA must be exactly equal to the number of elements in the vector. Impossible to calculate!';
            }
        
            let vetorResultado = [];
        
            //Percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){
        
                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];
        
                //Inicializa a variavel que será usada para a soma ponderada da linha atual
                let produtoAtual = 0;
        
                //Percorre cada elemento do vetor B
                for( let colunaB = 0 ; colunaB < matrixB.length ; colunaB++ ){
                    produtoAtual += ( valoresLinhaAtual[colunaB] * matrixB.readIndex(colunaB) );
                }
        
                //Vai adicionando os resultados no vetor de resultado
                vetorResultado.push(produtoAtual);
            }
        
            return Vectorization.Vector(vetorResultado);
        }
    }

    /**
     * Produto escalar de uma matriz com outra matriz
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matriz-com-vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matrizes
     * 
     * @param {Vectorization.Matrix} matrixA
     * @param {Vectorization.Matrix} matrixB
     * @returns {Vectorization.Matrix}
    */
    context.produtoEscalarMatrix = function( matrixB ){
        let matrixA = context;
        /**
        * Regra: percorre na vertical a matrixB, para cada coluna:
        * Coluna1 matrixB com linha1 matrixA, depois Coluna2 da matrixB com linha1 da matrixA.
        */

        if( !matrixB.objectName || (matrixB.objectName != 'Matrix' && matrixB.objectName != 'Vector') ){
            throw 'matrixB must be a Vectorization.Matrix';
        }

        if( matrixA.rows != (matrixB.columns || matrixB.length) ){
            throw 'The number of rows in matrixA must be exactly equal to the number of columns in matrixB. Impossible to calculate!';
        }

        //Se o segundo parametro for uma matrix
        if( matrixB.objectName == 'Matrix' ){
            let resultMatrix = [];
            let ordemColunasB = [];

            //Esse trecho é semelhante a uma transposição de matriz, pra tornar possivel os calculos
            for( let coluna = 0 ; coluna < matrixB.columns ; coluna++ ){

                //Extrair os valores da coluna atual da matrixB
                let valoresColunaBAtual = [];
                for( let linha = 0 ; linha < matrixB.rows ; linha++ ){
                    valoresColunaBAtual.push( matrixB.content[linha][coluna] );
                }

                //Salva isso numa lista, em ordem certa para os calculos abaixo no proximo bloco a seguir:
                ordemColunasB.push( valoresColunaBAtual );

            }   

            //Proxima etapa: percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){

                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];

                //Cria um array vazio para a linha. Esse array vai ser usado para armazenar os produtos feitos com os valores da linha abaixo:
                resultMatrix[linha] = [];
                
                //Percorre cada "fileira"(ou melhor dizendo, cada fileira é um vetor contendo cada valor da colunaB atual, ou seja, em sentido vertical) da matrix B
                for( let colunaB = 0 ; colunaB < ordemColunasB.length ; colunaB++ ){

                    //Obtem a fileira atual da matrix B(o vetor atual)
                    let valoresColunaBAtual = ordemColunasB[colunaB];

                    //Inicializa a variavel que será usada para a soma ponderada
                    let produtoAtual = 0;
                    //Percorre cada indice dos valores da fileira atual da matrix B
                    for( let indexValor = 0 ; indexValor < valoresColunaBAtual.length ; indexValor++ ){
                        produtoAtual += ( valoresLinhaAtual[indexValor] * valoresColunaBAtual[indexValor] );
                    }

                    //Atribui o produto dentro da linha atual da matriz resultante, isso é feito em ordem sequencial
                    resultMatrix[linha].push( produtoAtual );

                    //... vai pro próximo produto [...], permanecendo na linha atual da matrixA

                }
            }

            return Vectorization.Matrix(resultMatrix);

        //Se o segundo objeto for um Vector
        }else if( matrixB.objectName == 'Vector' ){
            throw 'O segundo parametro precisa ser uma Matrix!';
        }
    }

    /**
     * Produto escalar de uma matriz com um vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matriz-com-vetor
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/produto-escalar-matrizes
     * 
     * @param {Vectorization.Matrix} matrixA
     * @param {Vectorization.Vector} matrixB
     * @returns {Vectorization.Vector}
    */
    context.produtoEscalarVetor = function( matrixB ){
        let matrixA = context;
        /**
        * Regra: percorre na vertical a matrixB, para cada coluna:
        * Coluna1 matrixB com linha1 matrixA, depois Coluna2 da matrixB com linha1 da matrixA.
        */

        if( !matrixB.objectName || (matrixB.objectName != 'Matrix' && matrixB.objectName != 'Vector') ){
            throw 'matrixB must be a Vectorization.Matrix';
        }

        if( matrixA.rows != (matrixB.columns || matrixB.length) ){
            throw 'The number of rows in matrixA must be exactly equal to the number of columns in matrixB. Impossible to calculate!';
        }

        //Se o segundo parametro for uma matrix
        if( matrixB.objectName == 'Matrix' ){
            throw 'O segundo parametro precisa ser um Vector!';

        //Se o segundo objeto for um Vector
        }else if( matrixB.objectName == 'Vector' ){
            if( matrixA.rows != matrixB.length ){
                throw 'The number of lines in matrixA must be exactly equal to the number of elements in the vector. Impossible to calculate!';
            }
        
            let vetorResultado = [];
        
            //Percorre cada linha da matrix A
            for( let linha = 0 ; linha < matrixA.rows ; linha++ ){
        
                //Obtem os valores da linha atual da matrix A
                let valoresLinhaAtual = matrixA.content[linha];
        
                //Inicializa a variavel que será usada para a soma ponderada da linha atual
                let produtoAtual = 0;
        
                //Percorre cada elemento do vetor B
                for( let colunaB = 0 ; colunaB < matrixB.length ; colunaB++ ){
                    produtoAtual += ( valoresLinhaAtual[colunaB] * matrixB.readIndex(colunaB) );
                }
        
                //Vai adicionando os resultados no vetor de resultado
                vetorResultado.push(produtoAtual);
            }
        
            return Vectorization.Vector(vetorResultado);
        }
    }

    /**
     * Multiplica esta matrix com outra, de maneira elemento a elemento
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-elemento-a-elemento/codigo-principal.js
     * 
     * @param {Vectorization.Matrix} matrixB_param
     * @returns {Vectorization.Matrix}
    */
    context.multiplicarMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }

        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let matrixResultado = [];

        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                matrixResultado[i].push( matrixA[i][j] * matrixB[i][j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Multiplica esta matrix por um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero
     * @returns {Vectorization.Matrix}
     */
    context.multiplicarNumero = function(numero){
        let matrixA = context.content;
        let matrixResultado = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];
    
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                matrixResultado[i].push( matrixA[i][j] * numero );
            }
        }
    
        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Multiplica esta matrix por um vetor
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/multiplicar-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
     * @param {Vectorization.Vector} vectorB_param
     * @returns {Vectorization.Matrix} 
     */
    context.multiplicarVetor = function(vectorB_param){
        let matrixA = context.content;
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let matrixResultado = [];

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( matrixA[i][j] * vectorB[j] );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Faz a transposta da matrix
     * https://github.com/WilliamJardim/javascript-matematica/tree/main/matriz-transposta
     *
     * @returns {Vectorization.Matrix}
    */
    context.transposta = function(){
        let novaMatrix = [];

        for( let j = 0 ; j < context.content[0].length ; j++ ){
            novaMatrix[j] = [];

            for( let i = 0 ; i < context.content.length ; i++ ){
                novaMatrix[j].push( context.content[i][j] );
            }
        }

        const extraProps = {
            isTransposta: !context.isTransposta ? true : false
        }

        return Vectorization.Matrix(novaMatrix, extraProps);
    }

    /**
     * Obtem a matrix oposta
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/matriz-oposta/codigo-principal.js
     * @returns {Vectorization.Matrix}
     */
    context.matrixOposta = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] * -1;
            }
        }

        const extraProps = {
            isOposta: !context.isOposta ? true : false
        }
    
        return Vectorization.Matrix(novaMatrix, extraProps);
    }

    /**
     * Obtem a matrix absoluta
     * 
     * @returns {Vectorization.Matrix}
     */
    context.abs = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.abs(matrixA[i][j]);
            }
        }

        const extraProps = {
            isOposta: !context.isOposta ? true : false
        }
    
        return Vectorization.Matrix(novaMatrix, extraProps);
    }

    context.modulo = function(){
        return context.abs();
    }

    context.absoluto = function(){
        return context.abs();
    }

    /**
     * Obtem a raiz quadrada, de cada elemento da matrix 
     * @returns {Vectorization.Matrix}
     */
    context.sqrt = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.sqrt(matrixA[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Obtem o log2, de cada elemento da matrix 
     * @returns {Vectorization.Matrix}
     */
    context.log2 = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.log2(matrixA[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Obtem o log10, de cada elemento da matrix 
     * @returns {Vectorization.Matrix}
     */
    context.log10 = function(){
        let matrixA = context.content;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.log10(matrixA[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Tenta obter a matrix de identidade de ordem desta matrix 
    */
    context.identidade = function(){
        if( context.rows != context.columns ){
            throw 'A matrix precisa ser quadrada de ordem X'
        }
        
        return window.Vectorization.matrixIdentidade( context.rows );
    }

    /**
     * Soma esta matrix com outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.somarMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }

        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] + matrixB[i][j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Soma esta matrix com um número
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/soma-matrizes-por-um-numero-scalar/codigo-principal.js
    * @param {Number} numero
    * @returns {Vectorization.Matrix}
    */
    context.somarNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] + numero;
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Soma esta matrix com um vetor
     * 
     * @param {Vectorization.Matrix} vectorB_param 
     * @returns {Vectorization.Matrix}
    */
    context.somarVetor = function(vectorB_param){
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;

        if( vectorB.objectName != undefined && vectorB.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB.objectName);
        }
        
        let matrixA = context.content;

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        //let matrixB = (vectorB.objectName != undefined && vectorB.objectName == 'Vector') ? vectorB.content : vectorB;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] + vectorB[j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Subtrai esta matrix com outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.subtrairMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }

        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] - matrixB[i][j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Subtrai esta matrix com um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/subtracao-matrizes-por-um-numero-scalar/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix} 
    */
    context.subtrairNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] - numero;
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Subtrai esta matrix com um vetor
     * 
     * @param {Vectorization.Matrix} vectorB_param 
     * @returns {Vectorization.Matrix}
    */
    context.subtrairVetor = function(vectorB_param){
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;

        if( vectorB.objectName != undefined && vectorB.objectName != 'Vector' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Vector. E não um ' + String(vectorB.objectName);
        }
        
        let matrixA = context.content;

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        //let matrixB = (vectorB.objectName != undefined && vectorB.objectName == 'Vector') ? vectorB.content : vectorB;
        let novaMatrix = [];
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] - vectorB[j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Divide esta matrix com outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.dividirMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }
        
        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] / matrixB[i][j];
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Divide esta matrix por um número
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes-por-um-numero-scalar/codigo-principal.js
     * @param {Number} numero 
     * @returns {Vectorization.Matrix}
     */
    context.dividirNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];
        
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] / numero;
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Divide esta matrix por um vetor, aplicando o vetor a cada linha desta matrix 
    * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes-por-um-vetor-linha-por-linha/codigo-principal.js
    * @param {Vectorization.Vector} vectorB_param
    * @returns {Vectorization.Matrix}
    */
    context.dividirVetor = function(vectorB_param){
        let matrixA = context.content;
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let novaMatrix = [];

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser igual a quantidade de colunas da matrix!'
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                novaMatrix[i][j] = matrixA[i][j] / vectorB[j];
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Eleva esta matrix a um número
    * 
    * @param {Number} numero
    * @returns {Vectorization.Matrix}
    */
    context.elevarNumero = function(numero){
        let matrixA = context.content;
        let novaMatrix = [];

        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.pow(matrixA[i][j], numero);
            }
        }

        return Vectorization.Matrix(novaMatrix);
    }

    /**
     * Eleva esta matrix a um vetor
     * 
     * @param {Vectorization.Vector} vectorB_param
     * @returns {Vectorization.Matrix} 
     */
    context.elevarVetor = function(vectorB_param){
        let matrixA = context.content;
        let vectorB = (vectorB_param.objectName != undefined && vectorB_param.objectName == 'Vector') ? vectorB_param.content : vectorB_param;
        let matrixResultado = [];

        if( matrixA[0].length != vectorB.length ){
            throw 'A quantidade de elementos do vetor precisa ser a quantidade de colunas da matrix';
        }

        for( let i = 0 ; i < matrixA.length ; i++ )
        {   
            matrixResultado[i] = [];

            for( let j = 0 ; j < vectorB.length ; j++ )
            {
                matrixResultado[i].push( Math.pow(matrixA[i][j], vectorB[j]) );
            }
        }

        return Vectorization.Matrix(matrixResultado);
    }

    /**
     * Eleva esta matrix a outra matrix
     * https://github.com/WilliamJardim/javascript-matematica/blob/main/divisao-matrizes/codigo-principal.js
     * @param {Vectorization.Matrix} matrixB_param 
     * @returns {Vectorization.Matrix}
    */
    context.elevarMatrix = function(matrixB_param){
        if( matrixB_param.objectName != undefined && matrixB_param.objectName != 'Matrix' ){
            throw 'O segundo parametro precisa obrigatoriamente ser um Matrix. E não um ' + String(matrixB_param.objectName);
        }
        
        let matrixA = context.content;
        let matrixB = (matrixB_param.objectName != undefined && matrixB_param.objectName == 'Matrix') ? matrixB_param.content : matrixB_param;
        let novaMatrix = [];
    
        if( matrixA.length != matrixB.length || matrixA[0].length != matrixB[0].length ){
            throw 'As matrizes precisam ser do mesmo tamanho!'
        }
    
        for( let i = 0 ; i < matrixA.length ; i++ )
        {
            novaMatrix[i] = [];
            for( let j = 0 ; j < matrixA[0].length ; j++ )
            {
                novaMatrix[i][j] = Math.pow(matrixA[i][j], matrixB[i][j]);
            }
        }
    
        return Vectorization.Matrix(novaMatrix);
    }

    /**
    * Calcula a média de cada Vectorization.Vector desta Vectorization.Matrix
    * @returns {Vectorization.Vector}
    */
    context.mediaLinhas = function(){
        let vetorResultado = Vectorization.Vector([]);

        context.paraCadaLinha(function(indiceLinha, vetorDaLinha){
            const isVectorizationVector = Vectorization.Vector.isVectorizationVector(vetorDaLinha) == true ||
                                          Vectorization.BendableVector.isVectorizationBendableVector(vetorDaLinha) == true;

                                                                           //Se ja for um Vectorization.Vector 
            vetorResultado.adicionarElemento( isVectorizationVector == true ? vetorDaLinha.media() 
                                                                            //AGORA CASO SEJA UM ARRAY NORMAL, converte para Vectorization.Vector
                                                                            : Vectorization.Vector(vetorDaLinha).media() );
        });

        return vetorResultado;
    }

    /**
    * Calcula a média de cada Vectorization.Vector desta Vectorization.Matrix
    * @returns {Vectorization.Vector}
    */
    context.lineMean = context.mediaLinhas;

    /**
    * Calcula a média de cada coluna desta Vectorization.Matrix
    * @returns {Vectorization.Vector}
    */
    context.mediaColunas = function(){
        let vetorResultado = Vectorization.Vector([]);

        for( let numeroColuna = 0 ; numeroColuna < context.getColumns() ; numeroColuna++ )
        {
            const vetorValoresColuna    = context.extrairValoresColuna( numeroColuna );
 
            const isVectorizationVector = Vectorization.Vector.isVectorizationVector(vetorValoresColuna) == true ||
                                          Vectorization.BendableVector.isVectorizationBendableVector(vetorValoresColuna) == true;

                                                            //Se ja for um Vectorization.Vector 
            vetorResultado.adicionarElemento( isVectorizationVector == true ? vetorValoresColuna.media() 
                                                                            //AGORA CASO SEJA UM ARRAY NORMAL, converte para Vectorization.Vector
                                                                            : Vectorization.Vector(vetorValoresColuna).media() );
        }

        return vetorResultado;
    }

    /**
    * Calcula a média de cada coluna desta Vectorization.Matrix
    * @returns {Vectorization.Vector}
    */
    context.columnMean = context.mediaColunas;

    /**
    * Pega todos os elementos que estão dentro desta Vectorization.Matrix,
    * e deixa todos eles num unico Vectorization.Vector, desprezando as dimensões, e deste modo: concentrando tudo em um unico Vectorization.Vector. 
    * @returns {Vectorization.Vector}
    */
    context.planificar = function(){
        let novoVetorASerRetornado = Vectorization.Vector([]);
        Vectorization.Matrix(context.duplicar())
        .paraCadaLinha(
            function(iLinha, vetorDaLinha){
                const vetorDaLinha_Vector = Vectorization.Vector.isVectorizationVector(vetorDaLinha) ? vetorDaLinha : Vectorization.Vector(vetorDaLinha);
                novoVetorASerRetornado.acrescentarVetor( Vectorization.Vector( vetorDaLinha_Vector ).duplicar() );
            }); 

        return Vectorization.Vector(novoVetorASerRetornado);
    }

    /**
    * DIFERENTE DO context.extrairValoresColuna
    * Esse método extrai os valores de uma ou mais colunas,
    * NOTA: Isso vai retornar um Vectorization.Vector para cada coluna
    * e não recortar colunas da Vectorization.Matrix, então o resultado não será um Vectorization.Matrix
    * o resultado será um Vectorization.Vector, conteundo outros Vectorization.Vector(as colunas)
    * @param {Vectorization.Vector || Array} listaColunas - um Vectorization.Vector de indices(numeros inteiros)
    * @returns {Vectorization.Vector}
    */
    context.extrairValoresColunas = function( listaColunas='todasColunas' ){
        let listaColunas_Vector = listaColunas != 'todasColunas' ?
                                  Vectorization.Vector.isVectorizationVector(listaColunas) == false ? Vectorization.Vector(listaColunas) : listaColunas : 'todasColunas';
    
        let colunasExtraida = Vectorization.Vector([], {usarEscalares: false});

        if( listaColunas == 'todasColunas' ){
           //Para cada coluna
           Vectorization.Vector({
              valorPreencher: 1,
              //Vai criar uma iteração em cada coluna
              elementos: matrix1.columns

           }).paraCadaElemento(function(j, numeroColuna){
               let valoresExtraidosColunaAtual = context.extrairValoresColuna(numeroColuna);
               colunasExtraida.adicionarElemento( valoresExtraidosColunaAtual );
           });

        }else{
           //Para cada coluna a ser extraida
           listaColunas_Vector.paraCadaElemento(function(j, numeroColuna){
               let valoresExtraidosColunaAtual = context.extrairValoresColuna(numeroColuna);
               colunasExtraida.adicionarElemento( valoresExtraidosColunaAtual );
           });
        }

        return colunasExtraida;
    }

    /**
    * DIFERENTE DO context.extrairValoresColuna
    * SIMILAR ao context.extrairValoresColunas
    * 
    * Esse método extrai os valores de todas as colunas EXCETO UMA,
    * NOTA: Isso vai retornar um Vectorization.Vector para cada coluna
    * e não recortar colunas da Vectorization.Matrix, então o resultado não será um Vectorization.Matrix
    * o resultado será um Vectorization.Vector, conteundo outros Vectorization.Vector(as colunas)
    * @param {Vectorization.Vector || Array} listaColunas - um Vectorization.Vector de indices(numeros inteiros)
    * @returns {Vectorization.Vector}
    */
    context.extrairValoresColunasExceto = function(numeroColunaIgnorar){
        let colunasExtraida = Vectorization.Vector([], {usarEscalares: false});

        //Para cada coluna
        Vectorization.Vector({
            valorPreencher: 1,
            //Vai criar uma iteração em cada coluna
            elementos: matrix1.columns

        }).paraCadaElemento(function(j, numeroColuna){
            if( j != numeroColunaIgnorar )
            {
                let valoresExtraidosColunaAtual = context.extrairValoresColuna(j);
                colunasExtraida.adicionarElemento( valoresExtraidosColunaAtual );
            
            }else{
                //Faz nada, IGNORA
            }
        });

        return colunasExtraida;
    }

    /**
     * Faz o onehot em uma coluna especifica
     * retorna um Vectorization.Vector, contendo outros Vectorization.Vector(coluna) contendo valores booleanos,
     * para cada valor unico na coluna especifica ele vai percorrer cada valor existente na coluna especifica(numeroColuna), e verificar se o item atual da coluna da matrix é igual a esse valor unico atual
     * se sim, então vai colocar 1, caso contrario vai colocar 0
     * 
     * NOTA: Isso só faz o onehot para uma unica coluna especifica
     * e retorna um Vectorization.Vector para cada valor unico da coluna especifica a ser codificada
     * 
     * @param {Number} numeroColuna 
     * @param {Vectorization.Vector} dadosColunaAtual 
     * @returns {Vectorization.Vector}
     */
    context.aplicarCodificacaoONEHOT = function(numeroColuna, dadosColunaAtual){
        const valoresUnicosColunaAtual = dadosColunaAtual.valoresUnicos();

        //Cria as colunas que serão usadas
        const novasColunas_COLUNA_ATUAL = Vectorization.Vector({
            valorPreencher: Vectorization.Vector([], {usarEscalares: false}),
            elementos: valoresUnicosColunaAtual.elementos
        }, {
            usarEscalares: false
        });

        //Percorre essa numeroColuna coluna da matrix
        context.paraCadaLinha(function(ii){
            let dadosLinha = context.getLinha(ii);
            let dadosLinhaNACOLUNA = dadosLinha.lerIndice(numeroColuna);

            for( let jj = 0 ; jj < valoresUnicosColunaAtual.elementos ; jj++ )
            {
                const valorUnico = valoresUnicosColunaAtual.lerIndice(jj);
                const isIgual = dadosLinhaNACOLUNA.raw() == valorUnico;

                if( isIgual == true ){
                    novasColunas_COLUNA_ATUAL.lerIndice(jj)
                                             .adicionarElemento(1);

                }else{
                    novasColunas_COLUNA_ATUAL.lerIndice(jj)
                                             .adicionarElemento(0);
                }
            }
        });

        return novasColunas_COLUNA_ATUAL;
    }

    /**
    * Faz o onehot nas colunas definidas
    * @param {Number} numeroColunasQuero
    * @returns {Object} - objeto onde voce pode obter Vectorization.Vector(s) ou uma Vectorization.Matrix com os valores inclusos
    */
    context.oneHotColunas = function(numeroColunasQuero){
        const colunas_Vetor = context.extrairValoresColunas(numeroColunasQuero);

        /*
        * Vai fazer a codificação de cada coluna passada em numeroColunasQuero, 
        * E armazenar aqui no resultadoOperacao
        */
        const resultadoOperacao = Vectorization.Vector([], {usarEscalares: false});
        const resultadoMatrix = context.duplicar();

        //Para cada coluna que quero aplicar
        colunas_Vetor.paraCadaElemento(function(i){
            
            //Obtenho os dados da coluna
            const dadosColunaAtual = colunas_Vetor.lerIndice(i);
            const dadosCodificadosColunaAtual = context.aplicarCodificacaoONEHOT( i , dadosColunaAtual );
        
            resultadoOperacao.adicionarElemento(dadosCodificadosColunaAtual);

            //Vai jogando tudo isso dentro da Vectorization.Matrix copiada
            dadosCodificadosColunaAtual.paraCadaElemento(function(jColuna, elementoColuna){
                if( 
                    Vectorization.Vector.isVector( elementoColuna ) == true || 
                    Vectorization.BendableVector.isBendableVector( elementoColuna ) == true 
                ){
                    resultadoMatrix.adicionarColuna(elementoColuna);
                }
            });
        });

        return {
            resultado_vector: resultadoOperacao,
            matrix_incluida: resultadoMatrix,

            raw: function(){
                return resultadoOperacao.raw();
            },

            obterMatrix: function(){
                return this.matrix_incluida;
            },

            obterVector: function(){
                return this.resultado_vector;
            }
        };
    }

    /**
    * Calcula a correlação entre duas colunas(pelo indice) 
    */
    context.correlationColumns = function(indiceColuna1, indiceColuna2){
        const valoresColuna1 = context.extrairValoresColuna(indiceColuna1);
        const valoresColuna2 = context.extrairValoresColuna(indiceColuna2);
        return valoresColuna1.correlationWith( valoresColuna2 );
    }

    context._doDefaultBaseAfterCreate();

    //Se a opção advanced estiver ativa, ele roda um método adicional após criar a matrix
    if( context.isAdvancedMatrix == true ){
        context._matrix2Advanced();
    }

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    //Aplica arredondamentos, se o usuario desejar, mesmo não sendo um Vectorization.Matrix aleatoria
    if( context._config != undefined &&
        (
            context._config['aleatorio'] == undefined || context._config['aleatorio'] == false
        ) == true && 
        (
            context._config['arredondar'] != undefined ||
            context.configRecebidaUsuario['arredondar'] != undefined
        ) == true
    ){
        context.aplicarArredondamento(context._config['arredondar'] || context.configRecebidaUsuario['arredondar']);
    }

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    context.bloqueado = (config['bloqueado'] != undefined || classConfig['bloqueado'] != undefined) ? (config['bloqueado'] || classConfig['bloqueado']) : false;

    //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Vector
    if( context._isBloqueado() == true ){
        context.bloquearModificacoes();
    }

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            'permitirBloquear'
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    /** EXPORTAÇÂO DE DADOS  */

    /**
    * Método auxiliar para fazer download do arquivo CSV.
    * @param {string} conteudo Conteúdo do arquivo.
    * @param {string} nomeArquivo Nome do arquivo.
    */
    context.downloadArquivo = function(conteudo, nomeArquivo) {
        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {

            const blob = new Blob([conteudo], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = nomeArquivo;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
        }
    }

    /**
    * Exporta os dados de um objeto Vectorization.Matrix para um formato CSV com separador configurável.
    * @param {string|null} downloadArquivo Nome do arquivo para download (opcional).
    * @param {string} separador Separador de colunas (padrão: ',').
    * @returns {string} Conteúdo do CSV.
    */
    context.exportarCSV = function(downloadArquivo = null, separador = ',') {
        let csvConteudo = '';

        // Gera a linha de cabeçalho
        //const linhaCabecalho = Array(context.colunas).fill(0).map((_, index) => `Coluna_${index}`).join(separador);
        //csvConteudo += linhaCabecalho + '\n';

        // Percorre cada linha da matriz
        context.content.forEach(linha => {
            const linhaValores = linha.map( (indice, valor) => {
                // Escapa valores que contêm o separador ou aspas
                if (typeof valor === 'string' && (valor.includes(separador) || valor.includes('"'))) {
                    return `"${valor.replace(/"/g, '""')}"`;
                }
                return valor;
            }).raw().join(separador);

            // Adiciona a linha atual ao conteúdo do CSV
            csvConteudo += linhaValores + '\n';
        });

        //Corta o \n sozinho no final
        if( csvConteudo.endsWith('\n') ){
            csvConteudo = csvConteudo.slice(0, csvConteudo.length-String('\n').length);
        }

        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
            // Faz o download do arquivo, se solicitado
            if (downloadArquivo && downloadArquivo.endsWith('.csv')) {
                context.downloadArquivo(csvConteudo, downloadArquivo);
            }

        //Se for node
        }if( VECTORIZATION_BUILD_TYPE == 'node' ) {

        }

        return csvConteudo;
    }

    /**
    * Exporta os dados de um objeto Vectorization.Matrix para um formato TXT com separador configurável.
    * @param {string|null} downloadArquivo Nome do arquivo para download (opcional).
    * @param {string} separador Separador entre valores (padrão: tabulação '\t').
    * @returns {string} Conteúdo do TXT.
    */
    context.exportarTXT = function(downloadArquivo = null, separador = '\t') {
        let txtConteudo = '';

        // Gera as linhas do conteúdo TXT
        context.content.forEach(linha => {
            const linhaValores = linha.map( (indice, valor) => {
                // Formata o valor, se necessário
                if (typeof valor === 'string' && (valor.includes(separador) || valor.includes('"'))) {
                    return `"${valor.replace(/"/g, '""')}"`;
                }
                return valor;
            }).raw().join(separador);

            // Adiciona a linha ao conteúdo do TXT
            txtConteudo += linhaValores + '\n';
        });

        //Corta o \n sozinho no final
        if( txtConteudo.endsWith('\n') ){
            txtConteudo = txtConteudo.slice(0, txtConteudo.length-String('\n').length);
        }

        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
            // Faz o download do arquivo, se solicitado
            if (downloadArquivo && downloadArquivo.endsWith('.txt')) {
                context.downloadArquivo(txtConteudo, downloadArquivo);
            }

        //Se for node
        }else if( VECTORIZATION_BUILD_TYPE == 'node' ) {

        }

        return txtConteudo;
    }

    /**
	* Exporta os dados deste Vectorization.Matrix para um formato JSON
	*/
	context.exportarJSON = function( downloadArquivo=null ){
		
        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
            if(downloadArquivo && downloadArquivo.endsWith('.json') ){
                context.downloadArquivo( context.raw() , downloadArquivo );
            }

        //Se for node
        }if( VECTORIZATION_BUILD_TYPE == 'node' ) {
            
        }

		return context.raw();
	}

    /** IMPORTAR DADOS */

	/**
	* Carrega um arquivo CSV do computador via upload e injeta dentro deste DataStructure
	* @param {Function} callback
	* @param {string} separador Separador usado no CSV (padrão: ',')
	*/
	context.loadCSV = function(callback, separador = ',') {

        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {
            // Cria dinamicamente o elemento <input> do tipo "file"
            const inputFile = document.createElement("input");
            inputFile.type = "file";
            inputFile.accept = ".csv"; // Aceita apenas arquivos CSV

            // Adiciona o evento "change" para capturar o arquivo selecionado
            inputFile.addEventListener("change", function(event) {
                const file = event.target.files[0]; // Obtém o primeiro arquivo selecionado

                if (!file) return; // Caso nenhum arquivo seja selecionado, não faz nada

                const reader = new FileReader();

                // Lê o conteúdo do arquivo como texto
                reader.onload = function() {
                    try {
                        const csvData = reader.result;

                        // Divide as linhas do CSV
                        const linhas = csvData.split(/\r?\n/).filter(linha => linha.trim() !== '');

                        // Processa os dados (demais linhas)
                        const dadosTratados = linhas.map(linha => {
                            const valores = linha.split(separador).map(valor => valor.trim());

                            return valores;
                        });

                        context.content = dadosTratados.map(amostra =>
                            Object.values(amostra)
                        );
                        context._matrix2Advanced();
                        context.atualizarQuantidadeColunasLinhas();

                        context.columns = context.content[0]?.length || 0;
                        context.colunas = context.columns;

                        if (callback) {
                            // Chama o callback com os dados CSV
                            callback(dadosTratados, context);
                        }
                    } catch (error) {
                        console.error("Erro ao carregar o arquivo CSV:", error);
                        alert("O arquivo selecionado não é um CSV válido.");
                    }
                };

                // Lê o arquivo
                reader.readAsText(file);

                // Remove o elemento de input do DOM após a leitura
                document.body.removeChild(inputFile);
            });

            // Adiciona o elemento de input ao DOM para que possa ser utilizado
            document.body.appendChild(inputFile);

            // Simula um clique no input para abrir a janela de seleção de arquivo
            inputFile.click();

        //Se for node
        }if( VECTORIZATION_BUILD_TYPE == 'node' ) {

        }
	}

	/**
	* Carrega um arquivo TXT do computador via upload e injeta dentro deste DataStructure.
	* @param {Function} callback Função a ser chamada após carregar os dados.
	* @param {string} separador Separador usado no TXT (padrão: '\t').
	*/
	context.loadTXT = function(callback, separador = '\t') {

        if( VECTORIZATION_BUILD_TYPE == 'navegador' ) {

            // Cria dinamicamente o elemento <input> do tipo "file"
            const inputFile = document.createElement("input");
            inputFile.type = "file";
            inputFile.accept = ".txt"; // Aceita apenas arquivos TXT

            // Adiciona o evento "change" para capturar o arquivo selecionado
            inputFile.addEventListener("change", function(event) {
                const file = event.target.files[0]; // Obtém o primeiro arquivo selecionado

                if (!file) return; // Caso nenhum arquivo seja selecionado, não faz nada

                const reader = new FileReader();

                // Lê o conteúdo do arquivo como texto
                reader.onload = function() {
                    try {
                        const txtData = reader.result;

                        // Divide as linhas do TXT
                        const linhas = txtData.split(/\r?\n/).filter(linha => linha.trim() !== '');

                        // Processa os dados (demais linhas)
                        const dadosTratados = linhas.map(linha => {
                            const valores = linha.split(separador).map(valor => valor.trim());

                            return valores;
                        });

                        context.content = dadosTratados.map(amostra =>
                            Object.values(amostra)
                        );
                        context._matrix2Advanced();
                        context.atualizarQuantidadeColunasLinhas();

                        context.columns = context.content[0]?.length || 0;
                        context.colunas = context.columns;

                        if (callback) {
                            // Chama o callback com os dados TXT
                            callback(dadosTratados, context);
                        }
                    } catch (error) {
                        console.error("Erro ao carregar o arquivo TXT:", error);
                        alert("O arquivo selecionado não é um TXT válido.");
                    }
                };

                // Lê o arquivo
                reader.readAsText(file);

                // Remove o elemento de input do DOM após a leitura
                document.body.removeChild(inputFile);
            });

            // Adiciona o elemento de input ao DOM para que possa ser utilizado
            document.body.appendChild(inputFile);

            // Simula um clique no input para abrir a janela de seleção de arquivo
            inputFile.click();

        //Se for node
        }else if( VECTORIZATION_BUILD_TYPE == 'node' ) {

        }
	}

    //return context;
    //Cria um Proxy para permitir acessar os indices da matrix diretamente
    return new Proxy(context, {
        get: function(target, prop, receiver) {
          if (typeof prop === 'string' && !isNaN(prop)) {
            return target.content[Number(prop)];
          }
          return Reflect.get(target, prop, receiver);
        },

        set: function(target, prop, value) {
          //Consulta se a gravação/modificação de dados está bloqueada neste Vectorization.Matrix
          if( target._isBloqueado() == true ){
            throw 'Este Vectorization.Matrix está bloqueado para novas gravações!';
          }

          //Outros casos barrar
          if( prop == 'bloqueado' || prop == 'permitirDesbloquear' || context.isAtributoProtegidoPeloVectorization(prop) ){
            throw 'Você não pode modificar esta atributo do Vectorization.Matrix!';
          }

          if (typeof prop === 'string' && !isNaN(prop)) {
            target.content[Number(prop)] = value;
            return true;
          }
          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Matrix.isMatrix = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Matrix');
}

window.Vectorization.Matrix.isVectorizationMatrix = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Matrix');
}

module.exports = window.Vectorization.Matrix;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Matrix.js*/
/* ARQUIVO VECTORIZATION: ../src/Matrix-translation.js*/
/*
 * File Name: Matrix-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Matrix._translations = function(){
    const translatedMethods = {
        //English
        "deepLevel": "nivelProfundidade",
        "getDeepLevel": "nivelProfundidade",

        "dotProduct": "produtoEscalar",

        "dotProductMatrix": "produtoEscalarMatrix",

        "dotProductVector": "produtoEscalarVector",

        "multiplyMatrix": "multiplicarMatrix",

        "multiplyNumber": "multiplicarNumero",

        "multiplyVector": "multiplicarVetor",

        "addMatrix": "somarMatrix",

        "addNumber": "somarNumero",

        "addVector": "somarVetor",

        "subtractMatrix": "subtrairMatrix",

        "subtractNumber": "subtrairNumero",

        "subtractVector": "subtrairVetor",

        "divideMatrix": "dividirMatrix",

        "divideNumber": "dividirNumero",

        "divideVector": "dividirVetor",

        "powMatrix": "elevarMatrix",

        "powNumber": "elevarNumero",

        "powVector": "elevarVetor",

        "transposed": "tranposta",

        "oppostMatrix": "matrixOposta",

        "identity": "identidade",

        "extractColumnValues": "extrairValoresColuna",
        "extractColumnsValues": "extrairValoresColunas",
        "extractColumnsValuesExcept": "extrairValoresColunasExceto",

        "extractLineValues": "extrairValoresLinha",

        "blockModifications": "bloquearModificacoes",
        "unblockModifications": "desbloquearModificacoes",

        "planify": "planificar",

        "oneHotColumns": "oneHotColunas",
        "sliceLines": "slice",
        "sliceColumns": "sliceColunas",
        "sliceRegion": "recortarRegiao",

        "removeColumns": "removerColunas",
        "removeColumn": "removerColuna",

        //Portugues
        "obterTransposta": "transposta",
        "somarMatriz": "somarMatrix",
        "subtrairMatriz": "subtrairMatrix",
        "multiplicarMatriz": "multiplicarMatrix",
        "elevarMatriz": "elevarMatrix",
        "produtoEscalarMatriz": "produtoEscalarMatrix",
        "addColuna": "adicionarColuna",
        "preencherLinha": "zerarLinha",
        "preencherColuna": "zerarColuna",
        "preencherColunaOnde": "zerarColunaOnde",
        "paraCadaLinha": "forEach",
        "percorrerElementosColuna": "percorrerColuna",
        "mapearElementosColuna": "mapearColuna",
        "bloquear": "bloquearModificacoes",
        "desbloquear": "desbloquearModificacoes"
    };

    const translatedAttributes = {
        //Portugues
        "valorPreencher": "fillValue",
        "preencherValor": "fillValue",
        "matrizAvancada": "isAdvancedMatrix",
        "matrixAvancada": "isAdvancedMatrix",
        "linhas": "rows",
        "colunas": "columns",

        //English
        //Ingles
        "blocked": "bloqueado",
        "allowBlock": "permitirBloquear",
        "allowUnblock": "permitirDesbloquear",
        "deepMatrix": "matrixProfunda"
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Matrix._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Matrix-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/StringMatrix.js*/
/*
 * File Name: StringMatrix.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    require('./Root'); 
    require('./Scalar');
    require('./Vector');
    require('./StringVector');
    require('./Matrix');
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringMatrix = function( config=[], classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.StringMatrix._translations || null;
    classConfig['advanced'] = false;
    classConfig['usarTexto'] = true;

    let classeBaseVector = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBaseVector.translateAttributes_andReturn(classConfig, classConfig['translations']() );
    
    //Se o usuario tentar criar um vetor a partir de outro vetor, ele recria o propio vetor passado, mantendo a estrutura como ainda sendo um Vector
    if( Vectorization.StringMatrix.isStringMatrix(config) && config.objectName == 'StringMatrix' ){
        return Vectorization.StringMatrix( config.values() );
    }

    //O StringMatrix será baseado no Vectorization.Matrix
    let context = window.Vectorization.Matrix(config, classConfig);
    context.objectName = 'StringMatrix';
    context.extendedFrom = 'Matrix';
    context.path = 'Vectorization.StringMatrix';
    context.configRecebidaUsuario = config;

    /**
    * @override
    * Método que converte a matrix para uma matrix avançada, onde cada linha é um Vector 
    */
    context._matrix2Advanced = function(vectorClassConfig={}){
        for( let i = 0 ; i < context.content.length ; i++ )
        {
            const extraPropsOfLine = {... vectorClassConfig};
            extraPropsOfLine['index'] = i;
            extraPropsOfLine['usarTexto'] = true;

            context.content[i] = Vectorization.StringVector(context.content[i], extraPropsOfLine);
        }
        context.isAdvancedMatrix = true;
    }

    context._matrix2Advanced();

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    return context;
}

window.Vectorization.StringMatrix.isStringMatrix = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'StringMatrix' )
}
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringMatrix.js*/
/* ARQUIVO VECTORIZATION: ../src/StringMatrix-translation.js*/
/*
 * File Name: StringMatrix-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.StringMatrix._translations = function(){
    const translatedMethods = {
       
    };

    const translatedAttributes = {
       
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.StringMatrix._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/StringMatrix-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Random.js*/
/*
 * File Name: Random.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global;
    
    require('./Root'); 

    if( window.Vectorization.Scalar == undefined ){
        require('./Scalar');
    }

    if( window.Vectorization.Vector == undefined ){
        require('./Vector');
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

//Classe que possui métodos para gerar números aleatórios do Vectorization
window.Vectorization.Random = function( classConfig={} ){
    let context = {... classConfig};
    context.value = value;
    context.objectName = 'Random';
    context.path = 'Vectorization.Random';
    return context;
}

/**
* Métodos estáticos
*/
window.Vectorization.Random._sementes = [
    //Passos por semente
    {
        sequencia: [2, -5, 8, 0.5, 3, 4.8, 1, 0.00001, 12, 2, 3, 7, 9, 15, 25, 0.8, 1, 0,5],
        multiplicador: 0.5
    },
    {
        sequencia: [5.555555555555555, -13.88888888888889, 22.22222222222222, 1.3888888888888888, 8.333333333333334, 13.333333333333332, 2.7777777777777777, 0.00002777777777777778, 33.333333333333336, 5.555555555555555, 8.333333333333334, 19.444444444444443, 25, 41.666666666666664, 69.44444444444444, 2.2222222222222223, 2.7777777777777777, 0.152, 13.88888888888889],
        multiplicador: 1.5
    },
    {
        sequencia: [0.75, -1.875, 3, 0.1875, 1.1250000000000002, 1.8000000000000003, 0.375, 0.00000375, 4.500000000000001, 0.75, 1.1250000000000002, 2.625, 3.375, 5.625, 9.375, 0.30000000000000004, 0.375, 0, 1.875],
        multiplicador: 4.5
    },
    {
        sequencia: [-1.0666666666666667, 2.6666666666666665, -4.266666666666667, -0.26666666666666666, -1.5999999999999999, -2.56, -0.5333333333333333, -0.000005333333333333334, -6.3999999999999995, -1.0666666666666667, -1.5999999999999999, -3.7333333333333334, -4.8, -8, -13.333333333333334, -0.42666666666666664, -0.5333333333333333, -0.25, -2.6666666666666665],
        multiplicador: 8
    }
]

//Inicializa a vezesJaUsouAteAgora de todas elas, pra nao repetir os mesmos numeros
for( let i = 0 ; i < window.Vectorization.Random._sementes.length ; i++ ){
    const sequenciaAtual = window.Vectorization.Random._sementes[i];
    sequenciaAtual.vezesJaUsouAteAgora = 0;
    sequenciaAtual.indiceAtual = 0;
}

window.Vectorization.Random._numeroSementePadraoDefinida = 5;

//Extrai os dados da semente definida pelo úsuario
window.Vectorization.Random._get_dados_semente = function(numeroDaSemente){
    let iSemente = 0;
    let sementeAtual = {... window.Vectorization.Random._sementes[0]};
    let iContadorIteracao = 0;

    while( iContadorIteracao <= Number.parseInt(numeroDaSemente) )
    {
        if(iSemente > window.Vectorization.Random._sementes.length - 1){
            sementeAtual = {... window.Vectorization.Random._sementes[0]};
            iSemente = 0;
        }

        sementeAtual = {... window.Vectorization.Random._sementes[iSemente]};
        iSemente++;

        iContadorIteracao++;
    }

    if(sementeAtual){
        return sementeAtual;

    }else{
        throw 'Erro ao tentar obter os dados da semente!. Tente outra.'
    }
}

window.Vectorization.Random._sementeDefinida = window.Vectorization.Random._get_dados_semente( window.Vectorization.Random._numeroSementePadraoDefinida );

window.Vectorization.Random.definirSemente = function(numeroDaSemente){
    switch(typeof numeroDaSemente){
        case 'number':
            window.Vectorization.Random._sementeDefinida = window.Vectorization.Random._get_dados_semente(numeroDaSemente);
            window.Vectorization.Random._numeroSementeDefinida = numeroDaSemente;
            break;

        //Se for um objeto do Vectorization
        case 'object':
        case 'function':
            if( numeroDaSemente.sequencia != undefined &&
                numeroDaSemente.multiplicador != undefined &&
                numeroDaSemente.sequencia.length > 2 &&
                numeroDaSemente.vezesJaUsouAteAgora != undefined
            ){
                window.Vectorization.Random._sementeDefinida = window.Vectorization.Random._get_dados_semente(numeroDaSemente);
            }
            break;

    }
}

/**
* @param {Object} sementeAtual 
* @returns {Number}
*/
window.Vectorization.Random.proximoNumeroDaSequenciaSemente = function(sementeAtual){
    let sequenciaVector = Vectorization.Vector(sementeAtual.sequencia);
    if( sementeAtual.indiceAtual > sequenciaVector.length-1 ){
        sementeAtual.indiceAtual = 0;
    }

    let meuNumeroTal = sequenciaVector.readIndex(sementeAtual.indiceAtual);
    sementeAtual.indiceAtual++;
    sementeAtual.vezesJaUsouAteAgora++;

    //Vai variando os valores
    let operacaoAAplicar = sementeAtual.indiceAtual % 2 == 0 ? '+' : '-';

    if( sementeAtual.indiceAtual < sequenciaVector.length ){
        if( sementeAtual.numeroAnterior != undefined && typeof sementeAtual.numeroAnterior == 'number' ){
            switch(operacaoAAplicar){
                case '+':
                    sementeAtual.sequencia[sementeAtual.indiceAtual] += ( (1/100 * sementeAtual.numeroAnterior) );
                    break;
                case '-':
                    sementeAtual.sequencia[sementeAtual.indiceAtual] -= ( (1/100 * sementeAtual.numeroAnterior) );
                    break;
            }
        }
    }

    let numeroGeradoDeAgora = ( (meuNumeroTal * sementeAtual.multiplicador) / (sementeAtual.vezesJaUsouAteAgora < 100 ? sementeAtual.vezesJaUsouAteAgora+10 : sementeAtual.vezesJaUsouAteAgora) ) * meuNumeroTal * sementeAtual.multiplicador;
    sementeAtual.numeroAnterior = numeroGeradoDeAgora;
    return numeroGeradoDeAgora;
}

/**
 * Permite gerar um número aleatorio entre um número inicial e final
 * Isso respeita o template definido, fazendo com que os números gerado sejam sempre os mesmos
 * 
 * @param {Number} minimo 
 * @param {Number} maximo 
 * @param {Number} sementeDefinida 
 * @returns {Number}
 */
window.Vectorization.Random.gerarNumeroAleatorio = function(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida){
    //Verificar a semente
    let sementeAleatoria = null;
    if( sementeDefinida != undefined && typeof sementeDefinida == 'number' ){
        sementeAleatoria = window.Vectorization.Random._get_dados_semente(sementeDefinida);
    }else{
        sementeAleatoria = sementeDefinida;
    }

    //Gerar o valor
    let sequenciaVector = Vectorization.Vector(sementeAleatoria.sequencia);
    let base = sequenciaVector.media() + (Math.PI * sequenciaVector.media()/2);
    let meuNumeroQualquer = (base + (maximo / (minimo+1.2) ) * (25/100 * base)) + minimo;

    //Isso obriga o número a ser menor que o limite(valor máximo que definimos)
    let maxTentativas = 500;
    let quantidadeTentativas = 0;
    while( meuNumeroQualquer > maximo ){
        if( quantidadeTentativas > maxTentativas ){
            break;
        }

        meuNumeroQualquer = window.Vectorization.Random.proximoNumeroDaSequenciaSemente(sementeAleatoria);
        quantidadeTentativas++;
    }

    if( quantidadeTentativas > maxTentativas ){
        meuNumeroQualquer = meuNumeroQualquer - maximo;

        if( meuNumeroQualquer < minimo ){
            meuNumeroQualquer += (minimo/2.5) * (2/100 * base);
        }
    }

    meuNumeroQualquer += minimo;

    return meuNumeroQualquer;
}

/**
 * Permite gerar um número aleatorio entre um número inicial e final
 * Isso respeita o template definido, fazendo com que os números gerado sejam sempre os mesmos
 * 
 * @param {Number} minimo 
 * @param {Number} maximo 
 * @param {Number} sementeDefinida 
 * @returns {Number}
 */
window.Vectorization.Random.gerarNumeroInteiroAleatorio = function(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida){
    let numeroAleatorioAtual = window.Vectorization.Random.gerarNumeroAleatorio(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida);
    return Number.parseInt(numeroAleatorioAtual);
}

/**
 * Permite gerar um número aleatorio entre um número inicial e final
 * Isso respeita o template definido, fazendo com que os números gerado sejam sempre os mesmos
 * 
 * @param {Number} minimo 
 * @param {Number} maximo 
 * @param {Number} sementeDefinida 
 * @returns {Number}
 */
window.Vectorization.Random.gerarNumeroFloatAleatorio = function(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida){
    let numeroAleatorioAtual = window.Vectorization.Random.gerarNumeroAleatorio(minimo, maximo, sementeDefinida=window.Vectorization.Random._sementeDefinida);
    return Number.parseFloat(numeroAleatorioAtual);
}


//Cria uma cópia segura das sementes como elas estavam antes de serem manipuladas/utilizadas pelo usuario
window.Vectorization.Random._sementesIniciais = Vectorization.Vector([... window.Vectorization.Random._sementes.copyWithin()]).duplicar();
window.Vectorization.Random._sementeDefinidaInicial = {... window.Vectorization.Random._sementeDefinida};

window.Vectorization.Random.resetarEstadoInicial = function(){
    window.Vectorization.Random._sementes = window.Vectorization.Random._sementesIniciais.duplicar().valores();
    window.Vectorization.Random.definirSemente( window.Vectorization.Random._numeroSementePadraoDefinida );
    window.Vectorization.Random._sementeDefinida = {... window.Vectorization.Random._sementeDefinidaInicial};
    console.warn('sementes aleatórias redefinidas!')
}


module.exports = window.Vectorization.Random;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Random.js*/
/* ARQUIVO VECTORIZATION: ../src/Random-translation.js*/
/*
 * File Name: Random-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Random._translations = function(){
    const translatedMethods = {
        //English
        'generateRandomNumericalValue': 'gerarNumeroAleatorio',
        'generateRandomFloatNumericalValue': 'gerarNumeroFloatAleatorio',
        'generateRandomIntegerNumericalValue': 'gerarNumeroInteiroAleatorio',
        'especifyOriginalInitialPoint': 'definirSemente'
    };

    const translatedAttributes = {
        
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

let randomClasseBase = window.Vectorization.Base(window.Vectorization.Random);

//Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
randomClassConfig = randomClasseBase.translateAttributes_andReturn(window.Vectorization.Random, window.Vectorization.Random._translations() );

//Se existir uma tradução para a classe
if(window.Vectorization.Random._translations && typeof window.Vectorization.Random._translations === 'function'){
    randomClasseBase.applyTranslations( window.Vectorization.Random._translations() );
}

//Passando as configurações pra dentro da classe Vectorization.Random
let todasConfiguracoesClassConfig = randomClasseBase.getTodasConfiguracoesAplicadas();
let keysConfiguracoesClassConfig = [... Object.keys(randomClasseBase)];

for( let i = 0 ; i < todasConfiguracoesClassConfig.quantidadeDentro ; i++ )
{   
    let nomeConfiguracaoClassConfig = keysConfiguracoesClassConfig[i],
        valorConfiguracaoClassConfig = todasConfiguracoesClassConfig.configuracoesUsadas[nomeConfiguracaoClassConfig];

    if( window.Vectorization.Random[ nomeConfiguracaoClassConfig ] == undefined )
    {
        window.Vectorization.Random[ nomeConfiguracaoClassConfig ] = valorConfiguracaoClassConfig;
    }
}

module.exports = window.Vectorization.Random._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Random-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Envelope.js*/
/*
 * File Name: Envelope.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Um objeto chamado literalmente de Envelope, para permitir "envelopar" varios objetos de diversos tipos, e permitir executar algum método em todos eles.
 * Ao executar um método em um Envelope, ele vai executar esse método em cada objeto que ele está armazenando. E vai retornar um novo Envelope, conténdo os resultados, que podem ser números, vetores, matrizes, ou qualquer coisa que o método escolhido para ser aplicado retorne.
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 

    if( window.Vectorization.Random == undefined ){
        require('./Root'); 
        require('./Random'); 
    }

    if( window.Vectorization.Utilidades == undefined ){
        require('./Utilidades'); 
    }
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Envelope = function( arrayObjetos=[], classConfig={} ){
    //Define a tradução
    classConfig['translations'] = window.Vectorization.Envelope._translations || null;

    let classeBase = window.Vectorization.Base({... classConfig});

    //Aplica a tradução dos métodos, pra ser capaz de entender nomes de atributos em outros idiomas
    classConfig = classeBase.translateAttributes_andReturn(classConfig, classConfig['translations']() );

    let context = window.Vectorization.Base({... classConfig});

    context.objectName = 'Envelope';
    context.path = 'Vectorization.Envelope';
    context.arrayObjetos = arrayObjetos;

    context.adicionarObjeto = function( objeto ){
        context.arrayObjetos.push( objeto );
    }

    /**
    * Cria um contexto separado do contexto do Envelope, para permitir executar métodos dentro do Envelope em si, e não dentro dos objetos dele
    * @returns {Envelope.SeparatedContext}
    */
    context.separatedContext = function(){
        const objetos = context.arrayObjetos;

        //um contexto manipulavel que não roda nos objetos do Envelope, mais sim no própio Envelope em si, podendo manipular seus atributos e objetos armazenados de forma independente do propio Envelope
        return Vectorization.Base({

            contextEnvelope: context,

            path: 'Envelope.SeparatedContext',
            objectName: 'EnvelopeSeparatedContext',
            arrayObjetos: objetos,
            
            lerIndice: function( indice ){
                return this.contextEnvelope.arrayObjetos[indice];
            },

            adicionarElemento: function( obj ){
                this.contextEnvelope.adicionarObjeto(obj);
            },

            getArrayObjetos: function(){
                return this.contextEnvelope.arrayObjetos;
            },

            getEnvelope: function(){
                return this.contextEnvelope;
            },

            getObjetos: function(){
                return Vectorization.Envelope( this.contextEnvelope.arrayObjetos );
            },

            setObjetos: function(novoArrayObjetos){
                this.contextEnvelope.arrayObjetos = novoArrayObjetos;
            }

        });
    }
    context.getSeparatedContext = context.separatedContext;
    context.internalContext = context.separatedContext;
    context.getInternalContext = context.separatedContext;
    context.separated = context.separatedContext;
    context.it = context.separatedContext;
    context.getIt = context.separatedContext;
    context.edit = context.separatedContext;
    context.editIt = context.separatedContext;

    context.raw = function(){
        return context.arrayObjetos;
    }

    /*
    * Calcula a média de cada objeto que estiver dentro do Envelope
    * O tipo de retorno não tem uma flexibilide definida. Vai depender os objetos que temos dentro do Envelope e do tipo de retorno que o método usado retorna
    */
    //context.media = function(){
    //    let novoEnvelope = Vectorization.Envelope([], classConfig);
        
    //    for( let i = 0 ; i < context.arrayObjetos.length ; i++ ){
    //        novoEnvelope.adicionarObjeto( context.arrayObjetos[i].media() );
    //    }

    //    return novoEnvelope;
    //}

    context.storedClassConfig = classConfig || {};

    //Se existir uma tradução para a classe
    if(context._translations && typeof context._translations === 'function'){
        context.applyTranslations( context._translations() );
    }

    return new Proxy(context, {
        /*
        * Calcula o resultado do NOME_ALGUM_MÈTODO de cada objeto que estiver dentro do Envelope
        * O tipo de retorno não tem uma flexibilide definida. Vai depender os objetos que temos dentro do Envelope e do tipo de retorno que o método usado retorna
        *
        * PERMITE FAZER envelope.NOME_ALGUM_MÈTODO(); 
        * 
        * Por exemplo:
        *   V.Envelope([ vec1, vec2, matrix1 ]).algumaMetodo().raw()
        * 
        * Ele vai tentar executar o método 'algumaMetodo' dentro de cada objeto: vec1, vec2 e matrix1
        */
        get: function(target, prop) {
            if (typeof prop === 'string' && typeof target[prop] === 'undefined') {
                // Verifica se o método existe em cada objeto dentro de arrayObjetos
                return function(...args) {
                    // Cria um Envelope para guardar os resultados
                    let novoEnvelope = Vectorization.Envelope([], classConfig);

                    // Tenta executar o método em cada objeto e adiciona o resultado ao novo Envelope
                    for (let i = 0; i < target.arrayObjetos.length; i++) 
                    {
                        let obj = target.arrayObjetos[i];

                        if (typeof obj[prop] === 'function') {
                            novoEnvelope.adicionarObjeto(obj[prop](...args));  // Executa o método no objeto
                        }else{
                            novoEnvelope.adicionarObjeto(null);  // INDICA QUE O MÈTODO NÂO EXISTIA
                        }
                    }

                    return novoEnvelope;
                };
            }
            return target[prop];
        },

        set: function(target, prop, value) {
          return Reflect.set(target, prop, value);
        }
    });
}

/**
* Métodos estáticos
*/
window.Vectorization.Envelope.isEnvelope = function(obj){
    return (obj.objectName != undefined && obj.objectName == 'Envelope');
}

module.exports = window.Vectorization.Envelope;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Envelope.js*/
/* ARQUIVO VECTORIZATION: ../src/Envelope-translation.js*/
/*
 * File Name: Envelope-translation.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * Description: Provide translations for class methods
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }
}

if(!window.Vectorization){ window.Vectorization = {} };

window.Vectorization.Envelope._translations = function(){
    const translatedMethods = {
        "raw": "bruto"
    };

    const translatedAttributes = {
        "path": "caminho"
    };

    return {
        translatedMethods: translatedMethods,
        translatedAttributes: translatedAttributes
    };
}

module.exports = window.Vectorization.Envelope._translations;
/* FIM DO ARQUIVO VECTORIZATION: ../src/Envelope-translation.js*/
/* ARQUIVO VECTORIZATION: ../src/Vectorization.js*/
/*
 * File Name: Vectorization.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

var Vectorization_4Node = class{
    constructor(){
        if( typeof window !== 'undefined' && window.isbrowser == true ){
            throw 'This class only works in Node';
        }

        //Se for node
        if( window.isbrowser == false && window.iscompilation == false )
        {
            //Importando classe raiz
            this.Root = require('./Root');

            this.Utilidades = require('./Utilidades');

            //Importando numeros escalares
            this.Scalar = require('./Scalar');
            this.Scalar_translation = require('./Scalar-translation');

            //Importando Text
            this.Scalar = require('./Text');
            this.Scalar_translation = require('./Text-translation');

            //Importando Vetores
            this.Vector = require('./Vector');
            this.Vector_translation = require('./Vector-translation');

            //Importando Vetores de String
            this.StringVector = require('./StringVector');
            this.StringVector_translation = require('./StringVector-translation');

            this.Random = require('./Random');
            this.Random_translation = require('./Random-translation');

            //Importando Matrizes
            this.Matrix = require('./Matrix');
            this.Matrix_translation = require('./Matrix-translation');
            
            this.StringMatrix = require('./StringMatrix');
            this.StringMatrix_translation = require('./StringMatrix-translation');
        }

        return window.Vectorization;
    }
}; 

module.exports = new Vectorization_4Node();
/* FIM DO ARQUIVO VECTORIZATION: ../src/Vectorization.js*/

window.isbrowser = true;

window.iscompilation = true
window.isbrowser = false;

module.exports = new Vectorization_4Node();