/*
 * File Name: Root.js
 * Author Name: William Alves Jardim
 * Author Email: williamalvesjardim@gmail.com
 * 
 * LICENSE: MIT
*/

//Compatibilidade com NodeJS
if( typeof window === 'undefined' ){
    global.window = global; 
    
//Se for navegador
}else{
    if (typeof module === 'undefined') {
        globalThis.module = {};
    }

    globalThis.require = function(){};
}

if(!window.Vectorization){ window.Vectorization = {} };

/**
 * Base class for all other components.
 * @param {Object} config;
 * @returns {Vectorization.Base}
 */
window.Vectorization.Base = function(config){
    const context = {};
    context._config = config;
    context.objectName = 'Base';
    context.extendedFrom = 'Base';
    context.namespace = 'window.Vectorization';
    context.path = 'Vectorization.Base';
    context.autoGeneratedGetters = [];
    context.autoGeneratedSetters = [];
    context._translations = config.translations;
    context._pai = null;

    /**
    * Obtém o objeto pai deste objeto
    * Se existir 
    */
    context.getPai = function(){
        return context._pai;
    }

    /**
    * Obtém o objeto pai deste objeto
    * Se existir 
    */
    context.getFather = context.getPai;

    /**
    * Verifica se o valor deste objeto está presente em um Vectorization.Vector ou Vectorization.Matrix
    */
    context.in = function( objetoVerificar ){
        //Se este objeto for um Vector ou Matrix
        if( Vectorization.Matrix.isVectorizationMatrix( context ) == true ||
            Vectorization.Vector.isVectorizationVector( context ) == true 
        ){
            throw 'Ainda não implementado para verificar se Vetores e Matrizes estão presentes em outros Vetores e Matrizes!';
            
            //Se 'objetoVerificar' for um Vector ou Matrix
            if( Vectorization.Matrix.isVectorizationMatrix( objetoVerificar ) ||
                Vectorization.Vector.isVectorizationVector( objetoVerificar )
            ){
                
            }else{

            }

        //Se o este objeto for um Scalar ou Text
        }else{
            if( context.getTipo && 
                (context.getTipo() == 'Scalar' || context.getTipo() == 'Text')
            ){
                //Se 'objetoVerificar' for um Vector ou Matrix
                if( Vectorization.Matrix.isVectorizationMatrix( objetoVerificar ) == true ||
                    Vectorization.Vector.isVectorizationVector( objetoVerificar ) == true
                ){
                    return objetoVerificar.have( context.obterValor() );
                }
            }
        }
    }

    /**
    * Retorna o tipo do objeto
    * @returns {String}
    */
    context.getTipo = function(){
        return context.objectName;
    }

    context.isAtributoProtegidoPeloVectorization = function(nomeAtributo){
        let listaAtributosProtegidos = [
            
        ];

        let confereSePodeMexe = listaAtributosProtegidos.indexOf(nomeAtributo) != -1;
        return confereSePodeMexe == true ? true : false;
    }

    context.copyArgs = function(config){
        //Copia os argumentos
        let configKeys = Object.keys(config);
        for( let i = 0 ; i < configKeys.length ; i++){
            context[ configKeys[i] ] = config[ configKeys[i] ];
        }
    }

    context.copyArgsSeNaoExistir = function(config, aplicarBind=true){
        //Copia os argumentos
        let configKeys = Object.keys(config);

        for( let i = 0 ; i < configKeys.length ; i++){

            if( context[ configKeys[i] ] == undefined )
            {
                context[ configKeys[i] ] = config[ configKeys[i] ];
                if(aplicarBind == true && context[ configKeys[i] ].bind != undefined){
                    context[ configKeys[i] ].bind(context);
                }
            }

        }
    }

    context._doDefaultBaseAfterCreate = function(){
        context.createGettersFromOriginalProperties();
        context.createSettersFromOriginalProperties();
    }

    context.createGettersFromOriginalProperties = function(){
        //Getters
        Object.keys( context ).forEach( function(attrib){
            const nameOfGetter = `get${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfGetter] ){
                context[nameOfGetter] = function(){
                    return context[attrib];
                }
                context.autoGeneratedGetters.push(nameOfGetter);
            }
        });
    }

    context.createSettersFromOriginalProperties = function(){
        //Setters
        Object.keys( context ).forEach( function(attrib){
            const nameOfSetter = `set${String( String(attrib[0]).replace('_','').toUpperCase() + String(attrib.slice(1, attrib.length) )).replace('_','').replace('get', '').replace('getGet', '').replace('Get', '') }`;
            
            if( typeof context[attrib] != 'function' && !context[nameOfSetter] ){
                context[nameOfSetter] = function(valueToDefine){
                    context[attrib] = valueToDefine; 
                }
                context.autoGeneratedSetters.push(nameOfSetter);
            }
        });
    }

    //Métodos responsavel por fazer as traduções dos métodos
    context.translateMethods = function(translations) {
        let translationsKeys;

        //Traduz os métodos
        translationsKeys = Object.keys(translations.translatedMethods);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedMethods[nomeMetodoTraduzido];

           //Aplica a tradução
           if(typeof context[nomeOriginal] === 'function'){
               context[nomeMetodoTraduzido] = context[nomeOriginal].bind(context);
           }
        }
    }

    //Métodos responsavel por fazer as traduções dos atributos
    context.translateAttributes = function(translations) {
        let translationsKeys;

        //Traduz os atributos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           //Aplica a tradução no atributo
           if(context[nomeOriginal] != undefined && typeof context[nomeOriginal] != 'function' && !context[nomeMetodoTraduzido] ){
              context[nomeMetodoTraduzido] = context[nomeOriginal];
           }
        }
    }

    //Parecido com a função translateAttributes, porém ele faz essa tradução e retorna um objeto com as traduções aplicadas
    //No caso o translationsDicionario pode ser um objeto ja pronto que só precisa ser traduzido
    //Isso vai ser usado na inicialização de algumas classes como Vectorization.Matrix e Vectorization.Vector
    context.translateAttributes_andReturn = function(propioDicionario, translations){
        let translationsKeys;
        let novoObjeto = {... propioDicionario};

        //Traduz os atributos
        translationsKeys = Object.keys(propioDicionario);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
           const nomeMetodoTraduzido = translationsKeys[i];
           const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

           if( nomeOriginal != undefined && !propioDicionario[nomeOriginal] ){
               novoObjeto[nomeOriginal] = propioDicionario[nomeMetodoTraduzido];
           }
        }

        return novoObjeto;
    }

    //Para não ter problemas com atributos desatualizados
    context.atualizarAtributosTraduzidos = function(translations=context._internal_translations){
        let translationsKeys;

        //Pegar os atributos traduzidos
        translationsKeys = Object.keys(translations.translatedAttributes);

        //Percorre cada nome a ser traduzido
        for(let i = 0 ; i < translationsKeys.length ; i++)
        {
            const nomeMetodoTraduzido = translationsKeys[i];
            const nomeOriginal = translations.translatedAttributes[nomeMetodoTraduzido];

            if( nomeOriginal != undefined && 
                typeof context[nomeMetodoTraduzido] != 'function' && 
                typeof context[nomeOriginal] != 'function' &&
                context[nomeOriginal] != undefined &&
                context[nomeMetodoTraduzido] != undefined
            ){
                context[nomeMetodoTraduzido] = context[nomeOriginal];
            }
        }
    }

    //Start class
    context.copyArgs(config);
    context._doDefaultBaseAfterCreate();

    context.applyTranslations = function(translationFunction=null){
        //Se existir uma tradução para a classe
        if(context._translations && typeof context._translations === 'function'){
            context._internal_translations = translationFunction || context._translations();
            context.translateMethods( context._internal_translations );
            context.translateAttributes( context._internal_translations );
        }
    }

    context.applyTranslations(null);

    context.getTodasConfiguracoesAplicadas = function(){
        let todasConfiguracoesClassConfig = {};
        let keysConfiguracoesClassConfig = [... Object.keys(context)];

        for( let i = 0 ; i < keysConfiguracoesClassConfig.length ; i++ )
        {
            let nomeConfiguracaoClassConfig = keysConfiguracoesClassConfig[i],
                valorConfiguracaoClassConfig = context[nomeConfiguracaoClassConfig];
            
            todasConfiguracoesClassConfig[nomeConfiguracaoClassConfig] = valorConfiguracaoClassConfig;
        }

        return { 
                  configuracoesUsadas: todasConfiguracoesClassConfig,
                  quantidadeDentro: keysConfiguracoesClassConfig.length
               };
    }

    context.herdarFuncoes = function(referenciaObjeto){
        const templateObjetoCriado = referenciaObjeto();
        const contextObjetoCriado = templateObjetoCriado;
        
        //Aplica dentro deste objeto do Vectorization
        context.copyArgsSeNaoExistir(contextObjetoCriado); 
    }

    return context;
}

//Funções a nivel principal

/**
 * Gera uma matrix de identidade
 * @param {Number} ordem 
 * @returns {Vectorization.Matrix}
*/
window.Vectorization.matrixIdentidade = function(ordem){
    const NON_DIAGONAL_VALUE = 0;
    const DIAGONAL_VALUE = 1;
    let matrix = [];

    for( let i = 0 ; i < ordem ; i++ )
    {
        matrix[i] = [];
        for( let j = 0 ; j < ordem ; j++ )
        {
            //NA LINHA ATUAL, Toda vez que o indice do número for igual ao indice da linha, ele faz parte da diagonal principal
            if( j == i ){
                matrix[i][j] = DIAGONAL_VALUE;

            }else{
                matrix[i][j] = NON_DIAGONAL_VALUE;
            }
        }
    }

    const extraProps = {
        isIdentidade: true
    }

    return Vectorization.Matrix(matrix, extraProps);
}

window.Vectorization.identificarTipo = function(obj){
    //Se for um objeto do Vectorization
    if( obj instanceof Object && obj.objectName != undefined ){

        if( Vectorization.Scalar.isScalar( obj ) ){
            return 'Scalar';

        }else if( Vectorization.Text.isText( obj ) ){
            return 'Text';

        }else{
            return undefined;
        }

    }else{
        if( typeof obj == 'number' ){
            return 'Scalar';

        }else if( typeof obj == 'string' ){
            return 'Text';
        }
    }

    return undefined;
}

window.Vectorization.isAlgumValorVectorization = function(obj){
    return window.Vectorization.identificarTipo(obj) != undefined && 
           obj instanceof Object && 
           obj.objectName != undefined;
}

window.Vectorization.isAlgumVetorVectorization = function(obj){
    return window.Vectorization.Vector.isVectorizationVector(obj) ||
           window.Vectorization.StringVector.isVectorizationStringVector(obj) ||
           window.Vectorization.BendableVector.isVectorizationBendableVector(obj);
}

module.exports = window.Vectorization.Root;